I"03<p><em>이 포스트는 <a href="">Optimizing Java</a> 를 바탕으로 작성하였습니다.</em></p>

<h2 id="java-performancethe-wrong-way">Java Performance—The Wrong Way</h2>

<p>Java 초창기에 메서드 디스패치 성능은 최악이었습니다. 그래서 메소드를 잘게 나누는것보다 하나의 큰 메소드로 작성하는 게 좋다고 권고도 했습니다. 하지만 시간이 지나며 디스패치 성능이 좋아졌고, 최신 <strong>JVM(Java Virtual Machine)</strong> 에서는 <strong>Automatic Managed Inlining</strong> 덕분에 가상 디스패치조차 대부분의 <strong>Call Site</strong> 에서 사라졌습니다. 덩치 큰 메소드는 현대 JIT 컴파일러와는 어울리지 않게 되었습니다.</p>

<p>Java 의 우수한 성능 목표를 위해 필요한 여러가지 단면을 종합적으로 알아보겠습니다.</p>

<ul>
  <li>전체 소프트웨어 수명주기의 성능 방법론</li>
  <li>성능과 연관된 테스트 이론</li>
  <li>측정, 통계, 툴링</li>
  <li>분석 스킬</li>
  <li>하부 기술과 메커니즘</li>
</ul>

<p>일반적인 원칙은 아래와 같습니다.</p>

<ul>
  <li>JVM 을 더 빨리 작동시키는 스위치 같은건 없습니다.</li>
  <li>Java 를 더 빨리 실행하게 만드는 팁은 없습니다.</li>
  <li>비밀 알고리즘도 없습니다.</li>
</ul>

<h2 id="java-performance-overview">Java Performance Overview</h2>

<p>Java 성능의 본질을 이해하기 위해 Java 창시자의 한마디를 인용하겠습니다.</p>

<blockquote>
  <p>Java 는 블루칼라 언어입니다. 박사 학위 논문 주제가 아니라 일을 하려고 만든 언어입니다.</p>
</blockquote>

<p>Java 는 실용적인 언어였습니다. 하지만 Java 환경이 고성능 컴퓨팅 어플리케이션에 적합한 수준에 이른 건 비교적 최근에 핫스팟 같은 정교한 JVM 이 성숙했기 때문입니다.</p>

<p>실용성을 추구하는 Java 의 성격은 여러 방면에서 드러납니다. 그중 관리되는 <strong>서브시스템(Sub System)</strong> 이 가장 대표적입니다. 개발자가 일일이 용량을 세세하게 관리하는 부담을 덜어주고, 대신 저수준으로 제어 가능한 일부 기능을 포기하는 발상입니다.</p>

<p>단적으로, 메모리 관리가 그렇습니다. JVM 이 탈착형 가비지 수집 서브시스템 형태로 메모리를 자동 관리하여 메모리를 의식할 필요가 없습니다.</p>

<h2 id="performance-as-an-experimental-science">Performance as an Experimental Science</h2>

<p>Java / JVM 소프트웨어 스택은 복잡합니다. 자신이 처한 환경에 적응하며 고도로 최적화하는 JVM 을 기반으로 구축된 운영 시스템의 성능 양상은 상당히 미묘하고 복잡하게 나타날 수 있습니다. 이렇게 복잡한 지경까지 이른 건 무어의 법칙과 그로 인한 하드웨어 용량의 전무후무한 발전 때문일 것입니다.</p>

<blockquote>
  <p>소프트웨어 산업의 가장 경이적인 성과는 하드웨어 산업에서 꾸준히 이루어낸 혁신을 끊임없이 무용지물로 만들고 있응것입니다. - 헨리 페트로스키</p>
</blockquote>

<p>JVM 도 다른 시스템과 같이 최상의 성능을 발휘하기 위해선 어느 수준 이상의 스킬과 경험이 필요합니다.</p>

<blockquote>
  <p>명확하게 정의하지 않고 측정하는 건 백해무익하다 - 엘리 골드렛</p>
</blockquote>

<p>JVM 성능 튜닝은 기술, 방법론, 툴을 망라한 개념입니다. 즉, 성능은 다음과 같은 활동을 하며 원하는 결과를 얻기 위한 일종의 과학 실험입니다.</p>

<ul>
  <li>원하는 결과를 정의</li>
  <li>기존 시스템 측정</li>
  <li>요건을 충족시키기 위해 수단을 정한다</li>
  <li>개선 활동을 추진</li>
  <li>테스트</li>
  <li>목표가 달성됐는지 판단</li>
</ul>

<p>바람직한 성능 결과를 정의하고 판단하는 과정에서 정량적인 일련의 목표가 수립됩니다. 무엇을 측정할 지 대상을 확정하고 목표를 기록하는 행위가 중요한데 결국 이런 활동들이 프로젝트 <strong>아티팩트</strong> 와 제품의 일부를 형성합니다. 성능 분석은 비기능 요건을 정의하고 달성을 확인하는 활동입니다.</p>

<h2 id="a-taxonomy-for-performance">A Taxonomy for Performance</h2>

<p>성능 지표는 성능 분석의 어휘집이자, 튜닝 프로젝트의 목표를 정량적인 단위로 표현한 기준입니다. 성능 목표를 정의한 비기능 요건입니다.</p>

<p>다음은 일반적인 기본적인 성능 지표입니다.</p>

<ul>
  <li>Throughput</li>
  <li>Latency</li>
  <li>Capacity</li>
  <li>Utilization</li>
  <li>Efficiency</li>
  <li>Scalability</li>
  <li>Degradation</li>
</ul>

<h3 id="throughput">Throughput</h3>

<p><strong>처리율(Throughput)</strong> 은 시스템이 수행 가능한 작업 비율을 나타내는 지표입니다. 보통 일정 시간 동안 완료한 작업 단위 수로 표시합니다.</p>

<p>처리율이 실제 성능을 반영하는 의미 있는 지표가 되려면 수치를 얻은 기준 플랫폼에 대해서도 내용을 기술해야 합니다.(ex : 하드웨어 스펙, OS, 소프트웨어 스펙) 그리고 트랜잭션은 테스트할 때마다 동일해야 합니다. 처리율을 테스트할 때 실행간 <strong>워크로드(workload)</strong> 역시 일정하게 유지해야 합니다.</p>

<h3 id="latency">Latency</h3>

<p>성능 지표는 수도 배관에 빗대어 설명할 때가 많습니다. 1 초에 100리터 를 흘려보내는 수도관의 처리율은 바로 1 초에 처리되는 부피입니다. 이때 <strong>지연(latency)</strong> 는 수도관 자체의 길이에 해당합니다. 즉 하나의 트랜잭션을 처리하고 그 결과를 반대편 수도관 끝에서 바라볼 때 까지 소요된 시간입니다.</p>

<h3 id="capacity">Capacity</h3>

<p><strong>용량(capacity)</strong> 는 시스템이 보유한 작업 병렬성의 총량, 즉 시스템이 동시 처리 가능한 작업 단위 개수를 말합니다.</p>

<p>용량은 처리율과 밀접한 연관이 잇습니다. 시스템에 동시 부하가 증가할수록 처리율도 영향을 받습니다. 이런 이유로 보통 용량은 어떤 처리율 또는 지연 값을 전제로 가능한 처리량으로 표시합니다.</p>

<h3 id="utilization">Utilization</h3>

<p>성능 분석 업무 중 가장 흔한 태스크는 시스템 리소스를 효율적으로 활용하는 겁니다. 예를 들 CPU 라는 리소스는 놀리는 것보다 실제 작업 단위를 처리하는 데 쓰여야 온당합니다.</p>

<p><strong>사용률(Utilization)</strong> 은 워크로드에 따라서 리소스별로 천차만별입니다. 예를 들어, 계산 집약적 워크로드(ex : 그래픽 처리) 는 CPU 사용률이 100% 에 육박하지만 메모리 사용률은 얼마 안나옵니다.</p>

<h3 id="efficiency">Efficiency</h3>

<p>전체 시스템의 <strong>효율(Efficiency)</strong> 은 처리율을 리소스 사용률로 나눈 값으로 측정합니다. 같은 처리율을 더 많은 리소스를 쏟아부어야 달성할 수 있다면 분명 효율이 낮은겁니다.</p>

<h3 id="scalability">Scalability</h3>

<p>처리율이나 시스템 용량은, 처리하는 데 끌어 쓸 수 있는 리소스에 달려 있습니다. 리소스 추가에 따른 처리율 변화는 시스템 / 어플리케이션의 <strong>확장성(Scalability)</strong> 을 가늠하는 척도입니다. 시스템 확장성은 궁극적으로는 정확히 리소스를 투입한 만큼 처리율이 변경되는 형태를 지향합니다.</p>

<p>보통 시스템 확장성은 하나의 단순한 상수 인자가 아니라, 여러가지 인자들의 영향을 받습니다. 리소스를 어느정도까지 늘리면 선형적으로 확장되지만, 대부분 부하가 높아지면 완벽한 확장을 저해하는 한계점에 봉착하게됩니다.</p>

<h3 id="degradation">Degradation</h3>

<p>리퀘스트 개수가 증가하건, 리퀘스트 접수 속도가 증가하건 시스템이 더 많은 부하를 받으면 지연 그리고 처리율 측정값에 변화가 생깁니다.</p>

<p>그 변화는 사용률에 따라 다릅니다. 시스템을 덜 사용하고 있으면 측정값이 느슨하게 변하지만, 시스템이 풀 가동된 상태면 처리율이 더는 늘어나지 않는, 지연이 증가하는 양상을 띱니다. 이런 현상을 부하 증가에 따른 <strong>저하(degradation)</strong>라고 합니다.</p>

<h3 id="connections-between-the-observables">Connections Between the Observables</h3>

<p>다양한 측정값은 서로 연결돼 있습니다. 또 구체적인 상호 관계는 시스템이 풀 가동 중인지 여부에 따라 달라집니다.</p>

<p>예를 들어, 일반적으로 시스템 부하가 증가하면 사용률도 달라지지만, 시스템을 많이 사용하지 않는 시간에는 부하가 늘어도 사용률은 별로 눈에 띄게 증가하지 않을 수 있습니다. 반대로 이미 시스템에 상당한 부하가 걸려있는 상태면 부하가 조금만 늘어도 다른 측정값이 크게 변화할 수 있습니다.</p>

<p>확장성과 저하는 부하가 증가함에 따라 시스템 양상이 어떻게 바뀌는지 반영하는 지표입니다. 확장성을 감안하면 부하가 늘 때 가용 리소스도 함께 늘려야 하는데, 시스템이 이렇게 확장한 리소스를 제대로 활용할 수 있을지가 관건입니다. 한편, 부하는 늘었는데 리소스는 그대로라면 저하되는 성능 측정값이 있을것입니다.</p>

<p>워크로드 종류에 따라도 천차만별입니다.</p>

<h2 id="reading-performance-graphs">Reading Performance Graphs</h2>

<p>아래 그림 <code class="highlighter-rouge">Example 1</code> 은 부하가 증가하면서 예기치 않게 저하가 발생한 그래프입니다. 이런 형태를 보통 <strong>성능 엘보(Performance Elbow)</strong> 라고 합니다.</p>

<blockquote>
  <p>Example 1 - A performance elbow</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74532290-2e4ebe80-4f72-11ea-9068-88ffca601d5e.png" alt="image" /></p>

<p>이와 반대로 아래 그림 <code class="highlighter-rouge">Example 2</code> 는 클러스터에 장비를 추가함에 따라 거의 선형적으로 처리율이 확장되는 운이 좋은 케이스입니다. 이렇게 이상적인 모습에 가까운 결과는 환경이 극단적으로 순조로울때 가능합니다.</p>

<blockquote>
  <p>Example 2 - Near-linear scaling</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74532291-2ee75500-4f72-11ea-9aab-ffd9ec41920f.png" alt="image" /></p>

<p>아래 <code class="highlighter-rouge">Example 3</code> 은 태스크를 처리할 때 프로세서 개수를 늘려도 실행 속도를 최대 어느정도까지 높일 수 있는지를 나타내는 그래프입니다.</p>

<blockquote>
  <p>Example 3 - Amdahl’s Law</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74532293-30b11880-4f72-11ea-86f0-1f39cadfdcf5.png" alt="image" /></p>

<p>위 그림처럼 암달의 법칙에 따르면 많은 제약이 있습니다. 그래프 x 축은 대수 눈금인데 순차비율이 5% 인 알고리즘도 12배 시간을 단축하기 위해서는 프로세서가 32 개나 필요합니다. 코어를 아주 많이 늘린다 해도 20 배 이상 시간 단축이 어렵습니다.</p>

<p>JVM 가비지 수집 서브시스템의 메모리 사용 패턴은 하부 기술 떄문에 부하가 별로 없는 어플리케이션도 아래와 같은 톱니모양이 나타납니다.</p>

<blockquote>
  <p>Example 4 - Healthy memory usage</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74532295-31e24580-4f72-11ea-86aa-fd21bdc454bf.png" alt="image" /></p>

<p><code class="highlighter-rouge">Example 5</code> 는 <strong>피보나치 수열</strong> 을 ㄱ계산하는 어플리케이션을 실행하여 얻은 그래프로 어플리케이션에서 <strong>메모리 할당률</strong> 을 성능 튜닝할 때 아주 중요한 메모리 그래프입니다.</p>

<blockquote>
  <p>Example 5 - Sample problematic allocation rate</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74532296-33137280-4f72-11ea-99f1-f13329c7ad14.png" alt="image" /></p>

<p><code class="highlighter-rouge">Example 6</code> 은 시스템 리소스가 누수될 때 흔히 나타나는 징후입니다. 부하가 증가하면서 지표가 차츰 약화되다가 결국 시스템 성능이 급락하는 <strong>변곡점(Inflection Point)</strong> 에 이르게 됩니다.</p>

<blockquote>
  <p>Example 6 - Degrading latency under higher load</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74532298-34dd3600-4f72-11ea-8677-2aa48eb4fae1.png" alt="image" /></p>
:ET