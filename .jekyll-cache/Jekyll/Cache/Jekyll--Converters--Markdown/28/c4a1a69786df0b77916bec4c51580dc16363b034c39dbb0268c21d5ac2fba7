I"+<p><em>이 포스트는 <a href="https://github.com/ethereumbook/ethereumbook">Mastering Ethereum</a>를 바탕으로 작성하였습니다.</em></p>

<h2 id="digital-signatures">Digital Signatures</h2>

<p>디지털 서명은 네트워크에서 송신자의 신원을 증명하는 방법으로, 송신자가 자신의 비밀키로 암호화한 메시지를 수신자가 송신자의 공용 키로 해독하는 과정이다.</p>

<h3 id="the-elliptic-curve-digital-signature-algorithm">The Elliptic Curve Digital Signature Algorithm</h3>

<p>이더리움에서 사용하는 디지털 서명 알고리즘은 ECDSA 입니다. 타원 곡선의 <strong>개인키 - 공개키</strong> 쌍을 기반으로 합니다.</p>

<p>디지털 서명은 이더리움에서 3 가지 용도로 사용이됩니다.</p>

<ol>
  <li>이더리움 계정과 개인키의 소유자가 이더 지출 또는 컨트랙트 이행을 <strong>승인</strong>했음을 증명</li>
  <li><strong>부인방지(non-repudiation)</strong> 보장</li>
  <li>트랜잭션 데이터를 <strong>수정할 수 없음</strong>을 증명</li>
</ol>

<h3 id="how-digital-signatures-work">How Digital Signatures Work</h3>

<p>디지털 서명은 2 단계로 구성된 수학적 체계입니다. 1 번째 부분은 메세지에서 개인키를 사용하여 서명을 만드는 알고리즘입니다. 2 번째 부분은 누구나 메세지와 공개키만 사용하여 서명을 검증할 수 있게 하는 알고리즘 입니다.</p>

<h3 id="creating-a-digital-signature">Creating a digital signature</h3>

<p>이더리움의 ECDSA 구현에서 서명된 메세지는 트랜잭션 입니다. 트랜잭션의 RLP 로 인코딩된 데이터의 Keccak-256 의 해시입니다. 서명 키는 EOA 의 개인키입니다.</p>

<script type="math/tex; mode=display">Sig = F_{sig}(F_{keccak256}(m),k)</script>

<ul>
  <li><strong>k</strong> : 서명 개인키</li>
  <li><strong>m</strong> : RLP 인코딩된 트랜잭션</li>
  <li>$F_{keccak256}$ : Keccak-256 해시 함수</li>
  <li>$F_{sig}$ : 서명 알고리즘</li>
  <li><strong>Sig</strong> : 결과 서명</li>
</ul>

<p>함수 $F_{sig}$ 는 일반적으로 r 및 s 라고 하는 두 값으로 구성된 서명 Sig 를 생성합니다.</p>

<script type="math/tex; mode=display">Sig = (r,s)</script>

<h3 id="verifying-the-signature">Verifying the Signature</h3>

<p>서명을 확인하려면 서명(r, s) 과 시리얼라이즈된 트랜잭션 그리고 서명을 만드는데 사용된 개인키에 상응하는 공개키가 있어야 한다. 서명 확인은 공개키를 생성한 개인키의 소유자만이 트랜잭션에서 서명을 생성할 수 있다.</p>

<p>서명 알고리즘은 메세지, 서명자의 공개키 및 서명을 가져와서 서명이 메세지와 공개키에 유효하면 true 를 반환합니다.</p>

<h3 id="ecdsa-math">ECDSA Math</h3>

<p>서명은 2개의 r과 s로 구성된 서명을 생성하는 수학 함수 F_{sig} 에 의해 생성됩니다.</p>

<p>서명 알고리즘은 처음에는 일시적인 개인키를 암호학적인 안전한 방법으로 생성합니다. 이 임시 키는 이더리움 네트워크에서 서명된 트랜잭션을 보는 공격자가 발신자의 실제 개인키를 계산할 수 없도록 r 및 s 값을 계산하는데 사용합니다.</p>

<p>이 방법은 다음과 같은 이점이 있습니다.</p>

<ul>
  <li>임시 개인키로 사용되는 암호학적으로 안전한 난수 q</li>
  <li>q 로부터 생성된 상응하는 임시 공개키 Q와 타원곡선 생성자 점 G</li>
</ul>

<p>디지털 서명의 r 값은 일시적인 공개키 Q 의 x 좌표 입니다.</p>

<p>여기서 알고리즘은 다음과 같이 서명의 s 값을 계산합니다.</p>

<script type="math/tex; mode=display">s \equiv q^{-1}(Keccak256(m) + r*k) \quad(mod\,p)</script>

<ul>
  <li><strong>q</strong> : 일시적인 개인키</li>
  <li><strong>r</strong> : 일시적인 공개키 x 의 좌표</li>
  <li><strong>k</strong> : 서명 개인키</li>
  <li><strong>m</strong> : 트랜잭션 데이터</li>
  <li><strong>p</strong> : 타원 곡선의 소수 차수</li>
</ul>

<p>검증은 r 및 s 값과 보낸 사람의 공개키를 사용하여 타원 곡선의 한 지점인 값 Q 를 계산하는, 서명 생성 함수의 반대 프로세스입니다. 단계는 다음과 같습니다.</p>

<ol>
  <li>모든 입력이 올바르게 구성되어있는지 확인한다.</li>
  <li>$w=s^{-1}mod\,p$ 를 계산</li>
  <li>$u_1 = Keccak256(m) *w \,mod\, p$ 를 계산</li>
  <li>$u_2 = r*w\, mod\,p를 계산</li>
  <li>타원 곡선을 계산한다.$</li>
</ol>

<script type="math/tex; mode=display">Q \equiv u_1* G + u_2 * K\;(mod\,p)</script>

<ul>
  <li><strong>r, s</strong> : 서명 값</li>
  <li><strong>K</strong> : 서명자의 공개키</li>
  <li><strong>m</strong> : 서명된 트랜잭션 데이터</li>
  <li><strong>G</strong> : 타원 곡선 생성자 점</li>
  <li><strong>p</strong> : 타원 곡선의 소수 차수</li>
</ul>

<p>계산된 포인트 Q의 x 좌표가 r 과 같으면, 검증자는 서명이 유효하다고 결론을 내릴 수 있습니다.</p>
:ET