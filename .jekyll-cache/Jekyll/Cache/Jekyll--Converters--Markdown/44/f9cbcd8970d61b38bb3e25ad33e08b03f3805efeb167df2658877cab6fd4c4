I"fM<p><em>이 포스트는 <a href="https://github.com/ethereumbook/ethereumbook">Mastering Ethereum</a>를 바탕으로 작성하였습니다.</em></p>

<h2 id="the-ethereum-name-service-ens">The Ethereum Name Service (ENS)</h2>

<p>전통적인 인터넷에서 DNS 는 브라우저에서 사람이 읽을 수 있는 이름을 사용할 수 있게 해줍니다. DNS 는 브라우저에서 사용하는 이름을 IP 주소 해당 페이지 내에 다른 식별자로 해석한다. 이더리움 블록체인에서는 ENS(Ethereum Naming System) 가 이와 같은 문제를 탈중앙화된 방식으로 풀어줍니다.</p>

<p>예를 들어, 이더리움 재단의 기부 주소 <strong>0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359</strong> 는 ENS 를 지원하는 지갑에서는 간단하게 <code class="highlighter-rouge">ethereum.eth</code> 가 됩니다.</p>

<p>ENS 는 스마트 컨트랙트 이상의 기능이 있습니다. ENS 는 기본적으로 댑이고 탈중앙화 네임 서비스를 제공합니다. 또한 등록, 관리 그리고 등록된 이름의 경매를 위한 여러 댑이 ENS 기능을 지원합니다. ENS 는 댑이 다른 댑을 지원하기 위해 만들어지고, 댑의 생태계에 의해서 유지되고, 다른 댑에 포함되어 동작하는 등 댑들이 어떻게 협력하는지 보여줍니다.</p>

<h3 id="history-of-ethereum-name-services">History of Ethereum Name Services</h3>

<p>네임 등록은 <strong>네임 코인(Namcoin)</strong> 개척한 블록체인 최초 비화폐 어플리케이션이었습니다.</p>

<p>게스와 C++ 이더리움 클라이언트의 초기 릴리스에는 namereg 컨트랙트 내장되어 있으며, 네임 서비스를 위한 많은 제안과 ERC 가 만들어졌습니다. 그러나 2016년 부터 <strong>레지스타(registrar)</strong> 에 대한 작업이 시작되었습니다.</p>

<h3 id="the-ens-specification">The ENS Specification</h3>

<p>ENS 는 주로 3 가지 이더리움 개선 제안에 명시되어 있습니다.</p>

<ul>
  <li><strong>EIP-137</strong> : 기본 기능을 지정</li>
  <li><strong>EIP-162</strong> : .eth 루트에 대한 경매 시스템</li>
  <li><strong>EIP-181</strong> : 주소의 역 등록을 지정</li>
</ul>

<p>ENS 는 샌드위치 디자인 철학을 따릅니다. 맨 아래에는 매우 단순한 층이 있고, 그 다음에는 더 복잡하지만 대체 가능한 코드가 포함되어 있으며, 매우 간단한 최상위 계층은 모든 자금을 별도의 계정에 보관합니다.</p>

<h2 id="bottom-layer-name-owners-and-resolvers">Bottom Layer: Name Owners and Resolvers</h2>

<p>ENS 는 사람이 읽을 수 있는 이름 대신 <strong>노드(node)</strong> 로 작동합니다. 사람이 읽을 수 있는 이름은 <strong>네임해시(Namehash)</strong> 알고리즘을 사용하여 노드로 변환합니다.</p>

<p>ENS 의 기본 계층은 노드의 소유자만 자신의 이름에 대한 정보를 설정하고 하위 노드를 만들 수 있도록 하는 ERC137 에서 정의한 단순 스마트 컨트랙트 입니다.</p>

<p>기본 계층의 유일한 기능은 노드 소유자가 자신의 노드에 대한 정보(resolver) 를 설정하고 새 하위 노드의 소유자를 만들 수 있게 하는 기능입니다.</p>

<h3 id="the-namehash-algorithm">The Namehash algorithm</h3>

<p>네임해시는 어떤 이름이라도 그 이름을 식별하는 해쉬로 변환할 수 있는 재귀 알고리즘입니다.</p>

<p>네임해시는 재귀적으로 이름의 구성요소를 해시하여 유효한 입력 도메인에 대한 고유한 고정 길이 문자열을 생성합니다. 예를 들어, <code class="highlighter-rouge">subdomain.example.eth</code> 의 네임해시 노드는 <code class="highlighter-rouge">keccak('&lt;example.eth&gt; node) + keccak('&lt;subbdomain&gt;)</code> 입니다. 우리가 해결해야할 하위 문제는 <code class="highlighter-rouge">keccak('&lt;.eth&gt;' node) + keccak('&lt;example&gt;')</code> 인 <code class="highlighter-rouge">example.eth</code> 노드를 계산하는 거싱ㅂ니다. 먼저 <code class="highlighter-rouge">keccak(&lt;root node&gt;) + keccak('&lt;eth&gt;')</code> 인 eth 에 대한 노드를 계산해야합니다.</p>

<p>루트 노드는 재귀의 <strong>기본 케이스(base case)</strong> 라 부르는 것이며, 이것은 당연히 재귀적으로 정의할 수 없는데, 그렇지 않으면 알고리즘은 영원히 종료되지 않을 것입니다. 루트노드는 <code class="highlighter-rouge">0x0000000000000000000000000000000000000000000000000000000000000000</code> 로 정의합니다.</p>

<p>이 모든 것을 합치면, <code class="highlighter-rouge">subdomain.example.eth</code> 의 노드가 <code class="highlighter-rouge">keccak(keccak(keccak(0x0...0 + keccak('eth')) + keccak('example')) + keccak('subdomain'))</code> 으로 됩니다.</p>

<p>일반화하자면 네임해시 함수를 다음과 같이 정의할 수 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>namehash<span class="o">([])</span> <span class="o">=</span> 0x0000000000000000000000000000000000000000000000000000000000000000
namehash<span class="o">([</span>label, ...]<span class="o">)</span> <span class="o">=</span> keccak256<span class="o">(</span>namehash<span class="o">(</span>...<span class="o">)</span> + keccak256<span class="o">(</span>label<span class="o">))</span>
</code></pre></div></div>

<p>파이썬에서는 다음과 같습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">namehash</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">''</span><span class="p">:</span>
    <span class="k">return</span> <span class="s">'</span><span class="se">\0</span><span class="s">'</span> <span class="o">*</span> <span class="mi">32</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">label</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s">'.'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sha3</span><span class="p">(</span><span class="n">namehash</span><span class="p">(</span><span class="n">remainder</span><span class="p">)</span> <span class="o">+</span> <span class="n">sha3</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
</code></pre></div></div>

<p>따라서 mastering-ethereum.eth 에서는 다음과 같이 처리됩니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>namehash<span class="o">(</span><span class="s1">'mastering-ethereum.eth'</span><span class="o">)</span>
⇒ sha3<span class="o">(</span>namehash<span class="o">(</span><span class="s1">'eth'</span><span class="o">)</span> + sha3<span class="o">(</span><span class="s1">'mastering-ethereum'</span><span class="o">))</span>
⇒ sha3<span class="o">(</span>sha3<span class="o">(</span>namehash<span class="o">(</span><span class="s1">''</span><span class="o">)</span> + sha3<span class="o">(</span><span class="s1">'eth'</span><span class="o">))</span> + sha3<span class="o">(</span><span class="s1">'mastering-ethereum'</span><span class="o">))</span>
⇒ sha3<span class="o">(</span>sha3<span class="o">((</span><span class="s1">'\0'</span> <span class="k">*</span> 32<span class="o">)</span> + sha3<span class="o">(</span><span class="s1">'eth'</span><span class="o">))</span> + sha3<span class="o">(</span><span class="s1">'mastering-ethereum'</span><span class="o">))</span>
</code></pre></div></div>

<p>하위 도메인은 그 자체가 하위 도메인을 가질 수 있습니다. <code class="highlighter-rouge">subdomain.example.eth</code> 다음에 <code class="highlighter-rouge">sub.subdomain.example.eth</code>, 그 다음은 <code class="highlighter-rouge">sub.sub.subdomain.example.eth</code> 등이 될 수 있습니다.</p>

<p>값비싼 재계산을 피하기 위해 네임해시는 이름 자체에만 의존하기 때문에 주어진 이름의 노드를 미리 계산한 후 컨트랙트에 삽입하여 문자열 조작의 필요성을 제거하고 원시 이름의 구성요소 수에 관계없이 ENS 레코드를 즉시 검색할 수 있습니다.</p>

<h3 id="how-to-choose-a-valid-name">How to choose a valid name</h3>

<p>라벨과 도메인을 길이에 관계없이 사용할 수 있지만, 레거시 DNS 와의 호환성을 위해 다음 규칙을 권장합니다.</p>

<ul>
  <li>라벨은 각각 64 자를 넘지 않아야 한다.</li>
  <li>완전한 ENS 이름은 255 자를 넘지 않아야 한다.</li>
  <li>라벨은 하이픈으로 시작하거나 끝나서는 안되며, 숫자로 시작해서도 안 된다.</li>
</ul>

<h3 id="root-node-ownership">Root node ownership</h3>

<p>계층적 시스템의 결과 중 하나는 이것이 최상위 도메인(Top-Level Domain, TLD) 을 만들 수 있는 루트 노드의 소유자에 의존한다는 것이다.</p>

<p>궁금적인 목표는 새로운 TLD 들을 위한 탈중앙화된 의사결정 프로세스를 만드는 것이지만, 루트 노드는 4 of 7 멀티시그에 의해 컨트롤되고 있는데, 여러 국가에 그 키홀더들이 나누어져 있다. 그 결과, 변경을 위해서는 최소한 7명 중 4명의 키홀더가 동의해야만 합니다.</p>

<p>현재 이 키홀더의 목적과 목표는 커뮤니티와 합의하에 다음과 같은 작업을 하는 것입니다.</p>

<ul>
  <li>시스템이 일단 한번 검증되면 <code class="highlighter-rouge">.eth TLD</code> 의 임시 소유권을 보다 영구적인 컨트랙트로 마이그레이션하고 업그레이드한다.</li>
  <li>커뮤니티는 TLD 가 필요하다고 동의하면 새로운 TLD 들의 추가를 허용한다.</li>
  <li>그러한 시스템이 합의되고, 테스트되고, 구현될 때 루트 다중 서명의 소유권을 더 탈중앙화된 컨트랙트로 마이그레이션한다.</li>
  <li>최상위 저장소의 모든 버그 또는 취약점을 처리하는 최후의 수단으로 사용한다.</li>
</ul>

<h3 id="resolvers">Resolvers</h3>

<p>기본 ENS 컨트랙트는 이름에 메타데이터를 추가할 수 없다. 이것은 소위 <strong>리졸버(resolver) 컨트랙트</strong> 가 담당한다. 리졸버 컨트랙트는 앱과 관련된 스웜 주소, 앱에 지불할 주소 혹은 앱의 해시와 같은 이름에 대한 질문에 답변할 수 있는 사용자 생성 컨트랙트입니다.</p>

<h2 id="middle-layer-the-eth-nodes">Middle Layer: The .eth Nodes</h2>

<p>글을 쓰는 시점에서 스마트 컨트랙트에서 유일하게 등록할 수 있는 유일한 최상위 도메인은 .eth 입니다.</p>

<p>.eth 도메인은 경매 시스템을 통해 배포됩니다. 예약 목록이나 우선순위가 없으며, 이름을 얻는 유일한 방법은 시스템을 사용하는것입니다. 경매 시스템 코드는 상당히 복잡합니다. ENS 의 초기 개발 노력 대부분이 시스템의 이 부분에 포함되었습니다. 그러나 보관된 자금에 대한 리스크 없이 나중에 교체 및 업그레이드 할 수 있습니다.</p>

<h3 id="vickrey-auctions">Vickrey auctions</h3>

<p>이름은 수정된 비크레이 경매를 통해 배포된다. 전통적인 비크레이 경매에서는 모든 입찰자가 봉인된 입찰을 제출하고 모두가 동시에 공개합니다. 이때 가장 높은 입찰자가 경매에서 이기지만 두 번째로 높은 입찰가만 지불합니다. 그러므로 입찰자는 경매에 붙여진 이름의 실제 가치보다 더 적은 금액의 입찰을 하지 않게 됩니다. 실제 가치에 입찰하는것이 이길 확률을 높여주지만, 결국 지불하게 될 가격에는 영향을 미치지 않습니다.</p>

<p>블록체인에서는 일부 변경이 필요합니다.</p>

<h2 id="top-layer-the-deeds">Top Layer: The Deeds</h2>

<p>ENS 의 최상위 계층은 단일 목적을 지닌 또 다른 매우 단순한 컨트랙트다.</p>

<p>유저가 이름을 얻었을 때 그 돈은 실제로 아무데도 보내지는 않지만, 유저가 이름을 갖고 싶어 하는 기간 동안 잠겨있습니다. 이것은 보증된 바이백과 같이 동작합니다. 소유자가 더 이상 이름을 원하지 않으면 시스템으로 다시 판매하고 이더를 복구 할 수 있습니다.</p>

<p>단일 컨트랙트가 수백만 달러의 이더를 보유하는 것이 매우 위험하다는 것이 입증되었습니다. 그래서 ENS 는 각각의 이름에 대해 증서 컨트랙트를 생성합니다. 증서 컨트랙트는 간단합니다. 그리고 지금은 단일 계정에게만 전송되고 단일 엔티티에 의해서만 호출됩니다. 이 접근법은 버그로 인해 자금이 위험에 처할 수 있는 공격 영역을 크게 줄였습니다.</p>

<h2 id="registering-a-name">Registering a Name</h2>

<p>Vickrey Auction 에서 봤듯이, ENS 에 이름을 등록하는 과정은 4단계로 진행됩니다. 아래 <code class="highlighter-rouge">Example 1</code> 은 등록 일정을 보여주는 도표입니다.</p>

<blockquote>
  <p>Example 1 - ENS timeline for registration</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/73941973-8f9ede00-4931-11ea-997d-47a7f8eec52e.png" alt="image" /></p>

<p>사용 가능한 이름을 검색하고, <code class="highlighter-rouge">ethereumbook.eth</code> 라는 이름에 입찰하고, 입찰가를 공개하고, 이름을 보호하기 위해 몇 가지 사용자 친화적인 인터페이스 중 하나를 사용할 것이다.</p>

<p>ENS 탈중앙화 어플리케이션과 상호작용할 수 있는 ENS 웹 기반 인터페이스가 많이 있습니다. 이 예제에서는 메타마스크와 함께 마이크립토(MyCrypto) 인터페이스를 지갑으로 사용합니다.</p>

<p>먼저 우리가 원하는 이름을 사용할 수 있는지 확인해야 합니다. 이 책을 쓰는 동안 우리는 정말로 <code class="highlighter-rouge">mastering.eth</code> 라는 이름을 동록하려고 했지만, <code class="highlighter-rouge">Example 2</code> 같이 이미 사용된 것으로 나왔다. ENS 등록은 1년밖에 되지 않기 때문에 향후 해당 이름을 보유할 수 있습니다. 그동안 <code class="highlighter-rouge">ethereumbook.eth</code> 를 검색해 보겠습니다.</p>

<blockquote>
  <p>Example 2 - Searching for ENS names on MyCrypto.com</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/73935829-ce7a6700-4924-11ea-89dc-9eb903ff5c8d.png" alt="image" /></p>

<p>이제 이름을 사용할 수 있기 때문에 <code class="highlighter-rouge">Example 3</code> 을 진행하겠습니다. 메타마스크의 잠금을 해제하고 <code class="highlighter-rouge">ethereumbook.eth</code> 에 대한 경매를 시작하겠습니다.</p>

<blockquote>
  <p>Example 3 - Starting an auction for an ENS name</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/73935832-d0442a80-4924-11ea-845f-5004509542a0.png" alt="image" /></p>

<p><code class="highlighter-rouge">Example 4</code> 에서는 입찰을 해보겠습니다.</p>

<blockquote>
  <p>Example 4 - Placing a bid for an ENS name</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/73935834-d1755780-4924-11ea-95a6-6d332e418729.png" alt="image" /></p>

<p>마지막으로 SUBMIT 버튼을 클릭하여 트랜잭션을 확인하겠습니다.</p>

<blockquote>
  <p>Example 5 - MetaMask transaction containing your bid</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/73936041-447ece00-4925-11ea-8438-da0174caa22b.png" alt="image" /></p>

<p>이 방법으로 트랜잭션을 제출한 후 48 시간안에 입찰가를 공개하면, 우리가 요청한 입력은 우리의 이더리움 주소로 등록될 것입니다.</p>

<h2 id="managing-your-ens-name">Managing Your ENS Name</h2>

<p>ENS 이름을 등록하면 ENS 관리자 같은 사용자 친화적인 인터페이스를 사용하여 ENS 이름을 관리할 수 있습니다.</p>

<p>검색 상자에 관리하려는 이름을 입력하고, ENS 관리자 댑이 사용자를 대신하여 이름을 관리할 수 있도록 이더리움 지갑을 잠금 해제해야 합니다.</p>

<blockquote>
  <p>Example 6 - The ENS Manager web interface</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/73936039-434da100-4925-11ea-8b03-8429f9005683.png" alt="image" /></p>

<p>이 인터페이스에서 하위 도메인을 만들고, 리졸버 컨트랙트를 설정하고 각 이름을 댑 프론트엔드의 스웜 주소 같은 적절한 자원에 연결할 수 있습니다.</p>

<h3 id="creating-an-ens-subdomain">Creating an ENS subdomain</h3>

<p>먼저 경매 댑 하위 도메인을 만듭니다. 그리고 하위 도메인을 auction 이라는 이름을 붙입니다. 그래서 완전한 이름은 <code class="highlighter-rouge">auction.ethereumbook.eth</code> 가 될것입니다. 아래 <code class="highlighter-rouge">Example 7</code> 을 참고하면 됩니다.</p>

<blockquote>
  <p>Example 7 - Adding the subdomain auction.ethereumbook.eth</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/73936043-46489180-4925-11ea-8750-119b3673dfc0.png" alt="image" /></p>

<p>하위 도메인을 만들고 나면 이전에 도메인 <code class="highlighter-rouge">etereumbook.eth</code> 를 관리했던 것처럼 검색 상자에 다른 곳의 주소록을 입력하고 관리할 수 있습니다.</p>

<h3 id="ens-resolver">ENS Resolver</h3>

<p>ENS 에서 이름을 확인하는 과정은 두 단계로 이루어집니다.</p>

<ol>
  <li>ENS 레지스트리는 해시 후 해석할 이름과 함께 호출된다. 레코드가 존재하면 레지스트리는 리졸버의 주소를 리턴한다.</li>
  <li>리졸버는 요청된 자원에 적절한 메소드를 사용하여 호출한다. 리졸버는 원하는 결과를 반환한다.</li>
</ol>

<p>이 프로세스를 거치면 리졸버의 기능을 네이밍 시스템 자체와 분리하여 더 많은 유연성을 얻을 수 있습니다.</p>

<p>이름 소유자는 사용자 정의 리졸버를 사용하여 어떠한 타입이나 자원을 해석할 수 있으며, ENS 의 기능을 확장할 수도 있습니다.</p>

<p>경매 댑을 스웜 해시에 연결하고자 하면 아래 그림 <code class="highlighter-rouge">Example 8</code> 과 같이 컨텐츠 해석을 지원하는 공개 리졸버를 사용할 수 있습니다. 우리는 사용자 정의 리졸버를 코딩하거나 배포할 필요가 없습니다.</p>

<blockquote>
  <p>Example 8 - Setting the default public resolver for auction.ethereumbook.eth</p>
</blockquote>

<h3 id="resolving-a-name-to-a-swarm-hash-content">Resolving a Name to a Swarm Hash (Content)</h3>

<p><code class="highlighter-rouge">auction.ethereumbook.eth</code> 의 리졸버가 공개 리졸버로 설정되면, 스웜 해시를 이름의 컨텐츠로 반환하도록 설정할 수 있습니다.</p>

<blockquote>
  <p>Example 9 - Setting the ‘content’ to return for auction.ethereumbook.eth</p>
</blockquote>

<p>아래 그림은 경매 댑의 전체 아키텍처입니다.</p>

<blockquote>
  <p>Example 10 - Auction DApp architecture</p>
</blockquote>
:ET