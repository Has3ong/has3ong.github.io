I"<p><em>이 포스트는 <a href="">Optimizing Java</a> 를 바탕으로 작성하였습니다.</em></p>

<h2 id="interpreting-and-classloading">Interpreting and Classloading</h2>

<p>JVM 을 규정한 명세서에 따르면 JVM 은 스택 기반의 해석 머신입니다. 레지스터는 없지만 일부 결과를 실행 스택에 보관하며, 이 스택의 맨 위에 쌓인 값들을 가져와 계산합니다.</p>

<p>JVM 인터프리터의 로직은, 평가 스택을 이용해 중간값들을 담아두고 가장 마지막에 실행된 명령어와 독립적으로 프로그램을 구성하는 Operation Code 를 하나씩 순서대로 처리하는 <em>while 루프 안의 switch 문</em> 입니다.</p>

<p>java helloworld 명령을 내려 Java 어플리케이션을 실행하면 운영체제는 가상 머신 프로세스를 구동합니다. Java 가상환경이 구성되고 스택 머신이 초기화된 다음 실제 유저가 작성한 HelloWorld 클래스 파일이 실행됩니다.</p>

<p>어플리케이션의 Entry Point 는 <strong>HelloWorld.class</strong> 에 있는 <code class="highlighter-rouge">main()</code> 메소드 입니다. 제어권을 이 클래스로 넘기려면 가상 머신이 실행되기 전에 이 클래스를 로드해야 합니다.</p>

<p>여기에 Java ClassLoading 메커니즘이 관여합니다. Java 프로세스가 새로 초기화되면 사슬처럼 줄지어 연결된 클래스로더가 차례차례 작동합니다. 제일 먼저 부트스트랩 클래스가 시작하며 Java 런타임 코어 클래스를 로드합니다. 런타임 코어 클래스는 Java8 이전까지 <strong>rt.jar</strong> 파일을 가져오지만, Java9 이후부턴는 런타임이 모듈화되고 클래스 로딩 개념 자체가 달라졌습니다.</p>

<p>부투스트랩 클래스로더의 주 임무는, 다른 클래스로더가 나머지 시스템에 필요한 클래스를 로드할 수 있게 최소한의 필수 클래스 (java.lang.Object, Class, Classloader) 를 로드하는겁니다.</p>

<p>다음, 확장클래스 로더가 생깁니다. 부트스트랩 클래스 로더를 자기 부모로 설정하고 필요할 때 클래스로딩 작업을 부모에게 넘깁니다. 많이 쓰이지는 않지만, 확장 클래스로더를 이용하면 특정한 OS 나 플랫폼에 <strong>Native Code</strong> 를 제공하고 기본 환경을 오버라이드 할 수 있습니다. Java8 에 탑재된 자바스크립트 런타임 <strong>Nashorn</strong> 을 바로 확장클래스로더가 로드합니다.</p>

<p>마지막으로, 어플리케이션 클래스로더가 생성되고 지정된 클래스에 위치안 유저클래스를 로드합니다. 확장 클래스로더의 자식인 어플리케이션 클래스로더는 자주 사용됩니다.</p>

<p>Java 는 프로그램 실행 중 처음 보는 새 클래스를 <strong>dependency</strong> 에 로드합니다. 클래스를 찾지 못한 클래스 로더는 기본적으로 자신의 부모 클래스로더에게 룩업을 넘깁니다. 이렇게 부모로 거슬러 올라가다 부트스트랩도 룩업하지 못하면 <code class="highlighter-rouge">ClassNotFoundException</code> 에러가 납니다.</p>

<p>보통 Java 는 클래스를 로드할 때 런타임 환경에서 해당 클래스를 나타내는 <code class="highlighter-rouge">Class</code> 객체를 만듭니다. 하지만 똑같은 클래스를 상이한 클래스로더가 2 번 로드할 가능성도 있으니 주의해야합니다. 한 시스템에서 클래스는 풀 클래스명과 자신을 로드한 클래스로더, 2 가지 정보로 식별됩니다.</p>

<h2 id="executing-bytecode">Executing Bytecode</h2>

<p>Java 소스 코드는 실행되기까지 많은 변환 과정을 거칩니다. 첫 단계는 Java 컴파일러 <strong>javac</strong> 를 이용해 컴파일하는것으로, 보통 전체 빌드 프로세스의 한 부분으로 수행합니다.</p>

<p><code class="highlighter-rouge">javac</code> 가 하는 일은 Java 소스 코드를 바이트코드로 가득찬 <em>.class</em> 파일로 바꾸는 겁니다. 아래 그림 <code class="highlighter-rouge">Example 1</code> 에 보다시피 소스코드 번역 작업은 아주 간단합니다. <code class="highlighter-rouge">javac</code> 는 컴파일하는동안 최적화는 거의 하지 않기 때문에 생성된 바이트코드를 쉽게 해독할 수 있습니다. 또 <code class="highlighter-rouge">javap</code> 같은 표준 역어셈블리 툴로 열어보면 원래 Java 코드도 알아볼 수 있습니다.</p>

<blockquote>
  <p>Example 1 - Java class file compilation</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74535760-e03db900-4f79-11ea-9200-d196f922df29.png" alt="image" /></p>

<p>바이트코드는 특정 컴퓨터 아키텍처에 특정하지 않은, <strong>중간표현형(intermediate Representation, IR)</strong> 입니다. 컴퓨터 아키텍처의 지배를 받지 않으므로 이식성이 좋아 개발을 마친 소프트웨어는 JVM 지원 플랫폼 어디서건 실행할 수 있고 Java 에 대해서도 추상화 되어있습니다. JVM 이 코드를 실행하는 원리를 이해하는 중요한 첫 단추 입니다.</p>

<blockquote>
  <p>Scala 컴파일러 scalac 로 컴파일한 바이트코드도 JVM 에서 문제없이 작동합니다.</p>
</blockquote>

<p>컴파일러가 생성한 클래스 파일은 VM 명세서에 잘 정의된 구조를 갖추고 있습니다. 아래 표를 확인하시면 됩니다. JVM 은 클래스를 로드할 때 올바른 형식을 준수하고 있는지 검사합니다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Component</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Magic Number</td>
      <td style="text-align: left">0xCAFEBABE</td>
    </tr>
    <tr>
      <td style="text-align: left">Version of class file format</td>
      <td style="text-align: left">클래스 파일의 메이저 / 마이너 버전</td>
    </tr>
    <tr>
      <td style="text-align: left">Constant pool</td>
      <td style="text-align: left">클래스 상수들이 모여있는 위치</td>
    </tr>
    <tr>
      <td style="text-align: left">Access flags</td>
      <td style="text-align: left">추상 클래스, 정적 클래스 등 클래스 종류 표시</td>
    </tr>
    <tr>
      <td style="text-align: left">This class</td>
      <td style="text-align: left">현재 클래스 명</td>
    </tr>
    <tr>
      <td style="text-align: left">Superclass</td>
      <td style="text-align: left">슈퍼클래스 명</td>
    </tr>
    <tr>
      <td style="text-align: left">Interfaces</td>
      <td style="text-align: left">클래스가 구현한 모든 인터페이스</td>
    </tr>
    <tr>
      <td style="text-align: left">Fields</td>
      <td style="text-align: left">클래스에 들어있는 모든 필드</td>
    </tr>
    <tr>
      <td style="text-align: left">Methods</td>
      <td style="text-align: left">클래스에 들어있는 모든 메소드</td>
    </tr>
    <tr>
      <td style="text-align: left">Attributes</td>
      <td style="text-align: left">클래스가 가지고있는 모든 속성</td>
    </tr>
  </tbody>
</table>

<p>모든 클래스 파일은 매직넘버, 즉 이 파일이 클래스 파일임을 나타내는 4 byte 16 진수로 시작합니다. 그 다음 4 byte 는 클래스 파일을 컴파일할 떄 꼭 필요한 메이저 / 마이너 버전 숫자이빈다. 클래스를 실행하는 대상 JVM 이 컴파일한 JVM 버전과 다르면 <code class="highlighter-rouge">UnsupportedClassVersionError</code> 예외가 납니다.</p>

<p>상수 풀에는 코드에 등장하는 상수값이 있습니다. JVM 은 코드를 실행할 때 런타임에 배치된 메모리 대신, 이 상수 풀 테이블을 찾아보고 필요한 값을 참조합니다.</p>

<p>액세스 플래그 클래스는 적용한 수정자를 결정합니다. 첫 부분은 일반 프로퍼티로 public 클래스인지, Final 클래스인지 나타냅니다. 또한 인터페이스인지, 추상클래스인지도 액세스 플래그로 표시합니다. 플래그 끝부분은 클래스 파일이 소스코드에 없는 합성 클래스인지 애너테이션 타입인지, <strong>Enum</strong> 인지 각각 나타냅니다.</p>

<p>this 클래스, 슈퍼클래스, 인터페이스 클래스 엔트리는 클래스에 포함된 타입 계층을 나타내며, 각각 상수 풀을 가리키는 인덱스로 표시합니다. 필드와 메서드는 시그니처 비슷한 구조를 정의하고 여기에 수정자도 포함되어 있습니다. 속성 세트는 더 복잡하고 크기가 고정되지 않은 구조를 나타내는 데 사용합니다. 예를 들어, 메서드는 Code 속성으로 특정 메서드와 연관된 바이트코드를 나타냅니다.</p>

<p>아래 <code class="highlighter-rouge">Example 2</code> 는 클래스 파일 구조를 기억할 때 좋은 암기 요령입니다.</p>

<blockquote>
  <p>Example 2 - provides a mnemonic for remembering the structure.</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74535757-dfa52280-4f79-11ea-9d91-11288a55f2b7.png" alt="image" /></p>

<p>다음과 같이 간단한 클래스를 javac 로 컴파일하면 어떻게 되는지 알아보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>javap 라는 역 어셈블러를 이용해 <code class="highlighter-rouge">javap -c HelloWorld</code> 명령어로 HelloWorld 클래스 파일을 보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nf">HelloWorld</span><span class="o">();</span>
    <span class="nl">Code:</span>
       <span class="mi">0</span><span class="o">:</span> <span class="n">aload_0</span>
       <span class="mi">1</span><span class="o">:</span> <span class="n">invokespecial</span> <span class="err">#</span><span class="mi">1</span>    <span class="c1">// Method java/lang/Object."&lt;init&gt;":()V</span>
       <span class="mi">4</span><span class="o">:</span> <span class="k">return</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">[]);</span>
    <span class="nl">Code:</span>
       <span class="mi">0</span><span class="o">:</span> <span class="n">iconst_0</span>
       <span class="mi">1</span><span class="o">:</span> <span class="n">istore_1</span>
       <span class="mi">2</span><span class="o">:</span> <span class="n">iload_1</span>
       <span class="mi">3</span><span class="o">:</span> <span class="n">bipush</span>        <span class="mi">10</span>
       <span class="mi">5</span><span class="o">:</span> <span class="n">if_icmpge</span>     <span class="mi">22</span>
       <span class="mi">8</span><span class="o">:</span> <span class="n">getstatic</span>     <span class="err">#</span><span class="mi">2</span>    <span class="c1">// Field java/lang/System.out ...</span>
      <span class="mi">11</span><span class="o">:</span> <span class="n">ldc</span>           <span class="err">#</span><span class="mi">3</span>    <span class="c1">// String Hello World</span>
      <span class="mi">13</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">4</span>    <span class="c1">// Method java/io/PrintStream.println ...</span>
      <span class="mi">16</span><span class="o">:</span> <span class="n">iinc</span>          <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span>
      <span class="mi">19</span><span class="o">:</span> <span class="k">goto</span>          <span class="mi">2</span>
      <span class="mi">22</span><span class="o">:</span> <span class="k">return</span>
<span class="o">}</span>
</code></pre></div></div>

<p><em>HelloWorld.class</em> 파일을 구성하는 바이트코드가 어떻게 배치됐는지 나옵니다. <code class="highlighter-rouge">-v</code> 옵션을 주면 클래스파일 헤더 전체정보 등 자세한 내용까지 확인할 수 있습니다. 소스파일에는 메소드가 <code class="highlighter-rouge">main()</code> 하나뿐이지만 컴파일 후 변환된 클래스 파일에는 <code class="highlighter-rouge">javac</code> 클래스 파일에 디폴트 생성자를 자동 추가하므로 메서드는 총 2개 생성됩니다.</p>

<p>먼저 생성자에서 <code class="highlighter-rouge">this</code> 레퍼런스를 스택 상단에 올려놓는 <code class="highlighter-rouge">aload_0</code> 이 실행됩니다. 다음, <code class="highlighter-rouge">invokespecial</code> 명령이 호출되면 슈퍼생성자들을 호출하고 객체를 생성하는 등 특정 작업을 담당하는 인스턴스 메서드를 실행합니다. HelloWorld 클래스는 디폴트 생성자를 오버라이드한 코드가 없으므로 <code class="highlighter-rouge">Object</code> 디폴트 생성자가 매치됩니다.</p>

<blockquote>
  <p>OperationCode 는 JVM 내부 매우 간결한 형태로, 타입, 작업을 비롯해, 변수, 상수 풀, 스택 간 상호작용을 나타낸다.</p>
</blockquote>

<p>다음은 <code class="highlighter-rouge">main()</code> 메소드 입니다. <code class="highlighter-rouge">iconst_0</code> 으로 정수형 상수 0 을 평가 스택에 푸시하고 <code class="highlighter-rouge">istore_1</code> 으로 이 상숫값을 오프셋 1에 위치한 지역 변수에 저장합니다. 지역 변수 오프셋은 0 부터 시작하며, 0 번째 엔트리는 무조건 <code class="highlighter-rouge">this</code> 입니다. 그리고 오프셋 1의 변수를 스택으로 다시 로드한 뒤, 상수 10 을 푸시한 다음 <code class="highlighter-rouge">if_icmpge</code> 로 둘을 비교합니다.</p>

<p>처음 몇 차례는 비교 테스트가 실패하니 8 번 명령으로 넘어가겠습니다. 여기서 <code class="highlighter-rouge">System.out</code> 의 정적 메서드를 해석(<code class="highlighter-rouge">getstatic #2)</code> 하고 상수 풀에서 <strong>Hello World</strong> 라는 스트링을 로드(<code class="highlighter-rouge">ldc #3</code>) 한 다음, <code class="highlighter-rouge">invokevirtual</code> 명령으로 이 클래스에 속한 인스턴스 메서드를 실행합니다. 정숫값은 하나 증가(<code class="highlighter-rouge">iinc 1, 1</code>) 되고 <code class="highlighter-rouge">goto</code> 를 만나 다시 2번 명령으로 돌아갑니다.</p>

<p>이 과정이 <code class="highlighter-rouge">if_icmpge</code> 테스트가 성공할 때까지 반복되다가 마지막에 22번 명령으로 제어권이 넘어가 메서드가 반환됩니다.</p>

<h2 id="introducing-hotspot">Introducing HotSpot</h2>

<p>Java 의 성능 관점에서 큰 변화를 가져온 계기가있습니다. Java 의 핫스팟 가상 머신 입니다. 핫스팟을 선보인 이후 자바는  C / C++ 같은 언어에 필적하는 성능을 갖추게되었습니다. <code class="highlighter-rouge">(Example 3) </code></p>

<blockquote>
  <p>Example 3 - The HotSpot JVM</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74580331-43653500-4fe6-11ea-9f5a-1d747667fa8a.png" alt="image" /></p>

<p>언어 및 플랫폼 설계 과정에는 추구하는 바를 끊임없이 저울질하며 결정을 내려야 할 일이 따릅니다. <strong>Zero-Cost Abstraction</strong> 사상에 근거한 기계에 가까운 언어와 개발자의 생산성에 무게들 두고 엄격한 저수준 제어라는 일을 대행하는 언어 사이에서 갈등을 겪습니다.</p>

<blockquote>
  <p>C++ 코드는 제로 - 오버헤드 원칙을 준수합니다. 사용하지 않은 것에는 대가를 치르지 않습니다. 즉, 유저가 사용하는 코드보다 더 나은 코드를 건네줄 수 없습니다 - 비야네 스트롭스트룹</p>
</blockquote>

<p>제로- 오버헤드 원칙은 이론은 그럴싸하지만, 결국 컴퓨터와 OS 가 실제로 어떻게 작동해야 하는지 언어 유저가 아주 세세한 저수준까지 일러주어야 합니다. 성능 자체가 주 관심사가 아닌 개발자 입장에선 학습 부담으로 다가옵니다.</p>

<p>뿐만 아니라 이런 언어로 작성한 소스 코드를 빌드하면 플랫폼에 특정한 기계어로 컴파일 됩니다. 확실히 인터프리터, 가상 머신, 이식성 레이어 같은 대안 모델은 대부분 제로-오버헤드가 아니기 때문입니다.</p>

<p>Java 는 이러한 제로-오버헤드 추상화 철학을 동조하지 않습니다. 오히려 핫스팟은 프로그램의 런타임 동작을 분석하고 성능에 가장 유리한 방향으로 영리한 최적화를 적용하는 가상 머신입니다. 핫스팟 VM 의 목표는 개발자가 억지로 VM 틀에 맞게 프로그램을 욱여넣는 대신, 자연스럽게 Java 코드를 작성하고 바람직한 설계 원리를 따르도록 하는 것입니다.</p>

<h3 id="introducing-just-in-time-compilation">Introducing Just-in-Time Compilation</h3>

<p>Java 프로그램은 바이트코드 인터프리터가 가상화한 스택 머신에서 명렁어를 실행하여 시작됩니다. CPU 를 추상화한 구조라 다른 플랫폼에서도 클래스 파일을 문제없이 실행할 수 있지만, 프로그램이 성능을 최대로 내려면 네이티브 기능을 활용해 CPU 에서 직접 프로그램을 실행시켜야 합니다.</p>

<p>이를 위해 핫스팟은 프로그램 단위를 인터프리드 바이트코드에서 네이티브 코드로 컴파일합니다. 이를 <strong>JIT(Just-In-Time)</strong> 컴파일이라 알려진 기술입니다.</p>

<p>핫스팟은 인터프리티드 모드로 실행하는 동안 어플리케이션을 모니터링하면서 가장 자주 실행 되는 코드 파트를 발견해 JIT 컴파일을 실행합니다. 이렇게 분석을 하는 동안 미리 프로그래밍한 추적 정보가 취합되어 더 정교하게 최적화할 수 있습니다. 특정 메소드가 어느 한계치를 넘어가면 프로파일러가 특정 코드 섹션을 컴파일 / 최적화 합니다.</p>

<p>JIT 방식으로 컴파일하면 이점이 많습니다. 무엇보다 컴파일러가 해석 단계에서 수집한 추적 정보를 근거로 최적화를 결정하는게 가장 큰 장점입니다. 상황별로 수집한 다양한 정보를 토대로 핫스팟이 더 올바른 방향으로 최적화할 수 있습니다.</p>

<p>Java 처럼 <strong>프로필 기반 최적화(Profile-Guided Optimization, PGO)</strong> 를 응용하는 환경에서는 대부분의 AOT 플랫폼에서 불가능한 방식으로 런타임 정보를 활용할 여지가 있으므로 <strong>동적 인라이닝(Dynanic Inlining)</strong> 또는 <strong>가상 호출(Virtual Call)</strong> 등으로 성능을 개선할 수 있습니다. 또 핫스팟 VM 은 시동시 CPU 타입을 정확히 감지해 가능하면 특정 프로세서의 기능에 맞게 최적화 저용할 수 있습니다.</p>

<p>핫스팟의 컴파일 시스템과 더불어 자바를 독보적인 언어로 만들었던 특징은 바로 <strong>자동 메모리 관리(Automatic Memory Management)</strong> 기능입니다.</p>

<h2 id="jvm-memory-management">JVM Memory Management</h2>

<p>C / C++ 개발자는 메모리 할당 / 해제 작업을 직접 수행합니다. 메모리와 객체수명을 개발자가 관리하면 좀더 확정적인 성능을 낼 수 있습니다.</p>

<p>하지만 메모리 관리 용어나 패턴을 모르는 개발자가 많았습니다. 후에 등장안 C++, Objective-C 버전은 표준 라이브러리에 <strong>스마트 포인터(Smart Pointer)</strong> 를 도입해 성과를 거두었지만, Java 탄샌 무렵엔 부실한 메모리 관리로 에러가 나는 일이 많았습니다.</p>

<p>Java 는 <strong>가비지 수집(Garbage Collection, GC)</strong> 라는 프로세스를 이용해 힙 메모리를 자동 관리하는 방식으로 해결했습니다. 가비지 수집은 JVM 이 더 많은 메모리를 할당해야 할 때 불필요한 메모리를 회수하거나 재사용하는 Nondeterministic 프로세스 입니다.</p>

<p>일단 GC 가 실행되는동안 다른 어플리케이션은 모두 중단이됩니다. 이 중단 시간은 아주 짧지만, 어플리케이션 부하가 늘수록 이 시간도 무시할 수 없습니다.</p>

<h2 id="threading-and-the-java-memory-model">Threading and the Java Memory Model</h2>

<p>Java 는 1.0 부터 멀티스레드 프로그래밍을 지원했습니다. 다음 구문(Java8) 으로 Java 개발자가 얼마든지 스레드를 만들 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World!"</span><span class="o">);});</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div>

<p>원래 Java 환경 자체가 JVM 처럼 멀티스레드 기반인 까닭에 Java 프로그램이 작동하는 방식은 복잡해졋고, 성능 분석가가 작업하기도 힘들어졌습니다.</p>

<p>주류 JVM 구현체에서 Java 어플리케이션 스레드는 각각 정확히 하나의 전용 OS 스레드에 대응됩니다. 공유 스레드 풀을 이용해 전체 Java 어플리케이션 스레드를 실행하는 방안도 있지만, 쓸데없이 복잡도만 가중시킬 뿐, 만족할 만한 수준의 성능은 나오지 않았습니다.</p>

<p>그래서 1990 년대 후반 부터 Java 의 멀티스레드 방식은 아래 3 가지 원칙에 기반합니다.</p>

<ul>
  <li>Java 프로세스의 모든 스레드는 가비지가 수집되는 하나의 공통 힙을 가진다.</li>
  <li>한 스레드가 생성한 객체는 그 객체를 참조하는 다른 스레드가 액세스할 수 있다.</li>
  <li>기본적으로 객체는 Mutable 하다. 즉, 객체 필드에 할당된 값은 프로그래머가 애써 Final 키워드로 표시하지 않는 한 바뀔 수 있다.</li>
</ul>

<h2 id="meet-the-jvms">Meet the JVMs</h2>

<p>오라클이 제작한 핫스팟 이외에도 제각기 다른 방법으로 구현한 Java 구현체가 있습니다.</p>

<p><strong>OpenJDK</strong></p>

<p>Java 기준 구현체를 제공하는 오픈소스 프로젝트입니다. 오라클이 직접 주관 / 지원하며 자바 릴리즈 기준을 발표합니다.</p>

<p><strong>Oracle Java</strong></p>

<p>OpenJDK 가 기반이지만 오라클 상용라이선스로 재라이선스를 받았습니다. 오라클 Java 에 변경된 내용은 거의 전부 OpenJDK 공개 저장소에 커밋됩니다.</p>

<p><strong>Zulu</strong></p>

<p>Zulu 는 아줄 시스템이 제작한, Java 풀인증을 받은 무료 OpenJDK 구현체 입니다. 상용 라이선스 문제로 제약받을 일 없이 자유롭게 재배포할 수 있습니다. 아줄 시스템은 OpenJDK 유료 지원 서비스를 제공하는 업체입니다.</p>

<p><strong>IcedTea</strong></p>

<p>RedHat 의 작품으로 풀인증을 받았고 재배포 가능합니다. RedHat 은 Java 풀 인증을 받은 OpenJDK 기반의 Java 구현체를 제작한 최초의 회사입니다.</p>

<p><strong>Zing</strong></p>

<p>Zing 은 아줄 시스템이 제작한 고성능 상용 JVM 입니다. Java 풀인증을 받았고 64 bit Linux 에서만 작동합니다. 대용량 힙 메모리와 멀티 CPU 서버급 시스템을 위해 설계되었습니다.</p>

<p><strong>J9</strong></p>

<p>IBM 이 만든 J9 는 상용 JVM 으로 출발했다가 중간에 오픈 소스로 바뀌었습니다. 지금은 이클립스 OMR 기반으로 제작되며 IBM 상용 제품의 근간을 이루고 있습니다. Java 인증 체계와 완전히 호환됩니다.</p>

<p><strong>Avian</strong></p>

<p>Avian 은 100% Java 인증을 받은 구현체가 아닙니다. JVM 의 세부작동 원리가 궁금한 개발자에게 훌룡한 학습 도구 역할이 될 수 있습니다.</p>

<p><strong>Android</strong></p>

<p>안드로이드는 Non-JVM 가상 머신 용도의 다른 파일 포맷<em>(.dex)</em> 로 변환하기 위해 여러가지 Java 클래스 라이브러리 구현체와 <strong>교차 컴파일러(Cross Compiler)</strong> 를 사용했습니다.</p>

<p>안드로이드는 자체 런타임에서 직접 지원되는 OpenJDK 8 클래스 라이브러리를 사용하는 방향으로 옮아가는 추세입니다.</p>

<h3 id="a-note-on-licenses">A Note on Licenses</h3>

<p>JVM 구현체는 거의 다 오픈소스입니다.</p>

<p>그런데 오라클 Java 9 이후 라이선스 체계가 복잡해집니다. 오라클 Java 기반은 OpenJDK 코드 베이스지만 오픈 소스가 아닌, 상용 제품입니다. 하지만 호라클은 모든 OpenJDK Contributor 들이 OpenJDK 의 GPL 라이선스와 오라클사의 상용 라이선스, 이중 라이선스에 동의한다는 서명을 받았습니다.</p>

<p>지금까지 오라클 Java 의 업데이트 버전은 각각 OpenJDK <strong>Mainline Branch</strong> 에서 가져왔지만, 차기 릴리즈부터는 주 브랜치에는 패치하지 않겠다고 했습니다. 그러면 오라클 JDK 와 OpenJDK 격차가 점점 더 벌어지는 현상을 막을 수 있고, 소스가 동일한 오라클 JDK 와 OpenJDK 의 바이너리 간의 유의미한 차이도 사라질 겁니다.</p>

<h2 id="monitoring-and-tooling-for-the-jvm">Monitoring and Tooling for the JVM</h2>

<p>JVM 은 성숙한 실행 플랫폼으로 어플리케이션을 <strong>Instrumentation</strong>, Monitoring 등 다양한 기술을 제공합니다. 다음은 이런 종류의 툴에 쓰이는 몇가지 중요한 기술입니다.</p>

<ul>
  <li>Java Management Extensions(JMX)</li>
  <li>Java Agent</li>
  <li>JVM Tool Interface(JVMTI)</li>
  <li>Serviceability Agent(SA)</li>
</ul>

<p>JMX 는 JVM 위에 동작하는 어플리케이션을 제어하고 모니터링하는 툴입니다. JMX 는 JVM 을 관리하는 기본 수단입니다.</p>

<p><strong>Java Agent</strong> 는 Java 언어로 작성된 툴로 <code class="highlighter-rouge">java.lang.instrument</code> 인터페이스로 메소드 바이트코드를 조작합니다. 에이전트는 다음과 같이 JVM 에 시작 플래그를 추가해 설치합니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-javaagent</span>:&lt;에이전트 JAR 파일이 위치한 경로&gt;<span class="o">=</span>&lt;옵션&gt;
</code></pre></div></div>

<p>에이전트 JAR 파일에서 <strong>매니페스트(manifest.mf)</strong> 는 필수입니다. 또 Premain-Class 속성에 에이전트 클래스명을 반드시 지정해야합니다. 이 클래스는 Java 에이전트의 <strong>등록 후크(Registeratin hook)</strong> 역할을 수행하는 <code class="highlighter-rouge">public static premain()</code> 메소드를 구현해야 합니다.</p>

<p>Java 인스트루먼테이션 API 로도 부족하면 JVMTI 를 대신 사용할 수 있습니다. JVMTI 는 JVM 의 네이티브 인터페이스이기 때문에 JVMTI 를 사용하는 에이전트는 필히 C / C++ 같은 네이티브 컴파일 언어로 작성해야 합니다. 네이티브 에이전트가 JVM 이벤트를 모니터링하며 알림을 받을 수 있도록 만든 통신인터페이스입니다.</p>

<p>네이티브 에이전트를 설치하는 플래그는 Java 에이전트와 약간 다릅니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-agentlib</span>:&lt;에이전트 라이브러리명&gt;<span class="o">=</span>&lt;옵션&gt;
</code></pre></div></div>

<p>또는</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-agentpath</span>:&lt;에이전트 경로&gt;<span class="o">=</span>&lt;옵션&gt;
</code></pre></div></div>

<p>JVMTI 에이전트를 네이티브 코드로 개발해야 하는 요건 때문에 실행 중인 어플리케이션에 악영향을 미치거나 심지어 JVM 을 멎게할 만한 코드를 작성하기 쉽습니다.</p>

<p>그래서 가급적 JVMTI 보다 Java 에이전트로 작성하는게 낫고 코딩하기도 Java 에이전트가 더 쉽습니다. 물론 간혹 Java API 로 가져올 수 없는 정보는 JVMTI 로 가져올 수 밖에 없습니다.</p>

<p>마지막으로 SA 는 Java 객체, 핫스팟 자료 구조 모두 표출 가능한 API 툴을 모아놓은 것입니다. SA 를 이용하면 대상 JVM 에서 코드를 실행할 필요가 없습니다. 핫스팟 SA 는 <strong>심볼 룩업(Symbol Lookup)</strong> 같은 기본형을 이용하거나 프로세스 메모리를 읽는 방식으로 디버깅합니다. SA 는 코어파일 및 자바 프로세스까지 디버깅 가능합니다.</p>

<h3 id="visualvm">VisualVM</h3>

<blockquote>
  <p>Example 4 - VisualVM Monitor screen</p>
</blockquote>

<p>VisualVM 은 JVM <strong>Attach Mechanism</strong> 을 이용해 실행 프로세스를 실시간 모니터링 합니다. 프로세스가 로컬인지 원격인지에 따라 작동 방식이 다릅니다.</p>

<p>VisualVM 은 다섯 가지 탭을 기본 제공합니다.</p>

<p><img src="https://user-images.githubusercontent.com/44635266/74580952-e0c36780-4fec-11ea-931c-59cb00c68ff6.png" alt="image" /></p>

<p><strong>개요(Overview)</strong></p>

<p>Java 프로세스에 관한 요약 정보를 표시합니다. 프로세스에 전달한 전체 플래그와 시스템 프로퍼티, 그리고 실행 중인 Java 버전도 정확히 나옵니다.</p>

<p><strong>모니터(Monitor)</strong></p>

<p>예전 JConsole 과 비슷한 탭입니다. CPU, Heep, JVM 을 고수준에서 원격 측정한 값들이 표시됩니다. Load / UnLoad 된 클래스 개수 및 실행 중인 스레드 개수 등 현황도 알 수 있습니다.</p>

<p><strong>쓰레드(Thread)</strong></p>

<p>실행 중인 어플리케이션 각 스레드가 시간대별로 표시됩니다. 스레드별 상태와 짧은 변화 추이를 보면서 필요시 <strong>Thread Dump</strong> 를 뜰 수 있습니다.</p>

<p><strong>샘플러 및 프로파일러(Sample and Profiler)</strong></p>

<p>CPU 및 메모리 사용률에 관한 샘플링 결과가 표시됩니다.</p>

<p>VisualVM 은 플러그인 아키텍처 덕분에 다른 툴을 손쉽게 추가해서 핵심 기능을 보충할 수 있습니다. 플러그인 중에는 JMX 콘솔과 상호작용하거나 오래된 JConsole 과 연결 짓는 플러그인도 있고, VisualGC 라는 아주 유용한 가비지 수집 플러그인도 있습니다.</p>
:ET