I"<p><em>이 포스트는 <a href="https://github.com/darrenzeng2012/nohtyp/blob/master/High%20Performance%20Python%20-%20Practical%20Performant%20Programming%20for%20Humans%202014.pdf">High Performance Python</a> 를 바탕으로 작성하였습니다.</em></p>

<p>프로파일링을 해보면 병목 지점을 찾을 수 있기 때문에 최소한의 노력으로 성능을 최대한 끌어 올릴 수 있습니다. 큰 수고를 들이지 않고 속도를 크게 향상시키고 자원을 적게 사용하면서, 실용적인 측면에서 코드가 충분히 빠르고 유연한 것을 목표로 삼스빈다.</p>

<p>CPU 뿐만 아니라 측정 가능한 자원은 모두 프로파일링 할 수 있습니다.</p>

<h2 id="profiling-efficiently">Profiling Efficiently</h2>

<p>프로파일링의 첫 번째 목표는 시스템의 어느 부분이 느린지, 어디서 RAM 을 많이 쓰고 있는지, 디스크나 네트워크의 I/O 를 과도하게 발생시키는 부분이 어디인지 확인하는 것입니다.</p>

<p>프로파일링하면 평소보다 10 ~ 100 배 까지 실행 속도가 느려지는데, 최대한 실제 상황과 유사한 조건에서 검사하고 싶으면 검사할 부분만 따로 떼어내서 검사하도록 하는편이 좋습니다.</p>

<p>비선형적인 특성이 있어 결과를 쉽게 예측할 수 없으며, RAM 과 CPU 자원을 많이 잡아먹는 쥘리아 집합을 이용하여 분석해보겠습니다.</p>

<h2 id="introducing-the-julia-set">Introducing the Julia Set</h2>

<p><strong>쥘리아 집합(Julia Set)</strong> 은 CPU 를 많이 사용하는 함수 입니다. 쥘리아 집합은 복잡한 그림을 생성하는 프랙탈을 말합니다.</p>

<p>복소수 c 가 -0.62772-0.42193j 일때 쥘리아 집합 그래프인 <code class="highlighter-rouge">Example 1</code> 과 <code class="highlighter-rouge">Example 3</code> 을 그리는 코드를 분석하겠습니다. 쥘리아 집합의 각 픽셀은 독립적으로 계산되는데, 각 점은 데이터를 공유하지 않으므로 완전하게 병렬로 계산할 수 있습니다.</p>

<blockquote>
  <p>Example 1 - Julia set plot with a false grayscale to highlight detail</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74344011-4d711300-4def-11ea-9cc9-feaebae6ec7a.png" alt="image" /></p>

<p>c 값을 다르게 하면 다른 그림을 얻을 수 있습니다. 우리가 선택한 지점은 빠르게 계산되는 부분과 느리게 계산되는 부분이 있어 우리가 해볼 분석에 적합합니다.</p>

<p>이 문제의 흥미로운 점은 각 픽셀을 계산하는 데 몇번이나 반복되는지 가늠하기 어려운 루프를 사용합니다. 매 반복마다 이 좌푯값이 무한 루프에 빠지는지 인력에 의해 끌어당겨지는지 검사합니다. 반복 횟수가 적을수록 어두운 색을 띠고 반복이 거듭될 수록 밝은 색을 띕니다. 하얀색 영역은 계산하기 더 복잡하며, 때문에 생성되는 시간이 오래 걸립니다.</p>

<p>이제 검사할 z 좌표의 집합을 정의하겠습니다. 이 함수는 복소수 z 의 제곱에 c 를 더한 값을 계산합니다.</p>

<script type="math/tex; mode=display">f(z) = z^2 + C</script>

<p>z 의 절대값이 2보다 작으면 이 함수를 계속 반복합니다. 2 이상이면 루프를 빠져나가면서 이 좌표에 대해서 수행한 반복 횟수를 기록합니다. 종료 조건을 계속 충족하지 못하면 maxiter 만큼 반복한 후에 루프를 빠져나옵니다. 이 z 결과 값은 나중에 복소평면 상에 픽셀을 그리는 용도로 사용합니다.</p>

<p>의사코드는 아래와 같습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">:</span>
  <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxiter</span><span class="p">):</span> <span class="c1"># limited iterations per point
</span>    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">2.0</span><span class="p">:</span> <span class="c1"># has the escape condition been broken?
</span>      <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">c</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">break</span>
  <span class="c1"># store the iteration count for each z and draw later
</span></code></pre></div></div>

<p>먼저 그리게 될 쥘리아 집합 그래프의 왼쪽 위 코너 좌표를 -1.8-1.8j 로 하겠습니다. 값을 계산하기 전에 <code class="highlighter-rouge">abs(z) &lt; 2</code> 인 조건을 만족해야 합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.8</span><span class="o">-</span><span class="mf">1.8j</span>
<span class="k">print</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

<span class="mf">2.54558441227</span>
</code></pre></div></div>

<p>왼쪽 위 좌표는 만족하지 못해서 루프는 한 번도 실행되지 않고 종료됩니다. 따라서 z 값을 갱신하지 않으며, 이 좌표값은 0 입니다.</p>

<p>원짐인 <code class="highlighter-rouge">z = 0 + 0j</code> 의 경우를 보겠습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.62772</span><span class="o">-</span><span class="mf">0.42193j</span>
<span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="o">+</span><span class="mf">0j</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
  <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">c</span>
  <span class="k">print</span> <span class="s">"{}: z={:33}, abs(z)={:0.2f}, c={}"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span>
  
<span class="mi">0</span><span class="p">:</span> <span class="n">z</span><span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.62772</span><span class="o">-</span><span class="mf">0.42193j</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">=</span><span class="mf">0.76</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.62772</span><span class="o">-</span><span class="mf">0.42193j</span><span class="p">)</span>
<span class="mi">1</span><span class="p">:</span> <span class="n">z</span><span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.4117125265</span><span class="o">+</span><span class="mf">0.1077777992j</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">=</span><span class="mf">0.43</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.62772</span><span class="o">-</span><span class="mf">0.42193j</span><span class="p">)</span>
<span class="mi">2</span><span class="p">:</span> <span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.469828849523</span><span class="o">-</span><span class="mf">0.510676940018j</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">=</span><span class="mf">0.69</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.62772</span><span class="o">-</span><span class="mf">0.42193j</span><span class="p">)</span>
<span class="mi">3</span><span class="p">:</span> <span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.667771789222</span><span class="o">+</span><span class="mf">0.057931518414j</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">=</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.62772</span><span class="o">-</span><span class="mf">0.42193j</span><span class="p">)</span>
<span class="mi">4</span><span class="p">:</span> <span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.185156898345</span><span class="o">-</span><span class="mf">0.499300067407j</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">=</span><span class="mf">0.53</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.62772</span><span class="o">-</span><span class="mf">0.42193j</span><span class="p">)</span>
<span class="mi">5</span><span class="p">:</span> <span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.842737480308</span><span class="o">-</span><span class="mf">0.237032296351j</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">=</span><span class="mf">0.88</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.62772</span><span class="o">-</span><span class="mf">0.42193j</span><span class="p">)</span>
<span class="mi">6</span><span class="p">:</span> <span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="mf">0.026302151203</span><span class="o">-</span><span class="mf">0.0224179996428j</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.62772</span><span class="o">-</span><span class="mf">0.42193j</span><span class="p">)</span>
<span class="mi">7</span><span class="p">:</span> <span class="n">z</span><span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.62753076355</span><span class="o">-</span><span class="mf">0.423109283233j</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">=</span><span class="mf">0.76</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.62772</span><span class="o">-</span><span class="mf">0.42193j</span><span class="p">)</span>
<span class="mi">8</span><span class="p">:</span> <span class="n">z</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.412946606356</span><span class="o">+</span><span class="mf">0.109098183144j</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">=</span><span class="mf">0.43</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.62772</span><span class="o">-</span><span class="mf">0.42193j</span><span class="p">)</span>
</code></pre></div></div>

<p>조건을 만족하여 계속 z 값을 갱신합니다. 이 좌표는 300 번을 반복해도 검사 조건을 만족하여 언제 끝날지 알 수 없어 무한 루프에 빠질 수 있습니다. 최대 반복횟수(maxiter) 를 설정해 무한 루프를 방지하겠습니다.</p>

<p><code class="highlighter-rouge">Example 2</code> 는 위 계산을 50 번 반복한 그래프 입니다. <code class="highlighter-rouge">0+0j</code> 값이 매 8회마다 반복됨을 알 수 있습니다. 7회 까지는 편차를 가지고 있으므로, 무한 루프에 빠질지 아니면 반복이 끝날지 알 수 없습니다. 점선으로 표시된 cutoff 는 +2 경계를 나타냅니다.</p>

<blockquote>
  <p>Example 2 - Two coordinate examples evolving for the Julia set</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74430863-10655900-4ea1-11ea-9d1e-6c5165386f2f.png" alt="image" /></p>

<p><code class="highlighter-rouge">-0.82+0j</code> 에 대한 값은 그림에서 보듯 9 번 반복후에 경계값인 +2 를 넘어서고 루프를 빠져나옵니다.</p>

<h2 id="calculating-the-full-julia-set">Calculating the Full Julia Set</h2>

<p>이제 쥘리아 집합을 생성하는 코드를 살펴보겠습니다. 첫 번째 프로파일링을 위해 <code class="highlighter-rouge">time</code> 모듈을 임포트하고 몇 가지 좌표 상수를 정의하겠습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"""Julia set generator without optional PIL-based image drawing"""</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># area of complex space to investigate
</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.8</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.8</span><span class="p">,</span> <span class="mf">1.8</span>
<span class="n">c_real</span><span class="p">,</span> <span class="n">c_imag</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.62772</span><span class="p">,</span> <span class="o">-</span><span class="mf">.42193</span>
</code></pre></div></div>

<p>그래프를 그리기 위해 입력 데이터를 담을 두 리스트 <code class="highlighter-rouge">zs(복소수 z축)</code> 와 <code class="highlighter-rouge">cs(복소수 초기 조건)</code> 을 생성합니다. <code class="highlighter-rouge">cs</code> 를 단일 <code class="highlighter-rouge">c</code> 값으로 최적화 할 수 있습니다. 두 벌의 입력 리스트를 생성하는 이유는 나중에 RAM 사용량을 프로파일링 할 때 납득할 만한 데이터를 얻기 위함입니다.</p>

<p><code class="highlighter-rouge">zs</code> 리스트와 <code class="highlighter-rouge">cs</code> 리스트를 생성하기 위해 각 <code class="highlighter-rouge">z</code> 좌표를 알아야 합니다. 아래 예제에서 <code class="highlighter-rouge">xcoord</code> 와 <code class="highlighter-rouge">ycoord</code> 를 이용하여 이 좌표를 만들고 <code class="highlighter-rouge">x_step</code> 과 <code class="highlighter-rouge">y_step</code> 을 지정합니다. 약간 번잡해 보일 수 있는 이 과정은 numpy 나 다른 파이선 환경으로 코드를 포팅할 때 명확한 디버깅에 도움을 줍니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calc_pure_python</span><span class="p">(</span><span class="n">desired_width</span><span class="p">,</span> <span class="n">max_iterations</span><span class="p">):</span>
  <span class="s">"""Create a list of complex coordinates (zs) and complex parameters (cs), build Julia set, and display"""</span>
  <span class="n">x_step</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">desired_width</span><span class="p">))</span>
  <span class="n">y_step</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">desired_width</span><span class="p">))</span>
  <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">ycoord</span> <span class="o">=</span> <span class="n">y2</span>
  
  <span class="k">while</span> <span class="n">ycoord</span> <span class="o">&gt;</span> <span class="n">y1</span><span class="p">:</span>
    <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ycoord</span><span class="p">)</span>
    <span class="n">ycoord</span> <span class="o">+=</span> <span class="n">y_step</span>
  <span class="n">xcoord</span> <span class="o">=</span> <span class="n">x1</span>
  
  <span class="k">while</span> <span class="n">xcoord</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">:</span>
    <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xcoord</span><span class="p">)</span>
    <span class="n">xcoord</span> <span class="o">+=</span> <span class="n">x_step</span>
  <span class="c1"># Build a list of coordinates and the initial condition for each cell.
</span>  <span class="c1"># Note that our initial condition is a constant and could easily be removed;
</span>  <span class="c1"># we use it to simulate a real-world scenario with several inputs to
</span>  <span class="c1"># our function.
</span>  <span class="n">zs</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">cs</span> <span class="o">=</span> <span class="p">[]</span>
  
  <span class="k">for</span> <span class="n">ycoord</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">xcoord</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
      <span class="n">zs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="n">xcoord</span><span class="p">,</span> <span class="n">ycoord</span><span class="p">))</span>
      <span class="n">cs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="n">c_real</span><span class="p">,</span> <span class="n">c_imag</span><span class="p">))</span>
      
  <span class="k">print</span> <span class="s">"Length of x:"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">print</span> <span class="s">"Total elements:"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">zs</span><span class="p">)</span>
  
  <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
  <span class="n">output</span> <span class="o">=</span> <span class="n">calculate_z_serial_purepython</span><span class="p">(</span><span class="n">max_iterations</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>
  <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
  <span class="n">secs</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>
  <span class="k">print</span> <span class="n">calculate_z_serial_purepython</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">" took"</span><span class="p">,</span> <span class="n">secs</span><span class="p">,</span> <span class="s">"seconds"</span>
  
  <span class="c1"># This sum is expected for a 1000^2 grid with 300 iterations.
</span>  <span class="c1"># It catches minor errors we might introduce when we're
</span>  <span class="c1"># working on a fixed set of inputs.
</span>  <span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">33219980</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">zs</code> 와 <code class="highlighter-rouge">cs</code> 리스트를 만들어서 해당 리스트의 크기에 관한 정보를 담고 <code class="highlighter-rouge">output</code> 리스트에 <code class="highlighter-rouge">calculate_z_serial_purepython</code> 함수에서 계산한 값을 저장합니다. 마지막으로 <code class="highlighter-rouge">output</code> 리스트에 들어 있는 값들을 모두 더해 그 값이 기대한 값과 같은지 검사합니다.</p>

<p>코드는 <strong>결정적(deterministic)</strong> 이므로, 계산된 값을 모두 더해서 함수가 기대하는 대로 잘 작동하는지 확인할 수 있습니다. 예컨대 수치 코드를 바꿀 때면 알고리즘 논리를 깨지 않는지 확인하는게 중요합니다.</p>

<p>다음 예제에서는 앞서 논의했던 알고리즘을 구현하는 <code class="highlighter-rouge">calculate_z_serial_purepython</code> 함수를 정의하겠습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calculate_z_serial_purepython</span><span class="p">(</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
  <span class="s">"""Calculate output list using Julia update rule"""</span>
  <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">zs</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">zs</span><span class="p">)):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">zs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">maxiter</span><span class="p">:</span>
      <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">z</span> <span class="o">+</span> <span class="n">c</span>
      <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">return</span> <span class="n">output</span>
</code></pre></div></div>

<p>이제 계산 루틴을 호출하겠습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
  <span class="c1"># Calculate the Julia set using a pure Python solution with
</span>  <span class="c1"># reasonable defaults for a laptop
</span>  <span class="n">calc_pure_python</span><span class="p">(</span><span class="n">desired_width</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">max_iterations</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
</code></pre></div></div>

<p>위 코드를 실행하면 문제의 복잡도에 관한 결과를 얻을 수 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># running the above produces:
</span><span class="n">Length</span> <span class="n">of</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1000</span>
<span class="n">Total</span> <span class="n">elements</span><span class="p">:</span> <span class="mi">1000000</span>
<span class="n">calculate_z_serial_purepython</span> <span class="n">took</span> <span class="mf">12.3479790688</span> <span class="n">seconds</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Example 1</code> 에서는 반전된 회색조 그래프에서 고대비 색상은 함수의 어떤 부분이 빠르고 느리게 결정되는지 보여줍니다. <code class="highlighter-rouge">Example 3</code> 에선 색상을 더 단순화하여 검은 부분은 계산이 빠르고 하얀 부분은 계산이 오래 걸렸음을 나타냅니다.</p>

<p>동일한 데이터에 대해 2 가지 다른 표현을 통해 <strong>linear mapping</strong> 에서는 상세 내용이 많이 누락됨을 확인할 수 있습니다.</p>

<blockquote>
  <p>Example 3 - Julia plot example using a pure grayscale</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74433037-fc225b80-4ea2-11ea-9b4a-b78506a8a2b7.png" alt="image" /></p>

<h2 id="simple-approaches-to-timingprint-and-a-decorator">Simple Approaches to Timing—print and a Decorator</h2>

<p>위 예제에서는 코드의 곳곳에 <code class="highlighter-rouge">print</code> 문을 추가해서 실행 결과를 살펴봤습니다. 실행시간은 약간의 편차가 있습니다. 코드의 실행 시간을 반복 측정하여 정규분포도를 그려야 코드의 개선 정도를 정확하게 측정할 수 있습니다.</p>

<p>코드를 실행하는 동안 네트워크를 사용하거나 디스크와 RAM 에 접근하여 다른 작업이 돌고 있으면 실행 시간에 편차에 영향을 줄 수 있습니다.</p>

<p>디버깅과 프로파일링에서 <code class="highlighter-rouge">print</code> 문은 가장 흔한 방법입니다. 하지만, 코드가 금방 더럽혀지고, 작업이 끝난 후 정리하지 않으면 표준 출력을 모조리 잡아먹을것입니다.</p>

<p>조금 더 깨끗한 방법으로 데코레이터가 있습니다. 여기서는 시간을 측정하고 싶은 함수 위에 코드를 한 줄 추가하겠습니다.</p>

<p>아래 예제에서는 함수를 인자로 받는 <code class="highlighter-rouge">timefn</code> 이라는 함수를 새로 정의하겠습니다. 내부에서 새로 정의한 <code class="highlighter-rouge">measure_time</code> 은 가변길이 인자인 <code class="highlighter-rouge">*args</code> 와 키워드 인자인 <code class="highlighter-rouge">**kwargs</code> 를 받아, 실행하는 <code class="highlighter-rouge">fn</code> 함수로 넘겨줍니다. <code class="highlighter-rouge">fn</code> 함수를 호출하는 부분은 <code class="highlighter-rouge">time.time()</code> 으로 감사서 시간을 구하고 <code class="highlighter-rouge">fn.func_name</code> 과 함께 소요된 시간을 출력합니다.</p>

<p>이 데코레이터로 인한 오버헤드는 작지만 <code class="highlighter-rouge">fn</code> 을 많이 호출하면 느려진 성능을 체감할 수 있습니다. <code class="highlighter-rouge">@wraps(fn)</code> 을 사용해 데코레이터로 넘어온 함수의 이름과 <strong>docstring</strong> 을 호출하는 함수에서 확인할 수 있도록 했습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">timefn</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
  <span class="o">@</span><span class="n">wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">measure_time</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">print</span> <span class="p">(</span><span class="s">"@timefn:"</span> <span class="o">+</span> <span class="n">fn</span><span class="o">.</span><span class="n">func_name</span> <span class="o">+</span> <span class="s">" took "</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">)</span> <span class="o">+</span> <span class="s">" seconds"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
  <span class="k">return</span> <span class="n">measure_time</span>
  
<span class="o">@</span><span class="n">timefn</span>
<span class="k">def</span> <span class="nf">calculate_z_serial_purepython</span><span class="p">(</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
 <span class="o">...</span>
</code></pre></div></div>

<p>기존의 <code class="highlighter-rouge">print</code> 문은 그대로 둔채 이 코들=드를 실행하면 데코레이터를 사용한 측정값이 <code class="highlighter-rouge">calc_pure_python</code> 함수에서 측정한 값보다 살짝 짧음을 확인할 수 있습니다. 이는 함수 호출에 의한 오버헤드입니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Length of x: 1000
Total elements: 1000000
@timefn:calculate_z_serial_purepython took 12.2218790054 seconds
calculate_z_serial_purepython took 12.2219250043 seconds
</code></pre></div></div>

<p>위에서 작상한 함수의 실행속도를 측정하는 다른 방법으로 <code class="highlighter-rouge">timeit</code> 모듈을 사용할 수 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python <span class="nt">-m</span> timeit <span class="nt">-n</span> 5 <span class="nt">-r</span> 5 <span class="nt">-s</span> <span class="s2">"import julia1"</span>
 <span class="s2">"julia1.calc_pure_python(desired_width=1000, max_iterations=300)"</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">-s</code> 를 사용해서 모듈을 임포트합니다. <code class="highlighter-rouge">-r</code> 은 반복 횟수를 나타내고 <code class="highlighter-rouge">-n</code> 는 각 검사에서의 평균을 구합니다. 결과로는 전체 반복 중 가장 빠른 값을 출력합니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5 loops, best of 5: 13.1 sec per loop
</code></pre></div></div>

<p>평범한 컴퓨터에서 확인할 수 있는 CPU 부하의 편차에 대해 생각해볼만합니다. <code class="highlighter-rouge">Example 4</code> 는 코드의 소요 시간동안 코어의 사용률을 확인할 수 있습니다.</p>

<p>하나의 코어는 갑자기 사용률이 치솟지만 다른 코어는 모두 일상적인 작업을 수행하는것을 확인할 수 있습니다.</p>

<blockquote>
  <p>Example 4 - System Monitor on Ubuntu showing variation in background CPU usage while we time our function</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74434126-18bf9300-4ea5-11ea-9b63-d945ef9b55f2.png" alt="image" /></p>

<h2 id="simple-timing-using-the-unix-time-command">Simple Timing Using the Unix time Command</h2>

<p>유닉스 시스템에 포함된 표준 시스템 유틸리티를 사용해보겠습니다. 다음 명령은 프로그램의 실행 시간에 대해 다양한 정보를 제공하며, 코드 내부 구조에 대해서는 전혀 신경 쓰지 않는다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>/usr/bin/time <span class="nt">-p</span> python julia1_nopil.py
Length of x: 1000
Total elements: 1000000
calculate_z_serial_purepython took 12.7298331261 seconds
real 13.46
user 13.40
sys 0.04
</code></pre></div></div>

<p><em>/usr/bin/time</em> 이라 명시해서 쉘에 포함된 단순한 버전의 <code class="highlighter-rouge">time</code> 을 실행하지 않고 시스템의 <code class="highlighter-rouge">time</code> 명령어를 사용했음에 주목합니다. <code class="highlighter-rouge">time --verbose</code> 를 실행해서 에러가 발생하면 시스템 명령어가 아닌 쉘에 포함된 <code class="highlighter-rouge">time</code> 을 실행했을 가능성이 높습니다.</p>

<p><code class="highlighter-rouge">-p</code> 옵션을 주면 다음과 같은 3 가지 결과를 얻을 수 있습니다.</p>

<ul>
  <li>real 항목은 경과된 시간을 기록한다.</li>
  <li>user 항목은 CPU 가 커널 함수 외 작업을 처리하느라 소비한 시간을 기록한다.</li>
  <li>sys 항목은 커널 함수를 수행하는 데 소비한 시간을 기록한다.</li>
</ul>

<p><code class="highlighter-rouge">user</code> 와 <code class="highlighter-rouge">sys</code> 항목을 추가하여 CPU 에서 시간을 어떻게 사용했는지를 알아볼 수 있습니다.</p>

<p><code class="highlighter-rouge">time</code> 이 유용한 이유는 Python 을 필요하지 않기 때문입니다. <code class="highlighter-rouge">time</code> 명령어를 이용하면 python 실행파일이 시작되는 데 걸리는 시간도 측정할 수 있습니다. 장시간 실행되는 단일 프로세스를 사용하지 않고 초기에 많은 프로세스를 생성한다면 유의미한 시간입니다. 실행 시간이 짧은 스크립트에서는 초기 구동시간이 전체 시간에서 차지하는 비중이 높으므로 <code class="highlighter-rouge">time</code> 을 사용하면 좀 더 유용한 측정을 할 수 있습니다.</p>

<p><code class="highlighter-rouge">--verbose</code> 플래그를 넘기면 더 자세한 결과를 확인할 수 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>/usr/bin/time <span class="nt">--verbose</span> python julia1_nopil.py
Length of x: 1000
Total elements: 1000000
calculate_z_serial_purepython took 12.3145110607 seconds
    Command being timed: <span class="s2">"python julia1_nopil.py"</span>
    User <span class="nb">time</span> <span class="o">(</span>seconds<span class="o">)</span>: 13.46
    System <span class="nb">time</span> <span class="o">(</span>seconds<span class="o">)</span>: 0.05
    Percent of CPU this job got: 99%
    Elapsed <span class="o">(</span>wall clock<span class="o">)</span> <span class="nb">time</span> <span class="o">(</span>h:mm:ss or m:ss<span class="o">)</span>: 0:13.53
    Average shared text size <span class="o">(</span>kbytes<span class="o">)</span>: 0
    Average unshared data size <span class="o">(</span>kbytes<span class="o">)</span>: 0
    Average stack size <span class="o">(</span>kbytes<span class="o">)</span>: 0
    Average total size <span class="o">(</span>kbytes<span class="o">)</span>: 0
    Maximum resident <span class="nb">set </span>size <span class="o">(</span>kbytes<span class="o">)</span>: 131952
    Average resident <span class="nb">set </span>size <span class="o">(</span>kbytes<span class="o">)</span>: 0
    Major <span class="o">(</span>requiring I/O<span class="o">)</span> page faults: 0
    Minor <span class="o">(</span>reclaiming a frame<span class="o">)</span> page faults: 58974
    Voluntary context switches: 3
    Involuntary context switches: 26
    Swaps: 0
    File system inputs: 0
    File system outputs: 1968
    Socket messages sent: 0
    Socket messages received: 0
    Signals delivered: 0
    Page size <span class="o">(</span>bytes<span class="o">)</span>: 4096
    Exit status: 0
</code></pre></div></div>

<p>위 지표에서 가장 눈여겨봐야 하는 항목은 <code class="highlighter-rouge">Major (requiring I/O) page faults</code> 항목입니다. 이 항목은 운영체제가 RAM 에서 필요한 데이터를 찾을 수 없어 디스크에서 페이지를 불러 왔는지의 여부를 나타냅니다. 이는 속도를 느리게 하는 원인입니다.</p>

<h2 id="using-the-cprofile-module">Using the cProfile Module</h2>

<p>cProfile 은 표준 라이브러리에 내장된 프로파일링 도구입니다. 이는 큰 오버헤드를 유발하지만 그만큼 더 많은 정보를 제공합니다.</p>

<p>cProfile 은 표준 라이브러리가 제공하는 3 가지 프로파일러 중 하나로, 다른 두 가지는 hotshot / profile 입니다.</p>

<p>cProfile 모듈을 사용하여 코드를 실행해보겠습니다. cProfile 의 <code class="highlighter-rouge">-s cumulative</code> 옵션은 각 함수에서 소비한 누적 시간순으로 정렬되어 어떤 함수가 더 느린지 쉽게 확인할 수 있습니다. cProfile 의 출력 결과는 코드의 <code class="highlighter-rouge">print</code> 문이 모두 출력된 뒤에 화면에 출력합니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python <span class="nt">-m</span> cProfile <span class="nt">-s</span> cumulative julia1_nopil.py

calculate_z_serial_purepython took 9.342324018478394 seconds
         36222239 <span class="k">function </span>calls <span class="o">(</span>36222238 primitive calls<span class="o">)</span> <span class="k">in </span>10.050 seconds

   Ordered by: cumulative <span class="nb">time

   </span>ncalls  tottime  percall  cumtime  percall filename:lineno<span class="o">(</span><span class="k">function</span><span class="o">)</span>
      2/1    0.000    0.000   10.050   10.050 <span class="o">{</span>built-in method builtins.exec<span class="o">}</span>
        1    0.030    0.030   10.050   10.050 kakao.py:1<span class="o">(</span>&lt;module&gt;<span class="o">)</span>
        1    0.540    0.540   10.019   10.019 kakao.py:9<span class="o">(</span>calc_pure_python<span class="o">)</span>
        1    7.324    7.324    9.342    9.342 kakao.py:51<span class="o">(</span>calculate_z_serial_purepython<span class="o">)</span>
 34219980    2.019    0.000    2.019    0.000 <span class="o">{</span>built-in method builtins.abs<span class="o">}</span>
  2002000    0.126    0.000    0.126    0.000 <span class="o">{</span>method <span class="s1">'append'</span> of <span class="s1">'list'</span> objects<span class="o">}</span>
        1    0.011    0.011    0.011    0.011 <span class="o">{</span>built-in method builtins.sum<span class="o">}</span>
        1    0.000    0.000    0.000    0.000 &lt;frozen importlib._bootstrap&gt;:978<span class="o">(</span>_find_and_load<span class="o">)</span>
        1    0.000    0.000    0.000    0.000 &lt;frozen importlib._bootstrap&gt;:948<span class="o">(</span>_find_and_load_unlocked<span class="o">)</span>
        1    0.000    0.000    0.000    0.000 &lt;frozen importlib._bootstrap&gt;:663<span class="o">(</span>_load_unlocked<span class="o">)</span>
        1    0.000    0.000    0.000    0.000 &lt;frozen importlib._bootstrap&gt;:882<span class="o">(</span>_find_spec<span class="o">)</span>
        1    0.000    0.000    0.000    0.000 &lt;frozen importlib._bootstrap_external&gt;:1272<span class="o">(</span>find_spec<span class="o">)</span>
        1    0.000    0.000    0.000    0.000 &lt;frozen importlib._bootstrap_external&gt;:1240<span class="o">(</span>_get_spec<span class="o">)</span>
        1    0.000    0.000    0.000    0.000 &lt;frozen importlib._bootstrap_external&gt;:722<span class="o">(</span>exec_module<span class="o">)</span>
        1    0.000    0.000    0.000    0.000 &lt;frozen importlib._bootstrap_external&gt;:793<span class="o">(</span>get_code<span class="o">)</span>
        3    0.000    0.000    0.000    0.000 &lt;frozen importlib._bootstrap_external&gt;:1356<span class="o">(</span>find_spec<span class="o">)</span>
        3    0.000    0.000    0.000    0.000 <span class="o">{</span>built-in method builtins.print<span class="o">}</span>
        5    0.000    0.000    0.000    0.000 &lt;frozen importlib._bootstrap_external&gt;:74<span class="o">(</span>_path_stat<span class="o">)</span>
        5    0.000    0.000    0.000    0.000 <span class="o">{</span>built-in method posix.stat<span class="o">}</span>
...
</code></pre></div></div>

<p>누적 소비 시간으로 정렬하면 실행 시간을 주로 소비하는 곳이 어딘지 쉽게 확인할 수 있습니다.</p>

<p>cProfile 의 결과는 부모 함수에 따라 정렬되지 않으며 실행된 코드 블록 안의 모든 함수가 소비한 시간을 요약해 보여줍니다. 함수 안의 각 줄에 대한 정보가 아닌 함수 호출 자체에 대한 정보만 얻을 수 있으므로, cProfile 로 코드의 각 줄에서 일어난 일을 알아내기란 매우 어렵습니다.</p>

<p><code class="highlighter-rouge">calculate_z_serial_purepython</code> 함수에는 <code class="highlighter-rouge">{abs}</code> 와 <code class="highlighter-rouge">{range}</code> 두 함수 호출에 대략 2.1 초를 소비했음을 알 수 있다. 그리고 <code class="highlighter-rouge">calculate_z_serial_purepython</code> 함수는 10.5 초를 소비했습니다.</p>

<p>프로파일링 결과의 마지막 줄은 cProfile 의 전신이라 볼 수 있는 <code class="highlighter-rouge">lsprof</code> 에서 출력한 것입니다.</p>

<p>cProfile 의 결과를 더 세밀하게 살펴보려면 통계 파일을 생성한 뒤 Python 으로 분석할 수 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python <span class="nt">-m</span> cProfile <span class="nt">-o</span> profile.stats julia1.py
</code></pre></div></div>

<p>통계 파일을 불러들이면 앞서 살펴본 출력과 동일한 결과를 확인할 수 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>In <span class="o">[</span>1]: import pstats
In <span class="o">[</span>2]: p <span class="o">=</span> pstats.Stats<span class="o">(</span><span class="s2">"profile.stats"</span><span class="o">)</span>
In <span class="o">[</span>3]: p.sort_stats<span class="o">(</span><span class="s2">"cumulative"</span><span class="o">)</span>
Out[3]: &lt;pstats.Stats instance at 0x177dcf8&gt;
In <span class="o">[</span>4]: p.print_stats<span class="o">()</span>

Sun Feb 16 23:40:48 2020    profile.stats

         36222239 <span class="k">function </span>calls <span class="o">(</span>36222238 primitive calls<span class="o">)</span> <span class="k">in </span>10.302 seconds

   Ordered by: cumulative <span class="nb">time

   </span>ncalls  tottime  percall  cumtime  percall filename:lineno<span class="o">(</span><span class="k">function</span><span class="o">)</span>
      2/1    0.000    0.000   10.302   10.302 <span class="o">{</span>built-in method builtins.exec<span class="o">}</span>
        1    0.029    0.029   10.302   10.302 kakao.py:2<span class="o">(</span>&lt;module&gt;<span class="o">)</span>
        1    0.551    0.551   10.272   10.272 kakao.py:10<span class="o">(</span>calc_pure_python<span class="o">)</span>
        1    7.519    7.519    9.585    9.585 kakao.py:52<span class="o">(</span>calculate_z_serial_purepython<span class="o">)</span>
 34219980    2.066    0.000    2.066    0.000 <span class="o">{</span>built-in method builtins.abs<span class="o">}</span>
  2002000    0.128    0.000    0.128    0.000 <span class="o">{</span>method <span class="s1">'append'</span> of <span class="s1">'list'</span> objects<span class="o">}</span>
        1    0.008    0.008    0.008    0.008 <span class="o">{</span>built-in method builtins.sum<span class="o">}</span>
        1    0.000    0.000    0.000    0.000 &lt;frozen importlib._bootstrap&gt;:978<span class="o">(</span>_find_and_load<span class="o">)</span>
        1    0.000    0.000    0.000    0.000 &lt;frozen importlib._bootstrap&gt;:948<span class="o">(</span>_find_and_load_unlocked<span class="o">)</span>
        1    0.000    0.000    0.000    0.000 &lt;frozen importlib._bootstrap&gt;:663<span class="o">(</span>_load_unlocked<span class="o">)</span>
</code></pre></div></div>

<p>프로파일 중인 함수를 추적하기 위해 해당함수를 <strong>호출한 측(caller)</strong> 의 정보를 출력해보겠습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>In <span class="o">[</span>5]: p.print_callers<span class="o">()</span>

   Ordered by: cumulative <span class="nb">time

</span>Function                                                                                                       was called by...
                                                                                                                   ncalls  tottime  cumtime
<span class="o">{</span>built-in method builtins.exec<span class="o">}</span>                                                                                &lt;-       1    0.000    0.000  &lt;frozen importlib._bootstrap&gt;:211<span class="o">(</span>_call_with_frames_removed<span class="o">)</span>
kakao.py:2<span class="o">(</span>&lt;module&gt;<span class="o">)</span>                                                                                           &lt;-       1    0.029   10.302  <span class="o">{</span>built-in method builtins.exec<span class="o">}</span>
kakao.py:10<span class="o">(</span>calc_pure_python<span class="o">)</span>                                                                                  &lt;-       1    0.551   10.272  kakao.py:2<span class="o">(</span>&lt;module&gt;<span class="o">)</span>
kakao.py:52<span class="o">(</span>calculate_z_serial_purepython<span class="o">)</span>                                                                     &lt;-       1    7.519    9.585  kakao.py:10<span class="o">(</span>calc_pure_python<span class="o">)</span>
<span class="o">{</span>built-in method builtins.abs<span class="o">}</span>                                                                                 &lt;- 34219980    2.066    2.066  kakao.py:52<span class="o">(</span>calculate_z_serial_purepython<span class="o">)</span>
<span class="o">{</span>method <span class="s1">'append'</span> of <span class="s1">'list'</span> objects<span class="o">}</span>                                                                            &lt;- 2002000    0.128    0.128  kakao.py:10<span class="o">(</span>calc_pure_python<span class="o">)</span>
<span class="o">{</span>built-in method builtins.sum<span class="o">}</span>                                                                                 &lt;-       1    0.008    0.008  kakao.py:10<span class="o">(</span>calc_pure_python<span class="o">)</span>
&lt;frozen importlib._bootstrap&gt;:978<span class="o">(</span>_find_and_load<span class="o">)</span>                                                              &lt;-       1    0.000    0.000  kakao.py:2<span class="o">(</span>&lt;module&gt;<span class="o">)</span>
&lt;frozen importlib._bootstrap&gt;:948<span class="o">(</span>_find_and_load_unlocked<span class="o">)</span>                                                     &lt;-       1    0.000    0.000  &lt;frozen importlib._bootstrap&gt;:978<span class="o">(</span>_find_and_load<span class="o">)</span>
&lt;frozen importlib._bootstrap&gt;:663<span class="o">(</span>_load_unlocked<span class="o">)</span>                                                              &lt;-       1    0.000    0.000  &lt;frozen importlib._bootstrap&gt;:948<span class="o">(</span>_find_and_load_unlocked<span class="o">)</span>
&lt;frozen importlib._bootstrap&gt;:882<span class="o">(</span>_find_spec<span class="o">)</span>                                                                  &lt;-       1    0.000    0.000  &lt;frozen importlib._bootstrap&gt;:948<span class="o">(</span>_find_and_load_unlocked<span class="o">)</span>
&lt;frozen importlib._bootstrap_external&gt;:1272<span class="o">(</span>find_spec<span class="o">)</span>                                                         &lt;-       1    0.000    0.000  &lt;frozen importlib._bootstrap&gt;:882<span class="o">(</span>_find_spec<span class="o">)</span>
&lt;frozen importlib._bootstrap_external&gt;:1240<span class="o">(</span>_get_spec<span class="o">)</span>                                                         &lt;-       1    0.000    0.000  &lt;frozen importlib._bootstrap_external&gt;:1272<span class="o">(</span>find_spec<span class="o">)</span>
&lt;frozen importlib._bootstrap_external&gt;:722<span class="o">(</span>exec_module<span class="o">)</span>                                                        &lt;-       1    0.000    0.000  &lt;frozen importlib._bootstrap&gt;:663<span class="o">(</span>_load_unlocked<span class="o">)</span>
&lt;frozen importlib._bootstrap_external&gt;:793<span class="o">(</span>get_code<span class="o">)</span>                                                           &lt;-       1    0.000    0.000  &lt;frozen importlib._bootstrap_external&gt;:722<span class="o">(</span>exec_module<span class="o">)</span>
&lt;frozen importlib._bootstrap_external&gt;:1356<span class="o">(</span>find_spec<span class="o">)</span>                                                         &lt;-       3    0.000    0.000  &lt;frozen importlib._bootstrap_external&gt;:1240<span class="o">(</span>_get_spec<span class="o">)</span>
<span class="o">{</span>built-in method builtins.print<span class="o">}</span>                                                                               &lt;-       3    0.000    0.000  kakao.py:10<span class="o">(</span>calc_pure_python<span class="o">)</span>
</code></pre></div></div>

<p>반대로 해당 함수에서 호출하는 함수 목록도 확인할 수 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>In <span class="o">[</span>6]: p.print_callees<span class="o">()</span>

Ordered by: cumulative <span class="nb">time

</span>Function                                                                                                       called...
                                                                                                                   ncalls  tottime  cumtime
<span class="o">{</span>built-in method builtins.exec<span class="o">}</span>                                                                                -&gt;       1    0.000    0.000  /usr/local/Cellar/python/3.7.5/Frameworks/Python.framework/Versions/3.7/lib/python3.7/cProfile.py:5<span class="o">(</span>&lt;module&gt;<span class="o">)</span>
                                                                                                                        1    0.029   10.302  kakao.py:2<span class="o">(</span>&lt;module&gt;<span class="o">)</span>
kakao.py:2<span class="o">(</span>&lt;module&gt;<span class="o">)</span>                                                                                           -&gt;       1    0.000    0.000  &lt;frozen importlib._bootstrap&gt;:978<span class="o">(</span>_find_and_load<span class="o">)</span>
                                                                                                                        1    0.551   10.272  kakao.py:10<span class="o">(</span>calc_pure_python<span class="o">)</span>
kakao.py:10<span class="o">(</span>calc_pure_python<span class="o">)</span>                                                                                  -&gt;       1    7.519    9.585  kakao.py:52<span class="o">(</span>calculate_z_serial_purepython<span class="o">)</span>
                                                                                                                        2    0.000    0.000  <span class="o">{</span>built-in method builtins.len<span class="o">}</span>
                                                                                                                        3    0.000    0.000  <span class="o">{</span>built-in method builtins.print<span class="o">}</span>
                                                                                                                        1    0.008    0.008  <span class="o">{</span>built-in method builtins.sum<span class="o">}</span>
                                                                                                                        2    0.000    0.000  <span class="o">{</span>built-in method time.time<span class="o">}</span>
                                                                                                                  2002000    0.128    0.128  <span class="o">{</span>method <span class="s1">'append'</span> of <span class="s1">'list'</span> objects<span class="o">}</span>
kakao.py:52<span class="o">(</span>calculate_z_serial_purepython<span class="o">)</span>                                                                     -&gt; 34219980    2.066    2.066  <span class="o">{</span>built-in method builtins.abs<span class="o">}</span>
                                                                                                                        2    0.000    0.000  <span class="o">{</span>built-in method builtins.len<span class="o">}</span>
<span class="o">{</span>built-in method builtins.abs<span class="o">}</span>                                                                                 -&gt;
<span class="o">{</span>method <span class="s1">'append'</span> of <span class="s1">'list'</span> objects<span class="o">}</span>                                                                            -&gt;
<span class="o">{</span>built-in method builtins.sum<span class="o">}</span>                                                                                 -&gt;
&lt;frozen importlib._bootstrap&gt;:978<span class="o">(</span>_find_and_load<span class="o">)</span>                                                              -&gt;       1    0.000    0.000  &lt;frozen importlib._bootstrap&gt;:143<span class="o">(</span>__init__<span class="o">)</span>
</code></pre></div></div>

<p>cProfile 의 출력내용은 약간 장황한 면이 있어서, 줄바꿈 없이 깔끔하게 보고 싶으면 창을 넓게 늘려서 사용해야 합니다.</p>

<h2 id="using-line_profiler-for-line-by-line-measurements">Using line_profiler for Line-by-Line Measurements</h2>

<p><code class="highlighter-rouge">line_profiler</code> 가 Python 코드에서 CPU 가 병목 원인을 찾아주는 가장 강력한 도구일 것입니다. <code class="highlighter-rouge">line_profiler</code> 는 개별 함수를 한 줄씩 프로파일링할 수 있으므로 먼저 cProfile 을 사용해 어떤 함수를 <code class="highlighter-rouge">line_profiler</code> 로 자세히 살펴볼지 방향을 정하면 됩니다.</p>

<p><code class="highlighter-rouge">line_profiler</code> 를 설치하려면 <code class="highlighter-rouge">pip install line_profiler</code> 를 입력하면 됩니다.</p>

<p><code class="highlighter-rouge">@profile</code> 데코레이터는 선택한 함수를 표시하기 위해 사용합니다 <em>kernprof.py</em> 스크립트는 코드를 실행하고 선택한 함수의 각 줄에 대한 CPU 시간 등의 통계를 기록하는 데 사용합니다.</p>

<p><code class="highlighter-rouge">-l</code> 옵션은 함수 단위가 한 줄씩 프로파일링하겠다는 옵션이며 <code class="highlighter-rouge">-v</code> 옵션은 출력결과를 다양하게 보여줍니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
calculate_z_serial_purepython took 69.51615619659424 seconds
Wrote profile results to julia1_lineprofiler.py.lprof
Timer unit: 1e-06 s

<span class="nv">$ </span>kernprof <span class="nt">-l</span> <span class="nt">-v</span> julia1_lineprofiler.py

Total <span class="nb">time</span>: 39.9619 s
File: julia1_lineprofiler.py
Function: calculate_z_serial_purepython at line 53

Line <span class="c">#      Hits         Time  Per Hit   % Time  Line Contents</span>
<span class="o">==============================================================</span>
    53                                           @profile
    54                                           def calculate_z_serial_purepython<span class="o">(</span>maxiter, zs, cs<span class="o">)</span>:
    55                                             <span class="s2">"""Calculate output list using Julia update rule"""</span>
    56         1       6074.0   6074.0      0.0    output <span class="o">=</span> <span class="o">[</span>0] <span class="k">*</span> len<span class="o">(</span>zs<span class="o">)</span>
    57   1000001     312475.0      0.3      0.8    <span class="k">for </span>i <span class="k">in </span>range<span class="o">(</span>len<span class="o">(</span>zs<span class="o">))</span>:
    58   1000000     297751.0      0.3      0.7      n <span class="o">=</span> 0
    59   1000000     350329.0      0.4      0.9      z <span class="o">=</span> zs[i]
    60   1000000     328300.0      0.3      0.8      c <span class="o">=</span> cs[i]
    61  34219980   15072458.0      0.4     37.7      <span class="k">while </span>abs<span class="o">(</span>z<span class="o">)</span> &lt; 2 and n &lt; maxiter:
    62  33219980   12147692.0      0.4     30.4        z <span class="o">=</span> z <span class="k">*</span> z + c
    63  33219980   11108739.0      0.3     27.8        n +<span class="o">=</span> 1
    64   1000000     338078.0      0.3      0.8      output[i] <span class="o">=</span> n
    65         1          1.0      1.0      0.0    <span class="k">return </span>output
</code></pre></div></div>

<h2 id="using-memory_profiler-to-diagnose-memory-usage">Using memory_profiler to Diagnose Memory Usage</h2>

<p>CPU 사용량을 측정하는 <code class="highlighter-rouge">line_profiler</code> 처럼 메모리 사용량을 줄 단위로 측정하는 <code class="highlighter-rouge">memory_profiler</code> 가 있습니다.</p>

<p><code class="highlighter-rouge">memory_profiler</code> 는 다음 명령어로 설치할 수 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>pip <span class="nb">install </span>memory_profiler
</code></pre></div></div>

<p>그리고 <code class="highlighter-rouge">psutil</code> 은 다음 명령어로 설치할 수 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>pip <span class="nb">install </span>psutil
</code></pre></div></div>

<p>아래는 <code class="highlighter-rouge">memory_profiler</code> 를 이용하여 메모리 사용을 측정한 예입니다. <code class="highlighter-rouge">line_profiler</code> 와 비교해서 시간이 더 오래 걸릴 수 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>calculate_z_serial_purepython took 3594.8900051116943 seconds
Filename: julia.py

Line <span class="c">#    Mem usage    Increment   Line Contents</span>
<span class="o">================================================</span>
    10   36.180 MiB   36.180 MiB   @profile
    11                             def calc_pure_python<span class="o">(</span>desired_width, max_iterations<span class="o">)</span>:
    12                                 <span class="s2">"""Create a list of complex coordinates (zs) and complex parameters (cs), build Julia set, and display"""</span>
    13   36.180 MiB    0.000 MiB       x_step <span class="o">=</span> <span class="o">(</span>float<span class="o">(</span>x2 - x1<span class="o">)</span> / float<span class="o">(</span>desired_width<span class="o">))</span>
    14   36.180 MiB    0.000 MiB       y_step <span class="o">=</span> <span class="o">(</span>float<span class="o">(</span>y1 - y2<span class="o">)</span> / float<span class="o">(</span>desired_width<span class="o">))</span>
    15   36.180 MiB    0.000 MiB       x <span class="o">=</span> <span class="o">[]</span>
    16   36.180 MiB    0.000 MiB       y <span class="o">=</span> <span class="o">[]</span>
    17   36.180 MiB    0.000 MiB       ycoord <span class="o">=</span> y2
    18
    19   36.180 MiB    0.000 MiB       <span class="k">while </span>ycoord <span class="o">&gt;</span> y1:
    20   36.180 MiB    0.000 MiB           y.append<span class="o">(</span>ycoord<span class="o">)</span>
    21   36.180 MiB    0.000 MiB           ycoord +<span class="o">=</span> y_step
    22   36.180 MiB    0.000 MiB       xcoord <span class="o">=</span> x1
    23
    24   36.184 MiB    0.000 MiB       <span class="k">while </span>xcoord &lt; x2:
    25   36.184 MiB    0.004 MiB           x.append<span class="o">(</span>xcoord<span class="o">)</span>
    26   36.184 MiB    0.000 MiB           xcoord +<span class="o">=</span> x_step
    27                                 <span class="c"># Build a list of coordinates and the initial condition for each cell.</span>
    28                                 <span class="c"># Note that our initial condition is a constant and could easily be removed;</span>
    29                                 <span class="c"># we use it to simulate a real-world scenario with several inputs to</span>
    30                                 <span class="c"># our function.</span>
    31   36.184 MiB    0.000 MiB       zs <span class="o">=</span> <span class="o">[]</span>
    32   36.184 MiB    0.000 MiB       cs <span class="o">=</span> <span class="o">[]</span>
    33
    34  119.973 MiB    0.000 MiB       <span class="k">for </span>ycoord <span class="k">in </span>y:
    35  119.973 MiB    0.016 MiB           <span class="k">for </span>xcoord <span class="k">in </span>x:
    36  119.973 MiB    1.098 MiB               zs.append<span class="o">(</span>complex<span class="o">(</span>xcoord, ycoord<span class="o">))</span>
    37  119.973 MiB    1.098 MiB               cs.append<span class="o">(</span>complex<span class="o">(</span>c_real, c_imag<span class="o">))</span>
    38
    39  119.977 MiB    0.004 MiB       print<span class="o">(</span><span class="s2">"Length of x:"</span>, len<span class="o">(</span>x<span class="o">))</span>
    40  119.977 MiB    0.000 MiB       print<span class="o">(</span><span class="s2">"Total elements:"</span>, len<span class="o">(</span>zs<span class="o">))</span>
    41
    42  119.977 MiB    0.000 MiB       start_time <span class="o">=</span> time.time<span class="o">()</span>
    43   80.156 MiB   80.156 MiB       output <span class="o">=</span> calculate_z_serial_purepython<span class="o">(</span>max_iterations, zs, cs<span class="o">)</span>
    44   80.184 MiB    0.027 MiB       end_time <span class="o">=</span> time.time<span class="o">()</span>
    45   80.184 MiB    0.000 MiB       secs <span class="o">=</span> end_time - start_time
    46   80.281 MiB    0.098 MiB       print<span class="o">(</span>calculate_z_serial_purepython.__name__ + <span class="s2">" took"</span>, secs, <span class="s2">"seconds"</span><span class="o">)</span>
    47
    48                                 <span class="c"># This sum is expected for a 1000^2 grid with 300 iterations.</span>
    49                                 <span class="c"># It catches minor errors we might introduce when we're</span>
    50                                 <span class="c"># working on a fixed set of inputs.</span>
    51   81.172 MiB    0.891 MiB       assert <span class="nb">sum</span><span class="o">(</span>output<span class="o">)</span> <span class="o">==</span> 33219980


Filename: julia.py

Line <span class="c">#    Mem usage    Increment   Line Contents</span>
<span class="o">================================================</span>
    53  119.977 MiB  119.977 MiB   @profile
    54                             def calculate_z_serial_purepython<span class="o">(</span>maxiter, zs, cs<span class="o">)</span>:
    55                               <span class="s2">"""Calculate output list using Julia update rule"""</span>
    56  127.609 MiB    7.633 MiB     output <span class="o">=</span> <span class="o">[</span>0] <span class="k">*</span> len<span class="o">(</span>zs<span class="o">)</span>
    57  137.910 MiB    0.000 MiB     <span class="k">for </span>i <span class="k">in </span>range<span class="o">(</span>len<span class="o">(</span>zs<span class="o">))</span>:
    58  137.910 MiB    0.000 MiB       n <span class="o">=</span> 0
    59  137.910 MiB    0.004 MiB       z <span class="o">=</span> zs[i]
    60  137.910 MiB    0.004 MiB       c <span class="o">=</span> cs[i]
    61  137.910 MiB    0.004 MiB       <span class="k">while </span>abs<span class="o">(</span>z<span class="o">)</span> &lt; 2 and n &lt; maxiter:
    62  137.910 MiB    0.004 MiB         z <span class="o">=</span> z <span class="k">*</span> z + c
    63  137.910 MiB    0.000 MiB         n +<span class="o">=</span> 1
    64  137.910 MiB    0.000 MiB       output[i] <span class="o">=</span> n
    65   80.105 MiB    0.000 MiB     <span class="k">return </span>output
</code></pre></div></div>

<p>아래 <code class="highlighter-rouge">Example 5</code> 는 <code class="highlighter-rouge">mprof run julia1_memoryprofiler.py</code> 명령으로 생성한 것입니다. 이 명령을 실행하면 먼저 통계 파일을 생성하고 <code class="highlighter-rouge">mprof plot</code> 명령으로 시각화합니다.</p>

<blockquote>
  <p>Example 5 - memory_profiler report using mprof</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74648824-becf0e00-51c1-11ea-8864-1dc403042ca3.png" alt="image" /></p>

<p>함수 수준의 동작을 관찰하는 데 추가로 컨텍스트 관리자를 사용해 라벨을 추가할 수 있습니다. 아래 그림은 라벨과 <code class="highlighter-rouge">mprof</code> 를 함꼐 이용한 <code class="highlighter-rouge">memory_profiler</code> 입니다.</p>

<blockquote>
  <p>Example 6 - memory_profiler report using mprof with labels</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74648829-c0003b00-51c1-11ea-8a8a-bca6d13a69e6.png" alt="image" /></p>

<p><code class="highlighter-rouge">create_range_of_zs</code> 뒤로 RAM 사용량이 급격하게 증가하는 것을 확인할 수 있습니다. <code class="highlighter-rouge">xrange</code> 를 사용하는 대신 <code class="highlighter-rouge">range</code> 를 사용해서 색인을 생성할 목적으로 1,000,000 개의 원소를 가지는 큰 리스트를 만들었는데, 큰 리스트를 다루게 되면 RAM 을 전부 써버릴지 모르니 비효율적인 방법입니다. 이 리스트를 저장하기 위한 메모리 할당 역시 시간을 잡아먹으며 해당 함수의 쓸모의 전혀 동무이 되지 않습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">profile</span>
<span class="k">def</span> <span class="nf">calculate_z_serial_purepython</span><span class="p">(</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
    <span class="s">"""Calculate output list using Julia update rule"""</span>
    <span class="k">with</span> <span class="n">profile</span><span class="o">.</span><span class="n">timestamp</span><span class="p">(</span><span class="s">"create_output_list"</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">zs</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">profile</span><span class="o">.</span><span class="n">timestamp</span><span class="p">(</span><span class="s">"create_range_of_zs"</span><span class="p">):</span>
        <span class="n">iterations</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">zs</span><span class="p">))</span>
        <span class="k">with</span> <span class="n">profile</span><span class="o">.</span><span class="n">timestamp</span><span class="p">(</span><span class="s">"calculate_output"</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iterations</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">zs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">maxiter</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">z</span> <span class="o">+</span> <span class="n">c</span>
                    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">output</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">calculate_output</code> 블록이 가장 오랫동안 실행되고 있는데 RAM 사용량이 아주 천천히 증가하는 것을 볼 수 있습니다. 이는 내부 반복문에서 사용하는 임시값 때문입니다.</p>

<p>마지막으로 <code class="highlighter-rouge">range</code> 를 <code class="highlighter-rouge">xrange</code> 로 바꿔보겠습니다. 아래 <code class="highlighter-rouge">Example 7</code> 을 확인해보면 RAM 사용량이 줄어든 것을 볼 수 있습니다.</p>

<blockquote>
  <p>Example 7 - memory_profiler report showing the effect of changing range to xrange</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74648830-c1c9fe80-51c1-11ea-8826-402c3075bd62.png" alt="image" /></p>

<p>여러 줄에 RAM 사용량을 확인하고 싶으면 IPython 의 명령어인 <code class="highlighter-rouge">%memit</code> 을 사용하면 됩니다.</p>

<h2 id="inspecting-objects-on-the-heap-with-heapy">Inspecting Objects on the Heap with heapy</h2>

<p>Guppy 프로젝트는 Python 힙 메모리에 있는 객체의 수와 크기를 살펴볼 수 있도록 heapy 라는 이름의 힙 메모리 조사 도구를 제공합니다.</p>

<p>heapy 를 사용하려면 다음 명령어로 <code class="highlighter-rouge">guppy</code> 패키지를 설치하면 됩니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install </span>guppy
</code></pre></div></div>

<p>아래 코드는 약간 변형한 쥘리아 집합 코드입니다. <code class="highlighter-rouge">calc_pure_python</code> 안에 힙 객체 hpy 를 포함시키고 3 곳에서 힙의 상태를 출력합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calc_pure_python</span><span class="p">(</span><span class="n">draw_output</span><span class="p">,</span> <span class="n">desired_width</span><span class="p">,</span> <span class="n">max_iterations</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">guppy</span> <span class="kn">import</span> <span class="n">hpy</span>
    <span class="n">hp</span> <span class="o">=</span> <span class="n">hpy</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"heapy after creating y and x lists of floats"</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">heap</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>


    <span class="n">zs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ycoord</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">xcoord</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">zs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="n">xcoord</span><span class="p">,</span> <span class="n">ycoord</span><span class="p">))</span>
            <span class="n">cs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="n">c_real</span><span class="p">,</span> <span class="n">c_imag</span><span class="p">))</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"heapy after creating zs and cs using complex numbers"</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">heap</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="k">print</span> <span class="p">(</span><span class="s">"Length of x:"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">print</span> <span class="p">(</span><span class="s">"Total elements:"</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">zs</span><span class="p">))</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">calculate_z_serial_purepython</span><span class="p">(</span><span class="n">max_iterations</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">secs</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>
    <span class="k">print</span> <span class="p">(</span><span class="n">calculate_z_serial_purepython</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s">" took"</span><span class="p">,</span> <span class="n">secs</span><span class="p">,</span> <span class="s">"seconds"</span><span class="p">)</span>

    <span class="k">print</span> <span class="p">(</span><span class="s">"heapy after calling calculate_z_serial_purepython"</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">heap</span><span class="p">()</span>
    <span class="k">print</span> <span class="p">(</span><span class="n">h</span><span class="p">)</span>

    <span class="c1"># this sum is expected for 1000^2 grid with 300 iterations
</span>    <span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">33219980</span>
</code></pre></div></div>

<p>아래는 <code class="highlighter-rouge">guppy</code> 패키지를 이용한 프로파일링 결과입니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python julia1_guppy.py

heapy after creating y and x lists of floats
Partition of a <span class="nb">set </span>of 40479 objects. Total size <span class="o">=</span> 4555081 bytes.
 Index  Count   %     Size   % Cumulative  % Kind <span class="o">(</span>class / dict of class<span class="o">)</span>
     0  11774  29  1026200  23   1026200  23 str
     1   9414  23   762816  17   1789016  39 tuple
     2   2460   6   355784   8   2144800  47 types.CodeType
     3   4824  12   337773   7   2482573  55 bytes
     4    437   1   333608   7   2816181  62 <span class="nb">type
     </span>5   2249   6   323856   7   3140037  69 <span class="k">function
     </span>6    437   1   243536   5   3383573  74 dict of <span class="nb">type
     </span>7     98   0   164312   4   3547885  78 dict of module
     8    250   1   117232   3   3665117  80 dict <span class="o">(</span>no owner<span class="o">)</span>
     9     47   0   103576   2   3768693  83 <span class="nb">set</span>
&lt;117 more rows. Type e.g. <span class="s1">'_.more'</span> to view.&gt;

heapy after creating zs and cs using complex numbers
Partition of a <span class="nb">set </span>of 2040479 objects. Total size <span class="o">=</span> 85949977 bytes.
 Index  Count   %     Size   % Cumulative  % Kind <span class="o">(</span>class / dict of class<span class="o">)</span>
     0 2000000  98 64000000  74  64000000  74 complex
     1    109   0 17432664  20  81432664  95 list
     2  11774   1  1026200   1  82458864  96 str
     3   9414   0   762816   1  83221680  97 tuple
     4   2460   0   355784   0  83577464  97 types.CodeType
     5   4824   0   337773   0  83915237  98 bytes
     6    437   0   333608   0  84248845  98 <span class="nb">type
     </span>7   2249   0   323856   0  84572701  98 <span class="k">function
     </span>8    437   0   243536   0  84816237  99 dict of <span class="nb">type
     </span>9     98   0   164312   0  84980549  99 dict of module
&lt;118 more rows. Type e.g. <span class="s1">'_.more'</span> to view.&gt;
Length of x: 1000
Total elements: 1000000
calculate_z_serial_purepython took 7.341063022613525 seconds

heapy after calling calculate_z_serial_purepython
Partition of a <span class="nb">set </span>of 2140852 objects. Total size <span class="o">=</span> 96760453 bytes.
 Index  Count   %     Size   % Cumulative  % Kind <span class="o">(</span>class / dict of class<span class="o">)</span>
     0 2000000  93 64000000  66  64000000  66 complex
     1    110   0 25432736  26  89432736  92 list
     2 101335   5  2840140   3  92272876  95 int
     3  11774   1  1026200   1  93299076  96 str
     4   9414   0   762816   1  94061892  97 tuple
     5   2460   0   355784   0  94417676  98 types.CodeType
     6   4824   0   337773   0  94755449  98 bytes
     7    437   0   333608   0  95089057  98 <span class="nb">type
     </span>8   2249   0   323856   0  95412913  99 <span class="k">function
     </span>9    437   0   243536   0  95656449  99 dict of <span class="nb">type</span>
&lt;118 more rows. Type e.g. <span class="s1">'_.more'</span> to view.&gt;
</code></pre></div></div>

<p><code class="highlighter-rouge">hpy.setrelheap()</code> 함수는 메모리 설정에서 체크포인트를 생성하기 위해 사용합니다. 이후 호출하는 <code class="highlighter-rouge">hpy.heap()</code> 함수는 체크포인트에서 변화된 내용을 출력합니다.</p>

<h2 id="using-dowser-for-live-graphing-of-instantiated-variables">Using dowser for Live Graphing of Instantiated Variables</h2>

<p><code class="highlighter-rouge">dowser</code> 는 실행중인 코드의 네임스페이스를 조작하여 CherryPy 인터페이스를 통해 웹 브라우저에서 생성하는 변수를 실시간으로 확인할 수 있습니다. 각 객체는 선 그래프로 보여주며 특정 객체 수가 늘어나는지 확인할 수 있습니다.</p>

<p>특정 조작에 따라 메모리 사용량이 변화하는 웹 서버나 오래 실행되는 프로세스가 있다면 <code class="highlighter-rouge">dowser</code> 를 통해 인터렉티브하게 확인할 수 있습니다. <code class="highlighter-rouge">Example 8</code> 은 <code class="highlighter-rouge">dowser</code> 의 사용 예입니다.</p>

<blockquote>
  <p>Example 8 - Several sparklines shown through CherryPy with dowser</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74650396-f8eddf00-51c4-11ea-8b3e-c6c8ded08cd5.png" alt="image" /></p>

<p><code class="highlighter-rouge">dowser</code> 를 사용하기 전에 아래 코드를 추가해 CherryPy 서버를 시작합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">launch_memory_usage_server</span><span class="p">(</span><span class="n">port</span><span class="o">=</span><span class="mi">8080</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">cherrypy</span>
    <span class="kn">import</span> <span class="nn">dowser</span>

    <span class="n">cherrypy</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="n">dowser</span><span class="o">.</span><span class="n">Root</span><span class="p">())</span>
    <span class="n">cherrypy</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
        <span class="s">'environment'</span><span class="p">:</span> <span class="s">'embedded'</span><span class="p">,</span>
        <span class="s">'server.socket_port'</span><span class="p">:</span> <span class="n">port</span>
    <span class="p">})</span>

    <span class="n">cherrypy</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</code></pre></div></div>

<p>복잡한 계산을 하기 전에 CherryPy 서버를 실행합니다. 계산이 끝난 뒤에는 <code class="highlighter-rouge">time.sleep</code> 을 추가하여 CherryPy 프로세스가 종료되지 않도록 하고 네임스페이스의 상태를 살펴봅니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">...</span>
    <span class="k">for</span> <span class="n">xcoord</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">zs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="n">xcoord</span><span class="p">,</span> <span class="n">ycoord</span><span class="p">))</span>
        <span class="n">cs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="n">c_real</span><span class="p">,</span> <span class="n">c_imag</span><span class="p">))</span>
<span class="n">launch_memory_usage_server</span><span class="p">()</span>
<span class="o">...</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">calculate_z_serial_purepython</span><span class="p">(</span><span class="n">max_iterations</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">print</span> <span class="s">"now waiting..."</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Example 8</code> 의 TRACE 링크를 클릭하면 아래 <code class="highlighter-rouge">Example 9</code> 와 같이 리스트 객체의 내용을 확인할 수 있습니다.</p>

<blockquote>
  <p>Example 9 - 1,000,000 items in a list with dowser</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74650400-fab7a280-51c4-11ea-922f-4992a0eb3d2f.png" alt="image" /></p>

<h2 id="using-the-dis-module-to-examine-cpython-bytecode">Using the dis Module to Examine CPython Bytecode</h2>

<p>Python 코드의 CPU 와 RAM 사용량을 측정하는 방법을 알아봤습니다. 이제 바이트코트에 대해 알아보겠습니다.</p>

<p><code class="highlighter-rouge">dis</code> 모듈을 통해 스택 기반의 CPython 가상 머신에서 동작하는 바이트 코드를 살펴볼 수 있습니다. Python 코드가 가상 머신 안에서는 어떻게 동작하는지 이해하면 특정 코딩 습관이 다른 방법보다 빠른 코드를 만들어 내는지 알 수 있습니다.</p>

<p><code class="highlighter-rouge">dis</code> 모듈은 기본으로 내장되어 있습니다. 여기에 코드나 모듈을 넘기면 역 어셈블 결과를 출력해줍니다. 아래는 함수의 역어셈블 결과입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">dis</span>

<span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">calc_pure_python</span><span class="p">)</span>

 <span class="mi">11</span>           <span class="mi">0</span> <span class="n">LOAD_CONST</span>               <span class="mi">1</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
              <span class="mi">2</span> <span class="n">BUILD_LIST</span>               <span class="mi">1</span>
              <span class="mi">4</span> <span class="n">LOAD_GLOBAL</span>              <span class="mi">0</span> <span class="p">(</span><span class="nb">len</span><span class="p">)</span>
              <span class="mi">6</span> <span class="n">LOAD_FAST</span>                <span class="mi">1</span> <span class="p">(</span><span class="n">zs</span><span class="p">)</span>
              <span class="mi">8</span> <span class="n">CALL_FUNCTION</span>            <span class="mi">1</span>
             <span class="mi">10</span> <span class="n">BINARY_MULTIPLY</span>
             <span class="mi">12</span> <span class="n">STORE_FAST</span>               <span class="mi">3</span> <span class="p">(</span><span class="n">output</span><span class="p">)</span>

 <span class="mi">12</span>          <span class="mi">14</span> <span class="n">SETUP_LOOP</span>              <span class="mi">94</span> <span class="p">(</span><span class="n">to</span> <span class="mi">110</span><span class="p">)</span>
             <span class="mi">16</span> <span class="n">LOAD_GLOBAL</span>              <span class="mi">1</span> <span class="p">(</span><span class="nb">range</span><span class="p">)</span>
             <span class="mi">18</span> <span class="n">LOAD_GLOBAL</span>              <span class="mi">0</span> <span class="p">(</span><span class="nb">len</span><span class="p">)</span>
             <span class="mi">20</span> <span class="n">LOAD_FAST</span>                <span class="mi">1</span> <span class="p">(</span><span class="n">zs</span><span class="p">)</span>
             <span class="mi">22</span> <span class="n">CALL_FUNCTION</span>            <span class="mi">1</span>
             <span class="mi">24</span> <span class="n">CALL_FUNCTION</span>            <span class="mi">1</span>
             <span class="mi">26</span> <span class="n">GET_ITER</span>
        <span class="o">&gt;&gt;</span>   <span class="mi">28</span> <span class="n">FOR_ITER</span>                <span class="mi">78</span> <span class="p">(</span><span class="n">to</span> <span class="mi">108</span><span class="p">)</span>
             <span class="mi">30</span> <span class="n">STORE_FAST</span>               <span class="mi">4</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>

 <span class="mi">13</span>          <span class="mi">32</span> <span class="n">LOAD_CONST</span>               <span class="mi">1</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
             <span class="mi">34</span> <span class="n">STORE_FAST</span>               <span class="mi">5</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>

 <span class="mi">14</span>          <span class="mi">36</span> <span class="n">LOAD_FAST</span>                <span class="mi">1</span> <span class="p">(</span><span class="n">zs</span><span class="p">)</span>
             <span class="mi">38</span> <span class="n">LOAD_FAST</span>                <span class="mi">4</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
             <span class="mi">40</span> <span class="n">BINARY_SUBSCR</span>
             <span class="mi">42</span> <span class="n">STORE_FAST</span>               <span class="mi">6</span> <span class="p">(</span><span class="n">z</span><span class="p">)</span>
</code></pre></div></div>

<p>결과는 간결하며 직관적입니다. 첫 번째 컬럼은 원래 소스 파일의 줄 번호를 나타냅니다. 두 번째 칼럼은 » 기호를 포함하는, 이는 코드의 다른 지점에서 점프해오는 지점입니다. 세 번째 컬럼은 연산의 주소와 그 이름이며, 네 번째 컬럼은 해당 연산에 전달하는 매개변수입니다. 마지막으로 다섯 번째 컬럼은 이해를 돕기위해 Python 코드를 같이 출력한 것입니다.</p>

<p>이해를 돕기위해 해당 Python 코드를 알려드리겠습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calculate_z_serial_purepython</span><span class="p">(</span><span class="n">maxiter</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
    <span class="s">"""Calculate output list using Julia update rule"""</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">zs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">zs</span><span class="p">)):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">zs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">maxiter</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">z</span> <span class="o">+</span> <span class="n">c</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">output</span>
</code></pre></div></div>

<h3 id="different-approaches-different-complexity">Different Approaches, Different Complexity</h3>

<p>아래 두 코드를 살펴보겠습니다. 둘 다 같은 일을 하지만, 첫 번째 코드는 더 많은 Python 바이트코드를 생성하기 때문에 더 느리게 동작합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fn_expressive</span><span class="p">(</span><span class="n">upper</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">):</span>
  <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">upper</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">n</span>
  <span class="k">return</span> <span class="n">total</span>

<span class="k">def</span> <span class="nf">fn_terse</span><span class="p">(</span><span class="n">upper</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">):</span>
  <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="n">upper</span><span class="p">))</span>

<span class="k">print</span> <span class="s">"Functions return the same result:"</span><span class="p">,</span> <span class="n">fn_expressive</span><span class="p">()</span> <span class="o">==</span> <span class="n">fn_terse</span><span class="p">()</span>
<span class="n">Functions</span> <span class="k">return</span> <span class="n">the</span> <span class="n">same</span> <span class="n">result</span><span class="p">:</span>
<span class="bp">True</span>
</code></pre></div></div>

<p>두 함수 정수 수열의 합을 구하는 함수입니다. 어림 잡아도 더 적은 수의 바이트코드를 생성하는 내장 함수를 사용하는 쪽이 더 많은 바이트코드를 생성하는 함수보다 빠르게 작동할 것입니다. 아래 <code class="highlighter-rouge">%timeit</code> 을 이용해 최적 실행 시간을 측정해봤습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">timeit</span> <span class="n">fn_expressive</span><span class="p">()</span>
<span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">42</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>

<span class="o">%</span><span class="n">timeit</span> <span class="n">fn_terse</span><span class="p">()</span>
<span class="mi">100</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mf">12.3</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">dis</code> 모듈을 통하여 각 함수를 역어셈블해보면 아래와 같이 수행해야하는 연산횟수가 다릅니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">dis</span>

<span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">fn_expressive</span><span class="p">)</span>

  <span class="mi">2</span>           <span class="mi">0</span> <span class="n">LOAD_CONST</span>               <span class="mi">1</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
              <span class="mi">2</span> <span class="n">STORE_FAST</span>               <span class="mi">1</span> <span class="p">(</span><span class="n">total</span><span class="p">)</span>

  <span class="mi">3</span>           <span class="mi">4</span> <span class="n">SETUP_LOOP</span>              <span class="mi">24</span> <span class="p">(</span><span class="n">to</span> <span class="mi">30</span><span class="p">)</span>
              <span class="mi">6</span> <span class="n">LOAD_GLOBAL</span>              <span class="mi">0</span> <span class="p">(</span><span class="nb">xrange</span><span class="p">)</span>
              <span class="mi">8</span> <span class="n">LOAD_FAST</span>                <span class="mi">0</span> <span class="p">(</span><span class="n">upper</span><span class="p">)</span>
             <span class="mi">10</span> <span class="n">CALL_FUNCTION</span>            <span class="mi">1</span>
             <span class="mi">12</span> <span class="n">GET_ITER</span>
        <span class="o">&gt;&gt;</span>   <span class="mi">14</span> <span class="n">FOR_ITER</span>                <span class="mi">12</span> <span class="p">(</span><span class="n">to</span> <span class="mi">28</span><span class="p">)</span>
             <span class="mi">16</span> <span class="n">STORE_FAST</span>               <span class="mi">2</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>

  <span class="mi">4</span>          <span class="mi">18</span> <span class="n">LOAD_FAST</span>                <span class="mi">1</span> <span class="p">(</span><span class="n">total</span><span class="p">)</span>
             <span class="mi">20</span> <span class="n">LOAD_FAST</span>                <span class="mi">2</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>
             <span class="mi">22</span> <span class="n">INPLACE_ADD</span>
             <span class="mi">24</span> <span class="n">STORE_FAST</span>               <span class="mi">1</span> <span class="p">(</span><span class="n">total</span><span class="p">)</span>
             <span class="mi">26</span> <span class="n">JUMP_ABSOLUTE</span>           <span class="mi">14</span>
        <span class="o">&gt;&gt;</span>   <span class="mi">28</span> <span class="n">POP_BLOCK</span>

  <span class="mi">5</span>     <span class="o">&gt;&gt;</span>   <span class="mi">30</span> <span class="n">LOAD_FAST</span>                <span class="mi">1</span> <span class="p">(</span><span class="n">total</span><span class="p">)</span>
             <span class="mi">32</span> <span class="n">RETURN_VALUE</span>

<span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">fn_terse</span><span class="p">)</span>
  <span class="mi">8</span>           <span class="mi">0</span> <span class="n">LOAD_GLOBAL</span>              <span class="mi">0</span> <span class="p">(</span><span class="nb">sum</span><span class="p">)</span>
              <span class="mi">2</span> <span class="n">LOAD_GLOBAL</span>              <span class="mi">1</span> <span class="p">(</span><span class="nb">xrange</span><span class="p">)</span>
              <span class="mi">4</span> <span class="n">LOAD_FAST</span>                <span class="mi">0</span> <span class="p">(</span><span class="n">upper</span><span class="p">)</span>
              <span class="mi">6</span> <span class="n">CALL_FUNCTION</span>            <span class="mi">1</span>
              <span class="mi">8</span> <span class="n">CALL_FUNCTION</span>            <span class="mi">1</span>
             <span class="mi">10</span> <span class="n">RETURN_VALUE</span>
</code></pre></div></div>

<p>바이트 코드로 살펴보면 두 코드 블록의 차이는 두드러집니다. <code class="highlighter-rouge">fn_expressive()</code> 는 두 개의 지역 변수를 가지며, for 문에 의해 리스트를 순회합니다. for 루프에서 매번 StopIteration 예외가 발생하는지 검사합니다. 루프가 계속될 때마다 두 번재 변수인 n 타입을 검사하는 <code class="highlighter-rouge">total.__add__</code> 함수를 호출합니다. 이러한 추가 검사 과정에서 성능 하락이 누적됩니다.</p>

<p><code class="highlighter-rouge">fn_terse()</code> 는 최적화된 C 리스트 표현식 함수를 호출해 중간 Python 객체를 생성하지 않고 최종 결과를 생성합니다. 여전히 매 반복마다 더해야 할 객체의 타입을 검사하지만 훨씬 빠릅니다.</p>

<h2 id="unit-testing-during-optimization-to-maintain-correctness">Unit Testing During Optimization to Maintain Correctness</h2>

<p>단위 테스트와 더불어 <em>coverage.py</em> 도 함께 고려하는게 좋습니다. <em>coverage.py</em> 를 사용하면 코드의 어떤 부분이 검사되었고 검사되지 않은 부분이 어디인지 알 수 있습니다. 이를 통해 최적화하려는 코드가 검사되는지를 쉽게 알 수 있어서 최적화 중에 실수를 하게 되면 빠르게 알 수 있습니다.</p>

<h3 id="no-op-profile-decorator">No-op @profile Decorator</h3>

<p><code class="highlighter-rouge">line_profiler</code> 나 <code class="highlighter-rouge">memory_profiler</code> 에서 <code class="highlighter-rouge">@profile</code> 을 사용하면 단위테스트에서 NameError 가 발생합니다. 단위 테스트 프레임워크는 <code class="highlighter-rouge">@profile</code> 데코레이터를 로컬 네임스페이스에 추가하지 않았기 때문입니다. 아무것도 하지 않는 <code class="highlighter-rouge">no-op</code> 데코레이터를 이용하면 이 문제를 피할 수 있습니다. 검사하려는 코드 블록에 추가하고 검사가 끝나면 제거하면 됩니다.</p>

<p><code class="highlighter-rouge">no-op</code> 데코레이터를 이용하면 검사하려는 코드를 변경하지 않고 테스트를 실행할 수 있습니다. 즉, 프로파일링을 통한 최적화 작업 중에도 테스트를 돌려볼 수 있기 때문에 잘못된 최적화에 빠지는 일을 방지할 수 있습니다.</p>

<p>아래 예제는 <code class="highlighter-rouge">nosetest</code> 를 위한 테스트가 있고 <code class="highlighter-rouge">line_profiler</code> 나 <code class="highlighter-rouge">memory_profiler</code> 로 프로파일링하는 함수가 하나 있습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ex.py
</span><span class="kn">import</span> <span class="nn">unittest</span>

<span class="o">@</span><span class="n">profile</span>
<span class="k">def</span> <span class="nf">some_fn</span><span class="p">(</span><span class="n">nbr</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">nbr</span> <span class="o">*</span> <span class="mi">2</span>

<span class="k">class</span> <span class="nc">TestCase</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">some_fn</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
  <span class="bp">self</span><span class="o">.</span><span class="n">assertEquals</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">nosetests</code> 를 실행하면 NameError 가 발생합니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>nosetests ex.py
E
<span class="o">======================================================================</span>
ERROR: Failure: NameError <span class="o">(</span>name <span class="s1">'profile'</span> is not defined<span class="o">)</span>
...
NameError: name <span class="s1">'profile'</span> is not defined

Ran 1 <span class="nb">test </span><span class="k">in </span>0.001s

FAILED <span class="o">(</span><span class="nv">errors</span><span class="o">=</span>1<span class="o">)</span>
</code></pre></div></div>

<p>해결 방법은 첫 부분에 <code class="highlighter-rouge">no-op</code> 데코레이터를 추가하는것입니다. 아래는 <code class="highlighter-rouge">line_profiler</code> 의 경우입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># for line_profiler
</span><span class="k">if</span> <span class="s">'__builtin__'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">()</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">__builtin__</span><span class="p">,</span> <span class="s">'profile'</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">__builtin</code> 테스트는 <code class="highlighter-rouge">nosetests</code> 유무를 위한것이며 <code class="highlighter-rouge">hasattr</code> 테스트는 네임스페이스에 <code class="highlighter-rouge">@profile</code> 이 추가되었는지 검사합니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kernprof.py <span class="nt">-v</span> <span class="nt">-l</span> ex.py
Line <span class="c"># Hits Time Per %%HTMLit % Time Line Contents</span>
<span class="o">==============================================================</span>
 11 @profile
 12 def some_fn<span class="o">(</span>nbr<span class="o">)</span>:
 13 1 3 3.0 100.0 <span class="k">return </span>nbr <span class="k">*</span> 2

<span class="nv">$ </span>nosetests ex.py
<span class="nb">.</span>
Ran 1 <span class="nb">test </span><span class="k">in </span>0.000s
</code></pre></div></div>

<p>아래 예제는 <code class="highlighter-rouge">memory_profiler</code> 를 위한 <code class="highlighter-rouge">no-op</code> 데코레이터 입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># for memory_profiler
</span><span class="k">if</span> <span class="s">'profile'</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">():</span>
  <span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>
</code></pre></div></div>

<p>출력 결과는 아래와 같습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-m</span> memory_profiler ex.py
...
Line <span class="c"># Mem usage Increment Line Contents</span>
<span class="o">================================================</span>
 11 10.809 MiB 0.000 MiB @profile
 12 def some_fn<span class="o">(</span>nbr<span class="o">)</span>:
 13 10.809 MiB 0.000 MiB <span class="k">return </span>nbr <span class="k">*</span> 2

<span class="nv">$ </span>nosetests ex.py
<span class="nb">.</span>
Ran 1 <span class="nb">test </span><span class="k">in </span>0.000
</code></pre></div></div>

<h2 id="strategies-to-profile-your-code-successfully">Strategies to Profile Your Code Successfully</h2>

<p>안정적인 벤치마킹을 위해서는 다음 사항을 기억하면됩니다.</p>

<ul>
  <li>Disable TurboBoost in the BIOS.</li>
  <li>Disable the operating system’s ability to override the SpeedStep (you will find this in your BIOS if you’re allowed to control it).</li>
  <li>Only use mains power (never battery power).</li>
  <li>Disable background tools like backups and Dropbox while running experiments.</li>
  <li>Run the experiments many times to obtain a stable measurement.</li>
  <li>Possibly drop to run level 1 (Unix) so that no other tasks are running.</li>
  <li>Reboot and rerun the experiments to double-confirm the results.</li>
</ul>

:ET