I"z[<p><em>이 포스트는 <a href="https://github.com/ethereumbook/ethereumbook">Mastering Ethereum</a>를 바탕으로 작성하였습니다.</em></p>

<h2 id="a-basic-dapp-example-auction-dapp">A Basic DApp Example: Auction DApp</h2>

<p>경매 댑은 사용자가 주택, 자동차 같은 고유한 자산을 나타내는 <strong>증서(deed)</strong> 토큰을 등록할 수 있게 합니다. 토큰이 등록되면 토큰 소유권이 경매 댑으로 이전되며 판매를 위해 리스팅할 수 있게 합니다. 경매 중에 사용자는 경매를 위해 만들어진 대화방에 참여하고, 경매가 완료되면 증서 토큰 소유권이 경매 낙찰자에게 이전됩니다.</p>

<blockquote>
  <p>Example 1</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/73842165-644bbe80-485f-11ea-9c83-b78a473518f2.png" alt="image" /></p>

<p>경매 댑의 주요 구성 요소는 다음과 같습니다.</p>

<ul>
  <li>ERC721 대체 불가능한 증서 토큰을 구현하는 스마트 컨트랙트</li>
  <li>증서를 팔기 위해 경매를 구현하는 스마트 컨트랙트</li>
  <li>Vue/Vuetify 자바 스크립트 프레임 워크를 사용하는 웹 프론트엔드</li>
  <li>이더리움 체인에 연결하는 web3.js 라이브러리</li>
  <li>이미지 같은 자원을 저장하는 스웜 클라이언트</li>
  <li>모든 참여자를 위해 경매별 대화방을 개설하기 위한 위스퍼 클라이언트</li>
</ul>

<p>경매댑 소스 코드는 <a href="https://github.com/ethereumbook/ethereumbook/tree/develop/code/auction_dapp">Github</a> 로 가면 됩니다.</p>

<h3 id="auction-dapp-backend-smart-contracts">Auction DApp: Backend Smart Contracts</h3>

<p>아래 예제는 <code class="highlighter-rouge">DeedRepository</code> 를 살펴보겠습니다. 이 컨트랙트는 ERC721 대체 불가능한 토큰입니다.</p>

<blockquote>
  <p>Example - DeedRepository.sol: An ERC721 deed token for use in an auction</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pragma</span> <span class="n">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="o">.</span><span class="mi">17</span><span class="o">;</span>
<span class="kn">import</span> <span class="err">"</span><span class="nn">.</span><span class="o">/</span><span class="no">ERC721</span><span class="o">/</span><span class="nc">ERC721Token</span><span class="o">.</span><span class="na">sol</span><span class="err">"</span><span class="o">;</span>

<span class="cm">/**
 * @title Repository of ERC721 Deeds
 * This contract contains the list of deeds registered by users.
 * This is a demo to show how tokens (deeds) can be minted and added 
 * to the repository.
 */</span>
<span class="n">contract</span> <span class="nc">DeedRepository</span> <span class="n">is</span> <span class="nc">ERC721Token</span> <span class="o">{</span>


    <span class="cm">/**
    * @dev Created a DeedRepository with a name and symbol
    * @param _name string represents the name of the repository
    * @param _symbol string represents the symbol of the repository
    */</span>
    <span class="n">function</span> <span class="nf">DeedRepository</span><span class="o">(</span><span class="n">string</span> <span class="n">_name</span><span class="o">,</span> <span class="n">string</span> <span class="n">_symbol</span><span class="o">)</span> 
        <span class="kd">public</span> <span class="nf">ERC721Token</span><span class="o">(</span><span class="n">_name</span><span class="o">,</span> <span class="n">_symbol</span><span class="o">)</span> <span class="o">{}</span>
    
    <span class="cm">/**
    * @dev Public function to register a new deed
    * @dev Call the ERC721Token minter
    * @param _tokenId uint256 represents a specific deed
    * @param _uri string containing metadata/uri
    */</span>
    <span class="n">function</span> <span class="nf">registerDeed</span><span class="o">(</span><span class="n">uint256</span> <span class="n">_tokenId</span><span class="o">,</span> <span class="n">string</span> <span class="n">_uri</span><span class="o">)</span> <span class="kd">public</span> <span class="o">{</span>
        <span class="n">_mint</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">sender</span><span class="o">,</span> <span class="n">_tokenId</span><span class="o">);</span>
        <span class="n">addDeedMetadata</span><span class="o">(</span><span class="n">_tokenId</span><span class="o">,</span> <span class="n">_uri</span><span class="o">);</span>
        <span class="n">emit</span> <span class="nf">DeedRegistered</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">sender</span><span class="o">,</span> <span class="n">_tokenId</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
    * @dev Public function to add metadata to a deed
    * @param _tokenId represents a specific deed
    * @param _uri text which describes the characteristics of a given deed
    * @return whether the deed metadata was added to the repository
    */</span>
    <span class="n">function</span> <span class="nf">addDeedMetadata</span><span class="o">(</span><span class="n">uint256</span> <span class="n">_tokenId</span><span class="o">,</span> <span class="n">string</span> <span class="n">_uri</span><span class="o">)</span> <span class="kd">public</span> <span class="nf">returns</span><span class="o">(</span><span class="n">bool</span><span class="o">){</span>
        <span class="n">_setTokenURI</span><span class="o">(</span><span class="n">_tokenId</span><span class="o">,</span> <span class="n">_uri</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
    * @dev Event is triggered if deed/token is registered
    * @param _by address of the registrar
    * @param _tokenId uint256 represents a specific deed
    */</span>
    <span class="n">event</span> <span class="nf">DeedRegistered</span><span class="o">(</span><span class="n">address</span> <span class="n">_by</span><span class="o">,</span> <span class="n">uint256</span> <span class="n">_tokenId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>보다시피 ERC721 호환 토큰을 간단하게 구현한 것입니다.</p>

<p>이 컨트랙트를 사용하여 각 경매에 대한 토큰을 발행하고 추적합니다. 경매 자체는 <code class="highlighter-rouge">AuctionRepository</code> 컨트랙트에 의해 조율됩니다.</p>

<p>위 코드는 너무 길어서 중요한 부분만 적겠습니다. 전체 코드는 <a href="https://github.com/ethereumbook/ethereumbook/blob/develop/code/auction_dapp/backend/contracts/AuctionRepository.sol">Github</a> 경로에 있습니다.</p>

<blockquote>
  <p>Example - AuctionRepository.sol: The main Auction DApp smart contract</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">contract</span> <span class="nc">AuctionRepository</span> <span class="o">{</span>
    
    <span class="c1">// Array with all auctions</span>
    <span class="nc">Auction</span><span class="o">[]</span> <span class="kd">public</span> <span class="n">auctions</span><span class="o">;</span>

    <span class="c1">// Mapping from auction index to user bids</span>
    <span class="n">mapping</span><span class="o">(</span><span class="n">uint256</span> <span class="o">=&gt;</span> <span class="nc">Bid</span><span class="o">[])</span> <span class="kd">public</span> <span class="n">auctionBids</span><span class="o">;</span>

    <span class="c1">// Mapping from owner to a list of owned auctions</span>
    <span class="n">mapping</span><span class="o">(</span><span class="n">address</span> <span class="o">=&gt;</span> <span class="n">uint</span><span class="o">[])</span> <span class="kd">public</span> <span class="n">auctionOwner</span><span class="o">;</span>

    <span class="c1">// Bid struct to hold bidder and amount</span>
    <span class="n">struct</span> <span class="nc">Bid</span> <span class="o">{</span>
        <span class="n">address</span> <span class="n">from</span><span class="o">;</span>
        <span class="n">uint256</span> <span class="n">amount</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Auction struct which holds all the required info</span>
    <span class="n">struct</span> <span class="nc">Auction</span> <span class="o">{</span>
        <span class="n">string</span> <span class="n">name</span><span class="o">;</span>
        <span class="n">uint256</span> <span class="n">blockDeadline</span><span class="o">;</span>
        <span class="n">uint256</span> <span class="n">startPrice</span><span class="o">;</span>
        <span class="n">string</span> <span class="n">metadata</span><span class="o">;</span>
        <span class="n">uint256</span> <span class="n">deedId</span><span class="o">;</span>
        <span class="n">address</span> <span class="n">deedRepositoryAddress</span><span class="o">;</span>
        <span class="n">address</span> <span class="n">owner</span><span class="o">;</span>
        <span class="n">bool</span> <span class="n">active</span><span class="o">;</span>
        <span class="n">bool</span> <span class="n">finalized</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">AuctionRepository</code> 컨트랙트는 다음 기능을 사용하여 모든 경매를 관리합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">getCount</span><span class="o">()</span>
<span class="n">getBidsCount</span><span class="o">(</span><span class="n">uint</span> <span class="n">_auctionId</span><span class="o">)</span>
<span class="n">getAuctionsOf</span><span class="o">(</span><span class="n">address</span> <span class="n">_owner</span><span class="o">)</span>
<span class="n">getCurrentBid</span><span class="o">(</span><span class="n">uint</span> <span class="n">_auctionId</span><span class="o">)</span>
<span class="n">getAuctionsCountOfOwner</span><span class="o">(</span><span class="n">address</span> <span class="n">_owner</span><span class="o">)</span>
<span class="n">getAuctionById</span><span class="o">(</span><span class="n">uint</span> <span class="n">_auctionId</span><span class="o">)</span>
<span class="n">createAuction</span><span class="o">(</span><span class="n">address</span> <span class="n">_deedRepositoryAddress</span><span class="o">,</span> <span class="n">uint256</span> <span class="n">_deedId</span><span class="o">,</span>
              <span class="n">string</span> <span class="n">_auctionTitle</span><span class="o">,</span> <span class="n">string</span> <span class="n">_metadata</span><span class="o">,</span> <span class="n">uint256</span> <span class="n">_startPrice</span><span class="o">,</span>
              <span class="n">uint</span> <span class="n">_blockDeadline</span><span class="o">)</span>
<span class="n">approveAndTransfer</span><span class="o">(</span><span class="n">address</span> <span class="n">_from</span><span class="o">,</span> <span class="n">address</span> <span class="n">_to</span><span class="o">,</span> <span class="n">address</span> <span class="n">_deedRepositoryAddress</span><span class="o">,</span>
                   <span class="n">uint256</span> <span class="n">_deedId</span><span class="o">)</span>
<span class="n">cancelAuction</span><span class="o">(</span><span class="n">uint</span> <span class="n">_auctionId</span><span class="o">)</span>
<span class="n">finalizeAuction</span><span class="o">(</span><span class="n">uint</span> <span class="n">_auctionId</span><span class="o">)</span>
<span class="n">bidOnAuction</span><span class="o">(</span><span class="n">uint</span> <span class="n">_auctionId</span><span class="o">)</span>
</code></pre></div></div>

<p>책의 저장소에 있는 truffle 을 사용하여 이더리움 블록체인에 컨트랙트를 배포할 수 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>code/auction_dapp/backend
<span class="nv">$ </span>truffle init
<span class="nv">$ </span>truffle compile
<span class="nv">$ </span>truffle migrate <span class="nt">--network</span> ropsten
</code></pre></div></div>

<h3 id="dapp-governance">DApp governance</h3>

<p>경매 댑의 스마트 컨트랙트를 살펴보면 특별 권한을 가진 계정이나 역할이 없습니다. 경매에는 특별한 권한이 있는 소유자가 있지만 경매 댑 자체에는 특권을 가진 사용자가 없습니다.</p>

<p>이는 댑 거버넌스를 탈중앙화하고 배포되면 모든 통제권을 포기하게 만들기 위한 선택입니다. 이에 비해 일부 댑은 컨트랙트를 무시하거나 설정을 변경하거나 특정 작업을 ‘veto’ 할 수 있는 능력을 가진 계정을 보유하고 있습니다. 일반적으로 이러한 기능은 버그로 인해 알려지지 않은 문제를 피하기 위해 댑에 적용됩니다.</p>

<p>댑은 특권 계정을 위한 특수 접근 권한을 허용하지 말아야합니다. 왜냐하면 그것은 탈중앙화가 아니기 때문입니다.</p>

<h3 id="auction-dapp-frontend-user-interface">Auction DApp: Frontend User Interface</h3>

<p>경매 댑이 배포되면 web3.js 나 web3 라이브러리를 사용하여 댑의 컨트랙트와 상호작용 할 수 있지만 대부분의 사용자는 쉬운 인터페이스가 필요하기 때문에 Vue/Vuetify 자바스크립트 프레임워크를 사용하여 작성하였습니다.</p>

<p>위 경로에는 <a href="https://github.com/ethereumbook/ethereumbook/tree/develop/code/auction_dapp/frontend">Github</a> 사용자 인터페이스 코드를 찾을 수 있습니다. 디렉토리 구조는 아래와 같습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>frontend/
|-- build
|   |-- build.js
|   |-- check-versions.js
|   |-- logo.png
|   |-- utils.js
|   |-- vue-loader.conf.js
|   |-- webpack.base.conf.js
|   |-- webpack.dev.conf.js
|   <span class="sb">`</span><span class="nt">--</span> webpack.prod.conf.js
|-- config
|   |-- dev.env.js
|   |-- index.js
|   <span class="sb">`</span><span class="nt">--</span> prod.env.js
|-- index.html
|-- package.json
|-- package-lock.json
|-- README.md
|-- src
|   |-- App.vue
|   |-- components
|   |   |-- Auction.vue
|   |   <span class="sb">`</span><span class="nt">--</span> Home.vue
|   |-- config.js
|   |-- contracts
|   |   |-- AuctionRepository.json
|   |   <span class="sb">`</span><span class="nt">--</span> DeedRepository.json
|   |-- main.js
|   |-- models
|   |   |-- AuctionRepository.js
|   |   |-- ChatRoom.js
|   |   <span class="sb">`</span><span class="nt">--</span> DeedRepository.js
|   <span class="sb">`</span><span class="nt">--</span> router
|       <span class="sb">`</span><span class="nt">--</span> index.js
</code></pre></div></div>

<p>컨트랙트 배포 후 <em>frontend/src/config.js</em> 에서 프론트엔드 설정을 편집하고 <code class="highlighter-rouge">DeedRepository</code> 및 <code class="highlighter-rouge">AuctionRepository</code> 컨트랙트 주소를 배포된 대로 입력하세요. 프론트 어플리케이션도 JSON-RPC / WebSockets 인터페이스를 제공하는 이더리움 노드에 대한 접근이 필요합니다. 그 후 프론트앤드를 실행하면 됩니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>npm <span class="nb">install</span>
<span class="nv">$ </span>npm run dev
</code></pre></div></div>

<p>실행이 되면 웹 브라우저에서 <strong>http://localhost:8080</strong> 을 통해 접근할 수 있습니다.</p>

<p>정상적으로 실행되면 아래와 같은 화면이 표시됩니다.</p>

<blockquote>
  <p>Example 2 - Auction DApp user interface</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/73845255-96601f00-4865-11ea-945f-d3e56cde059b.png" alt="image" /></p>

<h2 id="further-decentralizing-the-auction-dapp">Further Decentralizing the Auction DApp</h2>

<p>댑을 탈중앙화하고 복원력을 좋게 만들 수 있는 2 가지 방법이 있습니다.</p>

<ul>
  <li>모든 어플리케이션 코드를 스웜 또는 IPFS 에 저장한다.</li>
  <li>이더리움 네임 서비스를 사용하여 네임을 참조하여 댑에 접근한다.</li>
</ul>

<h2 id="storing-the-auction-dapp-on-swarm">Storing the Auction DApp on Swarm</h2>

<p>댑 자체의 프론트엔드 전체를 스웜에 저장하고 웹 서버를 실행하는대신 스웜 노드에서 직접 실행해 보겠습니다.</p>

<h3 id="preparing-swarm">Preparing Swarm</h3>

<p>먼저 스웜을 설치하고 스웜 노드를 초기합니다.</p>

<p>스웜을 설치하고나면 스웜을 실행하여 version 명령어로 올바르게 설치된지 확인합니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>swarm version
Version: 0.3
Git Commit: 37685930d953bcbe023f9bc65b135a8d8b8f1488
Go Version: go1.10.1
OS: linux
</code></pre></div></div>

<p>스웜을 실행하려면 JSON_RPC API 에 접근하기 위해 게스 인스턴스에 연결해야 합니다.</p>

<p>스웜을 시작하면 다음 내용이 표시됩니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Maximum peer count                       <span class="nv">ETH</span><span class="o">=</span>25 <span class="nv">LES</span><span class="o">=</span>0 <span class="nv">total</span><span class="o">=</span>25
Starting peer-to-peer node               <span class="nv">instance</span><span class="o">=</span>swarm/v0.3.1-225171a4/linux...
connecting to ENS API                    <span class="nv">url</span><span class="o">=</span>http://127.0.0.1:8545
swarm[5955]: <span class="o">[</span>189B blob data]
Starting P2P networking
UDP listener up                          <span class="nv">self</span><span class="o">=</span>enode://f50c8e19ff841bcd5ce7d2d...
Updated bzz <span class="nb">local </span>addr                   <span class="nv">oaddr</span><span class="o">=</span>9c40be8b83e648d50f40ad3... <span class="nv">uaddr</span><span class="o">=</span>e
Starting Swarm service
9c40be8b hive starting
detected an existing store. trying to load peers
hive 9c40be8b: peers loaded
Swarm network started on bzz address: 9c40be8b83e648d50f40ad3d35f...
Pss started
Streamer started
IPC endpoint opened                      <span class="nv">url</span><span class="o">=</span>/home/ubuntu/.ethereum/bzzd.ipc
RLPx listener up                         <span class="nv">self</span><span class="o">=</span>enode://f50c8e19ff841bcd5ce7d2d...
</code></pre></div></div>

<p>로컬 스웜 게이트웨이 웹 인터페이스 <strong>http://localhost:8500</strong> 에 연결하여 스웜 노드가 올바르게 실행되고 있는지 확인할 수 있습니다.</p>

<blockquote>
  <p>Example 3 - Swarm gateway on localhost</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/73930718-59a22f80-491a-11ea-9fee-dad4c1c4a021.png" alt="image" /></p>

<h3 id="uploading-files-to-swarm">Uploading Files to Swarm</h3>

<p>로컬 스웜 노드와 게이트웨이가 실행되면 스웜에 업로드 할 수 있으며, 파일 해시를 참조하여 스웜 노드에서 파일에 접근할 수 있습니다.</p>

<p>파일을 업로드하여 테스트해보겠습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>swarm up code/auction_dapp/README.md
ec13042c83ffc2fb5cb0aa8c53f770d36c9b3b35d0468a0c0a77c97016bb8d7c
</code></pre></div></div>

<p>경매 댑에는 모든 자원을 패키징하는 스크립트가 있습니다.</p>

<p>파일 하나를 업로드 하는 것은 비교적 간단하지만, 댑 프런트 엔드 전체를 업로드 하는 것은 좀 더 복잡합니다. 일반적으로 웹 서버는 URL 을 로컬 파일로 변환하고 올바른 자원을 제공합니다. 우리는 댑을 패키징하여 스웜에 대해서도 동일한 결과를 얻을 수 있습니다.</p>

<p>경매 댑에는 모든 자원을 패키징하는 스크립트가 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>code/auction_dapp/frontend
<span class="nv">$ </span>npm run build

<span class="o">&gt;</span> frontend@1.0.0 build /home/aantonop/Dev/ethereumbook/code/auction_dapp/frontend
<span class="o">&gt;</span> node build/build.js

Hash: 9ee134d8db3c44dd574d
Version: webpack 3.10.0
Time: 25665ms
Asset     Size
static/js/vendor.77913f316aaf102cec11.js  1.25 MB
static/js/app.5396ead17892922422d4.js   502 kB
static/js/manifest.87447dd4f5e60a5f9652.js  1.54 kB
static/css/app.0e50d6a1d2b1ed4daa03d306ced779cc.css  1.13 kB
static/css/app.0e50d6a1d2b1ed4daa03d306ced779cc.css.map  2.54 kB
static/js/vendor.77913f316aaf102cec11.js.map  4.74 MB
static/js/app.5396ead17892922422d4.js.map   893 kB
static/js/manifest.87447dd4f5e60a5f9652.js.map  7.86 kB
index.html  1.15 kB

Build complete.
</code></pre></div></div>

<p>이 명령의 결과는 새로운 디렉터리 <code class="highlighter-rouge">code/auction_dapp/frontend/dist</code> 에 있스빈다. 경매 댑 프론트엔드 전체를 포함하여 함께 패키징됩니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dist/
|-- index.html
<span class="sb">`</span><span class="nt">--</span> static
    |-- css
    |   |-- app.0e50d6a1d2b1ed4daa03d306ced779cc.css
    |   <span class="sb">`</span><span class="nt">--</span> app.0e50d6a1d2b1ed4daa03d306ced779cc.css.map
    <span class="sb">`</span><span class="nt">--</span> js
        |-- app.5396ead17892922422d4.js
        |-- app.5396ead17892922422d4.js.map
        |-- manifest.87447dd4f5e60a5f9652.js
        |-- manifest.87447dd4f5e60a5f9652.js.map
        |-- vendor.77913f316aaf102cec11.js
        <span class="sb">`</span><span class="nt">--</span> vendor.77913f316aaf102cec11.js.map
</code></pre></div></div>

<p>이제 up 명령과 –recursive 옵션을 사용하여 댑 전체를 스웜에 업로드할 수 있습니다. 여기서 <code class="highlighter-rouge">index.html</code> 이 댑을 로드하기 위한 defaultpath 라는 사실을 스웜에게 알려줍니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>swarm <span class="nt">--bzzapi</span> http://localhost:8500 <span class="nt">--recursive</span> <span class="se">\</span>
  <span class="nt">--defaultpath</span> dist/index.html up dist/

ab164cf37dc10647e43a233486cdeffa8334b026e32a480dd9cbd020c12d4581
</code></pre></div></div>
:ET