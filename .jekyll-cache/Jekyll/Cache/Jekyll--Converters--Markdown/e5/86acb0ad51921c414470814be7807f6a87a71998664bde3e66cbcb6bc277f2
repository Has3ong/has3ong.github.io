I"<p><em>이 포스트는 <a href="">Optimizing Java</a> 를 바탕으로 작성하였습니다.</em></p>

<p>Java 언어는 컴퓨팅 파워가 향상되면서 많은 혜택을 받았습니다. 하지만 성능을 고민하는 Java 프로그래머는 가용 리소스를 최대한 활용할 수 있도록 Java 플랫폼의 근간 원리와 기술을 잘 알고 있어야 합니다.</p>

<h2 id="introduction-to-modern-hardware">Introduction to Modern Hardware</h2>

<p>1990 년대 이후 어플리케이션 개발 세상은 대부분 인텔 x86/x64 아키텍처 위주로 돌아갔습니다. 이후 등장한 수 많은 고급 기능들이 핵심부를 형성하고 있습니다. 이제 프로세서 작동 원리를 단순화한 모델은 전혀 맞지 않고 그런 모델을 토대로 직관적인 추론을 하면 엉뚱한 결론을 내리기 쉽습니다.</p>

<p>그간 발전된 여러가지 CPU 기술을 알아보겠습니다. 먼저 Java 개발자에게 가장 중요한 메모리로 시작하겠습니다.</p>

<h2 id="memory">Memory</h2>

<p>무어의 법칙에 따라 개수가 급증한 트랜지스터는 처음엔 <strong>Clock Speed</strong> 를 높이는 데 쓰였습니다. 클록 속도가 증가하면 초당 더 많은 명령어를 처리할 수 있기 때문입니다.</p>

<p>하지만 클록 속도가 증가하니 다른 문제가 생겼습니다. 바로 칩이 빨라질수록 데이터도 더 빨리 움직여야 하는데, 시간이 갈수록 프로세서 코어의 데이터 수요를 메인 메모리가 맞추기 어려워졌습니다. <code class="highlighter-rouge">Example 1</code></p>

<blockquote>
  <p>Example 1 - Speed of memory and transistor counts (Hennessy and Patterson, 2011)</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74581902-79131980-4ff8-11ea-8989-282afb760fc5.png" alt="image" /></p>

<p>그 결과 클록 속도가 올라가도 데이터가 도착할 때까지 CPU 는 놀면서 기다려야하니 아무 소용도 업게되었습니다.</p>

<h3 id="memory-caches">Memory Caches</h3>

<p>그래서 CPU 캐시가 고안됐습니다. CPU 캐시는 CPU 에 있는 메모리 영역입니다. 레지스터보다는 느리지만 메인 메모리보다 훨씬 빠릅니다. 자주 액세스하는 메모리 위치는 CPU 가 메인 메모리를 재참조하지 않게 사본을 떠서 CPU 캐시에 보관하자는 아이디어입니다.</p>

<p>요즘 CPU 에는 액세스 빈도가 높은 캐시일수록 프로세서 코어와 더 가가이 위치하는 식으로 여러 캐시 계층이 있습니다. CPU 와 가장 가까운 캐시가 L1, 그 다음 L2 식으로 명명합니다.</p>

<p>프로세서 아키텍처에 따라 캐시 개수 및 설정 상태는 제각각이지만, 일반적으로 각 실행 코어에 전용 프라이빗 캐시 L1, L2 를 두고, 일부 또는 전체 코어가 공유하는 L3 캐시를 둡니다. 아래 <code class="highlighter-rouge">Example 2</code> 는 캐시를 쓰면 액세스 시간이 얼마나 빨라지는지 비교하는 작업입니다.</p>

<blockquote>
  <p>Example 2 - Access times for various types of memory</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74581903-7a444680-4ff8-11ea-87bb-cb4d21b8020a.png" alt="image" /></p>

<p>이렇게 캐시 아키텍처를 이용해 액세스 시간을 줄이고 코어가 처리할 데이터를 계속 채워 넣습니다. 클록 속도와 액세스 시간의 차이 때문에 최신 CPU 는 더 많은 예산을 캐시에 투자합니다.</p>

<p>아래 <code class="highlighter-rouge">Example 3</code> 은 그 결과 완성된 설계도입니다. CPU 코어마다 전용 L1, L2 캐시가 있고 모든 코어가 공유하는 L3 캐시가 있습니다. 메인 메로리는 <strong>NorthBridge</strong> 컴포넌트를 거쳐 액세스하고 이 버스를 관통하여 메인 메모리 액세스 시간이 줄어듭니다.</p>

<blockquote>
  <p>Example 3 - Overall CPU and memory architecture</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74581904-7b757380-4ff8-11ea-84a7-43b95dbb86fa.png" alt="image" /></p>

<p>캐시 아키텍처를 추가한 덕분에 프로세서 처리율은 개선됐지만, 메모리에 있는 데이터를 어떻게 캐시로 가져오고 캐시한 데이터를 어떻게 메모리에 다시 써야 할지 결정해야했습니다. 이 문제는 <strong>Cache Consistency Protocol</strong> 이라는 방법으로 해결했습니다.</p>

<p>프로세서의 가장 저수준에서 MESI 라는 프로토콜이 자주 눈에 띕니다. MESI 프로토콜은 캐시 라인 상태를 다음 4 가지로 정의합니다.</p>

<ul>
  <li>Modified
    <ul>
      <li>데이터가 수정된 상태</li>
    </ul>
  </li>
  <li>Exclusive
    <ul>
      <li>이 캐시에만 존재하고 메인 메모리 내용과 동일한 상태</li>
    </ul>
  </li>
  <li>Shared
    <ul>
      <li>둘 이상의 캐시에 데이터가 들어 있고 메모리 내용과 동일한 상태</li>
    </ul>
  </li>
  <li>Invalid
    <ul>
      <li>다른 프로세스가 데이터를 수정하여 무효한 상태</li>
    </ul>
  </li>
</ul>

<p>요약하면, 멀티 프로세서가 동시에 공유 상태에 있을 수 있다는 것입니다. 하지만, 어느 한 프로세서가 배타나 수정 상태로 바뀌면 다른 프로세서는 모두 강제로 무효 상태가 됩니다.</p>

<blockquote>
  <p>MESI allowable states between processors</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: left">M</th>
      <th style="text-align: left">E</th>
      <th style="text-align: left">S</th>
      <th style="text-align: left">I</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">M</td>
      <td style="text-align: left">-</td>
      <td style="text-align: left">-</td>
      <td style="text-align: left">-</td>
      <td style="text-align: left">Y</td>
    </tr>
    <tr>
      <td style="text-align: left">E</td>
      <td style="text-align: left">-</td>
      <td style="text-align: left">-</td>
      <td style="text-align: left">-</td>
      <td style="text-align: left">Y</td>
    </tr>
    <tr>
      <td style="text-align: left">S</td>
      <td style="text-align: left">-</td>
      <td style="text-align: left">-</td>
      <td style="text-align: left">Y</td>
      <td style="text-align: left">Y</td>
    </tr>
    <tr>
      <td style="text-align: left">I</td>
      <td style="text-align: left">Y</td>
      <td style="text-align: left">Y</td>
      <td style="text-align: left">Y</td>
      <td style="text-align: left">Y</td>
    </tr>
  </tbody>
</table>

<p>이 프로토콜에서는 프로세서가 상태를 바꾸겠다는 의사를 BroadCasting 합니다. 공유 메모리 버스를 통해 전기 신호를 보내면 프로세서가 이를 알아차립니다. 아래 <code class="highlighter-rouge">Example 4</code> 는 전체 <strong>상태 변이(State Transition)</strong> 흐름을 정의한겁니다.</p>

<blockquote>
  <p>Example 4 - MESI state transition diagram</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74581905-7ca6a080-4ff8-11ea-912c-e64e6beee39b.png" alt="image" /></p>

<p>프로세서가 처음 나왔을 당시에는 매번 캐시 연산 결과를 바로 메모리에 기록했습니다. 이를 <strong>동시 기록(write-through)</strong> 라고 하며, 메모리 대역폭을 너무 많이 소모하는 등 효율이 낮아 요즘은 거의 사용안합니다. 후에 출시된 프로세서는 <strong>후 기록(write-back)</strong> 방식을 채택하여 캐시 블록을 교체해도 프로세서가 변경된 캐시 블록만 메모리에 기록하므로 메인 메모리로 되돌아가는 트래픽이 줄어듭니다.</p>

<p>캐시 기술 덕분에 데이터를 신속하게 메모리에서 쓰고 읽을 수 있게 됐습니다. 메모리 대역폭 측면에서 그 효과를 나타낼 수 있는데, 이론적으로 가능한 <strong>최대 전송률(Burst Rate)</strong> 은 다음 인자에 따라 달라집니다.</p>

<ul>
  <li>Clock frequency of memory</li>
  <li>Width of the memory bus (usually 64 bits)</li>
  <li>Number of interfaces (usually two in modern machines)</li>
</ul>

<p><strong>DDR RAM(Double Data Rate)</strong> 은 최대 전송률이 2 배입니다.</p>

<p>캐시 하드웨어의 작동 원리를 나타낸 코드를 살펴보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Caching</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">ARR_SIZE</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">testData</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">ARR_SIZE</span><span class="o">];</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Start: "</span><span class="o">+</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">15_000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">touchEveryLine</span><span class="o">();</span>
            <span class="n">touchEveryItem</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Warmup finished: "</span><span class="o">+</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Item     Line"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">t0</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
            <span class="n">touchEveryLine</span><span class="o">();</span>
            <span class="kt">long</span> <span class="n">t1</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
            <span class="n">touchEveryItem</span><span class="o">();</span>
            <span class="kt">long</span> <span class="n">t2</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
            <span class="kt">long</span> <span class="n">elItem</span> <span class="o">=</span> <span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="o">;</span>
            <span class="kt">long</span> <span class="n">elLine</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span><span class="o">;</span>
            <span class="kt">double</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">elItem</span> <span class="o">-</span> <span class="n">elLine</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">elItem</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">elLine</span> <span class="o">+</span><span class="s">" "</span><span class="o">+</span>  <span class="o">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">diff</span> <span class="o">/</span> <span class="n">elLine</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">touchEveryItem</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">testData</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">testData</span><span class="o">[</span><span class="n">i</span><span class="o">]++;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">touchEveryLine</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">testData</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">16</span><span class="o">)</span>
            <span class="n">testData</span><span class="o">[</span><span class="n">i</span><span class="o">]++;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Caching</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Caching</span><span class="o">();</span>
        <span class="n">c</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>소스코드만 보면 <code class="highlighter-rouge">touchEveryItem()</code> 메소드가 <code class="highlighter-rouge">touchEveryLine()</code> 메소드보다 16 배 더 많이 일을 할 것 같습니다. 하지만 JVM 성능 문제를 잘못 판단하기 쉽습니다. 아래 <code class="highlighter-rouge">Example 5</code> 는 이 클래스를 실행한 샘플링 결과 자료입니다.</p>

<blockquote>
  <p>Example 5 - Time elapsed for Caching example</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74581906-7e706400-4ff8-11ea-8ba9-6281a14e9778.png" alt="image" /></p>

<p>각 함수를 100회 실행한 결과입니다. 시간경과에 따른 패턴이 서로 비슷합니다.</p>

<p>가장 지배적인 영향을 미치는 곳은 메모리 버스를 예열시키는 부분입니다. <code class="highlighter-rouge">touchEveryItem()</code>, <code class="highlighter-rouge">touchEveryLine()</code> 두 메소드를 이용해 배열 컨텐츠를 메인 메모리에서 캐시로 퍼 나르는 코드 입니다. 통계상으로 보면 일정한 모습을 보이다 <strong>Median Value</strong> 에서 30 ~ 35 % 벗어난 특이점이 간혹 보입니다.</p>

<p>약 100 MB 메모리 덩이를 나르는 단순 메모리 연산을 1회 수행할 때 마다 약 3 ms 소요됩니다. 실제 메모리 대역폭은 이론적 최대치인 3.5GB/s 약간 못 미치지만, 나쁘지 않은 수치입니다.</p>

<p>Java 성능을 논할 때는 객체 할당률에 대한 어플리케이션 민감도가 아주 중요합니다.</p>

<h2 id="modern-processor-features">Modern Processor Features</h2>

<p>흔히 하드웨어 엔지니어들은 신기능이 무어의 법칙에 따라 <em>트랜지스터 예산을 쏟아부은</em> 결과라고 합니다. 메모리 캐시는 점점 증가한 트랜지스터를 가장 확실하게 활용하는 분야지만, 지난 수년간 여러가지 다른 기술도 등장했습니다.</p>

<h3 id="translation-lookaside-buffer">Translation Lookaside Buffer</h3>

<p><strong>변환 색인 버퍼(Translation Lookaside Buffer, TLB)</strong> 는 여러 캐시에서 아주 긴요하게 사용하는 장치입니다. 가상 메모리 주소를 물리 메모리 주소로 매핑하는 페이지 테이블의 캐시 역할을 수행합니다. 이 장치 덕분에 가상 주소를 참조해 물리 주소에 액세스하는 빈번한 작업 속도가 매우 빨라집니다.</p>

<blockquote>
  <p>JVM 에도 똑같이 TLB 라고 약칭하는 메모리 관련 기능이 있습니다.</p>
</blockquote>

<p>TLB 가 없으면 L1 캐시에 페이지 테이블이 있어도 가상 주소 룩업에 16 사이클이나 걸리기 때문에 성능이 제대로 나오지 않습니다. 모든 최신 칩에서 TLB 는 사실상 필연입니다.</p>

<h3 id="branch-prediction-and-speculative-execution">Branch Prediction and Speculative Execution</h3>

<p><strong>분기 예측(Branch Prediction)</strong> 은 최신 프로세서 고급 기법 중 하나로, 프로세서가 조건 분기하는 기준값을 평가하느라 대기하는 현상을 방지합니다. 대부분 프로세서가 다단계 명령 파이프라인을 이용해 CPU 1 사이클도 여러 개별 단계로 나누어 실행하므로 여러 명령이 동시 실행 중일 수도 있습니다.</p>

<p>이런 모델에서는 조건문을 다 평가하기 전까지 분기 이후 다음 명령을 알 수 없는게 문제입니다. 그 결과, 분기문 뒤에 나오는 다단계 파이프라인을 비우는 동안 프로세서는 여러 사이클 동안 멈추겓 ㅚㅂ니다.</p>

<p>이런 일이 발생하지 않도록 프로세서는 트랜지스터를 아낌없이 활용하여 가장 발생 가능성이 큰 브랜치를 미리 결정하는 휴리스틱을 형성합니다. 마치 도박이라도 하듯 추측한 결과를 바탕으로 파이프라인을 채웁니다.</p>

<h3 id="hardware-memory-models">Hardware Memory Models</h3>

<p><em>어떻게 하면 서로 다른 여러 CPU 가 일관성 있게 동일한 메모리 주소를 액세스할 수 있을까?</em> 는 멀티코어 시스템에 메모리에 관한 가장 근본적인 질문입니다.</p>

<p>이 질문의 해답은 하드웨어에 따라 드라지만, JIT 컴파일러인 javac 와 CPU 는 일반적으로 코드 실행 순서를 바꿀 수 있습니다. 물론 코드 실행 순서를 바꿔도 현재 스레드가 바라보는 결과는 아무런 영향이 없다는 전제가 필요합니다.</p>

<p>예를 들어, 다음 코드를 보겠습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">myInt</span> <span class="o">=</span> <span class="n">otherInt</span><span class="o">;</span>
<span class="n">intChanged</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</code></pre></div></div>

<p>두 할당문 사이에 다른 코드는 없으니 실행 스레드 입장에선 이들이 어떤 순서로 오든 상관없습니다.</p>

<p>그러나 이 변수들을 바라보는 스레드 입장에서 실행순서가 달라지면 <code class="highlighter-rouge">intChanged</code> 는 <code class="highlighter-rouge">true</code> 로 보여도 <code class="highlighter-rouge">myInt</code> 는 옛날 값을 일긍ㄹ 가능성이 있습니다.</p>

<p>이런 종류의 순서 바꾸기(Reordering) 방식은 x86 칩에서는 불가능하지만, CPU 아키텍처에 따라 조금씩 차이가 있습니다.</p>

<blockquote>
  <p>Hardware memory support</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th style="text-align: left">ARMv7</th>
      <th style="text-align: center">POWER</th>
      <th style="text-align: center">SPARC</th>
      <th style="text-align: center">x86</th>
      <th style="text-align: center">AMD64</th>
      <th style="text-align: center">zSeries</th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">loads moved after loads</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
    </tr>
    <tr>
      <td style="text-align: left">loads moved after stores</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
    </tr>
    <tr>
      <td style="text-align: left">stores moved after stores</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
    </tr>
    <tr>
      <td style="text-align: left">stores moved after loads</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">Y</td>
    </tr>
    <tr>
      <td style="text-align: left">atomic moved with loads</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
    </tr>
    <tr>
      <td style="text-align: left">atomic moved with stores</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">-</td>
    </tr>
    <tr>
      <td style="text-align: left">incoherent instructions</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">Y</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">Y</td>
    </tr>
  </tbody>
</table>

<p>JMM 은 프로세서 타입별로 상이한 메모리 액세스 일관성을 고려하여 명시적으로 <strong>약한 모델(weak model)</strong> 로 설계됐습니다. 따라서 멀티스레드 코드가 제대로 작동하게 하려면 Lock 과 volatile 를 정확히 알고 사용해야 합니다.</p>

<h2 id="operating-systems">Operating Systems</h2>

<p>OS 의 주 임무는 여러 실행 프로세스가 공유하는 리소스 액세르를 관리하는 일입니다. 모든 리소스는 한정돼 있고 프로세스는 저마다 리소스를 더 차지하려고 덤벼들기 때문에 리소스 양을 보고 골고루 나누어줄 중앙 시스템이 있어야 합니다. 한정된 리소스 가운데서 메모리와 CPU 시간은 가장 중요한 포인트입니다.</p>

<p><strong>메모리 관리 유닛(Memory Management Unit, MMU)</strong> 을 통한 <strong>가상 주소 방식(Virtual Addressing)</strong> 과 페이지 테이블은 메모리 액세스 제어의 핵심으로, 한 프로세스가 소유한 메모리 영여긍ㄹ 다른 프로세스가 함부로 훼손하지 못하게 합니다.</p>

<p>앞서 설명한 TLB 는 물리 메모리 주소 룩업 시간을 줄이는 하드웨어 기능입니다. 아무래도 버퍼를 사용하면 소프트웨어가 메모리에 액세스하는 성능이 향상되지만, MMU 는 개발자가 세부를 파악해서 직접 손대기엔 너무 저수준 영역이므로 대신 OS 스케줄러를 자세히 살펴보겠습니다. CPU 액세스를 제어하는 OS 스케줄러는 유저 입장에서 훨씬 시각적인 OS 커널 요소입니다.</p>

<h3 id="the-scheduler">The Scheduler</h3>

<p><strong>프로세스 스케줄러(Process Scheduler)</strong> 는 CPU 액세스를 통제합니다. 이때 <strong>실행 큐(Run Queue)</strong> 라는 큐를 이용합니다. 최신 시스템은 거의 항상 가능한 수준보다 더 많은 스레드 / 프로세스로 가득하기 때문에 CPU 자원 경쟁을 해소할 장치가 필요합니다.</p>

<p>스케줄러는 인터럽트에 응답하고 CPU 코어 액세스를 관리합니다. 아래 <code class="highlighter-rouge">Example 6</code> 은 Java 스레드의 수명주기를 나타내는 그림입니다. Java 명세서에는 이론적으로 Java 스레드가 굳이 OS 스레드와ㅇ= 일치할 필요 없는 스레딩 모델을 허용한다고 되어있지만, 실제로 이런 방식이 유용하지 않다는 사실이 밝혀져 주류 운영 환경에서는 배제됐습니다.</p>

<blockquote>
  <p>Example 6 - Thread lifecycle</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74581907-803a2780-4ff8-11ea-9ead-77e8bf52f97d.png" alt="image" /></p>

<p><code class="highlighter-rouge">Example 6</code> 속 OS 스케줄러는 스레드를 시스템 단일 코어로 분주히 나릅니다. 스케줄러는 할당 시간 끝 무렵 실행 큐로 스레드를 되돌려 큐의 맨 앞으로가 다시 실행될 때까지 대기시킵니다.</p>

<p>스레드가 자신이 할당받은 시간을 자발적으로 포기하려면 <code class="highlighter-rouge">sleep()</code> 메소드로 잠들 시간을 설정하거나 <code class="highlighter-rouge">wait()</code> 메소드로 대기 조건을 명시합니다. 스레드는 I/O 또는 소프트웨어 Lock 에 걸려 블로킹 될 수 있습니다.</p>

<p>OS 는 특성상 CPU 에서 코드가 실행되지 않는 시간을 유발합니다. 자신의 할당 시간을 다 쓴 프로세스는 실행 큐 맨 앞으로 갈 떄까지 CPU 로 복귀하지 않습니다. CPU 가 아껴 써야 할 리소스임을 감안하면 코드가 정작 실행되는 시간보다 기다리는 시간이 더 많다는 뜻입니다.</p>

<p>그러므로 실제로 관측한 프로세스에 나온 통계치는 시스템에 있는 다른 프로세스의 동작에도 영향을 받습니다. 이런 <strong>ㅓitter</strong> 와 스케줄링 오버헤드는 측정 결과에 Noise 를 만드는 주요 원인입니다.</p>

<p>스케줄러의 움직임을 확인하는 가장 쉬운 방법은 OS 가 스케줄링 과정에서 발생시킨 오버헤드를 관측하는 겁니다. 다음 코드는 1 ms 씩 총 1000 회 스레드를 재웁니다. 이 스레드는 한번 잠들 때마다 실행 큐 맨 뒤로 가고 새로 시간을 할당받을 때까지 기다리므로 이 코드의 총 실행시간을 보면 여느 프로세스에서 스케줄링 오버헤드가 얼마나 될지 짐작할 수 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1_000</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
<span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">curretTimeMillis</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Millis elapsed: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">/</span> <span class="mf">4000.0</span><span class="o">);</span>
</code></pre></div></div>

<p>OS 마다 결과는 다릅니다. UNIX 는 대략 10 ~ 20 % 가 오버헤드입니다. WindowXP 경우 오버헤드는 180 % 까지 이릅니다.</p>

<p><strong>타이밍(Timing)</strong> 은 성능 측정, 프로세스 스케줄링, 기타 어플리케이션 스택의 다양한 파트에서 아주 중요합니다. 그럼 Java 플랫폼은 어떻게 처리하는지 간략하게 알아보겠습니다.</p>

<h3 id="a-question-of-time">A Question of Time</h3>

<p><strong>POSIX(Portable Operating System Interface)</strong> 는 같은 업계 표준이 있어도 OS 는 다르게 작동합니다. <code class="highlighter-rouge">os::javaTimeMillis()</code> 함수를 예로 들어보겠습니다. OpenJDK 에서 이 함수는 실제로 작업을 수행하고 Java <code class="highlighter-rouge">System.currentTimeMillis()</code> 메소드의 반환값을 공급하는 OS 에 특정한 호출이 있습니다.</p>

<p><code class="highlighter-rouge">os::javaTimeMillis()</code> 는 Host OS 가 제공하는 기능에 의존하는 함수라 네이티브 메소드로 구현합니다. 다음은 BSD UNIX 에서 사용하는 함수입니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jlong</span> <span class="nl">os:</span><span class="o">:</span><span class="n">javaTimeMillis</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">timeval</span> <span class="n">time</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">gettimeofday</span><span class="o">(&amp;</span><span class="n">time</span><span class="o">,</span> <span class="no">NULL</span><span class="o">);</span>
    <span class="k">assert</span><span class="o">(</span><span class="n">status</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="s">"bsd error"</span><span class="o">);</span>
    <span class="k">return</span> <span class="nf">jlong</span><span class="o">(</span><span class="n">time</span><span class="o">.</span><span class="na">tv_sec</span><span class="o">)</span> <span class="o">*</span> <span class="mi">1000</span>  <span class="o">+</span>  <span class="n">jlong</span><span class="o">(</span><span class="n">time</span><span class="o">.</span><span class="na">tv_usec</span> <span class="o">/</span> <span class="mi">1000</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Window 는 완전히 다릅니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jlong</span> <span class="nl">os:</span><span class="o">:</span><span class="n">javaTimeMillis</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">UseFakeTimers</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">fake_time</span><span class="o">++;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="no">FILETIME</span> <span class="n">wt</span><span class="o">;</span>
        <span class="nc">GetSystemTimeAsFileTime</span><span class="o">(&amp;</span><span class="n">wt</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">windows_to_java_time</span><span class="o">(</span><span class="n">wt</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Window 는 UNIX timeval 구조체 대신 64 bit FileTIME 구조체를 이용해 1601 년 이후 경과한 시간을 100 ns 단위로 기록합니다. Window 는 물리 타이밍 하드웨어에 따라 달라지는 시스템 클록의 <strong>실 정확도(Real Accuracy)</strong> 라는 개념이 있어서 Java 에서 타이밍 콜을 해도 그 작동 방식은 Window 가 위치한 머신에 따라 달라집니다.</p>

<h3 id="context-switches">Context Switches</h3>

<p><strong>컨텍스트 교환(Context Switch)</strong> 은 OS 스케줄러가 현재 실행 중인 스레드 / 태스크를 없애고 대기 중인 다른 스레드 / 태스크로 대체하는 프로세스 입니다. 종류는 다양하지만 컨텍스트 교환은 스레드 실행 명령과 스택 상태를 교체하는 모든 일에 연관되어 있습니다.</p>

<p>유저 스레드 사이에 발생하든, 유저 모드에서 커널 모드로 바뀌면서 일어나든 컨텍스트 교환은 무거운 작업입니다. 유저 스레드가 <strong>타임 슬라이스(Time Slice)</strong> 도중 커널 모드로 바꾸어 어떤 기능을 수행할 수 있습니다. 하지만 유저 공간에 있는 코드가 액세스 하는 메모리 영역은 커널 코드와 공유할 부분이 없기 때문에 모드가 바뀌면 명령어와 다른 캐시를 어쩔 수 없이 강제로 비워야 합니다.</p>

<p>커널 모드로 컨텍스트가 교환되면 TLB 를 비롯한 다른 캐시까지 무효화됩니다. 이들 캐시는 시스템 콜 반환 시 다시 채워야 하므로 커널 모드 교환의 여파는 유저 공간으로 다시 제어권이 넘어간 후에도 다웁ㄴ간 이어집니다. 그래서 <code class="highlighter-rouge">Example 7</code> 에서 나타낸 시스템 콜의 진짜 비용이 가려집니다.</p>

<blockquote>
  <p>Example 7 - Impact of a system call (Soares and Stumm, 2010)</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74581908-8203eb00-4ff8-11ea-97f3-233e0814d33a.png" alt="image" /></p>

<p>Linux 는 이를 최대한 만회하려고 <strong>가상 동적 공유 객체(Virtual Dynamically Shared Object, vDSO)</strong> 라는 장치를 제공합니다. vDSO 는 굳이 커널 Privileges 이 필요없는 시스템 콜의 속도를 높이려고 쓰는 유저 공간의 메모리 영역입니다. 커널 모드로 컨텍스트를 교환하지 않으므로 그만큼 속도가 빠릅니다.</p>

<p><code class="highlighter-rouge">gettimeofday()</code> 는 UNIX 시스템에서 아주 흔히 쓰는 시스템 콜입니다. OS 가 인지한 Wallclock Time 을 반환합니다. 물밑에서 커널 자료 구조를 읽어 시스템 클록시간을 얻습니다. Side Effect 를 일으키지 않으므로 실제로 Privileged Access 는 필요 없습니다.</p>

<p>이 자료 구조를 vDSO 로 유저 프로세스의 주소 공간에 매핑시킬 수 있다면 커널 모드로 바꿀 필요가 없습니다. <code class="highlighter-rouge">Example 7</code> 에서 색칠한 부분의 손실을 감내할 이유도 전무합니다.</p>

<p>타이밍 자료를 빈번하게 액세스하는 Java 어플리케이션에서는 이런 식으로 성능을 끌어올릴 수 있습니다. 비록 Linux 에서만 사용할 수 있지만 vDSO 는 필자가 예시한 사례를 좀 더 일반화한 기법입니다.</p>

<h2 id="a-simple-system-model">A Simple System Model</h2>

<p>이 시스템 모델의 근본은 UNIX 계열의 OS 에서 작동하는 Java 어플리케이션의 단순한 개념으로 다음 기본 컴포넌트로 구성됩니다.(<code class="highlighter-rouge">Example 8</code>)</p>

<ul>
  <li>The hardware and operating system the application runs on</li>
  <li>The JVM (or container) the application runs in</li>
  <li>The application code itself</li>
  <li>Any external systems the application calls</li>
  <li>The incoming request traffic that is hitting the application</li>
</ul>

<blockquote>
  <p>Example 8 - Simple system model</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74581910-83cdae80-4ff8-11ea-9988-849633877ff3.png" alt="image" /></p>

<p>이들 중 누구라도 성능 문제를 일으킬 수 있습니다.</p>

<h2 id="basic-detection-strategies">Basic Detection Strategies</h2>

<p>어플리케이션이 잘 작동하는 건 CPU 사용량, 메모리, 네트워크, I/O 대역폭 등 시스템 리소스를 효율적으로 잘 이용하고 있다는 뜻입니다.</p>

<p>성능 진단의 첫 단추는 어느 리소스가 한계에 다다랐는지 밝히는 일입니다. 부족한 리소스가 뭔지 몰라 성능 지표를 제대로 튜닝할 수 없습니다.</p>

<p>하지만 OS 자체가 시스템을 가장 지치게 하는 원인이 되어서도 곤란합니다. OS 는 유저 프로세스 대신 리소스를 관리하는것이지, 자기 자신이 리소스를 소모하는게 아닙니다.</p>

<h3 id="utilizing-the-cpu">Utilizing the CPU</h3>

<p>CPU 사용률은 어플리케이션 성능을 나타내는 핵심 지표입니다. CPU 사이클은 어플리케이션이 가장 갈증을 느끼는 리소스라서 CPU 의 효율적 사용은 성능 향상의 지름길입니다. 또 부하가 집중되는 도중에는 사용률이 가능한 한 100 % 에 가까워야합니다.</p>

<blockquote>
  <p>어플리케이션 성능을 분석할 때는 시스템에 충분한 부하를 가해야 합니다.</p>
</blockquote>

<p>UNIX 계열 OS 명령줄에 툴 명령어를 실행하면 각각 현재 가상메모리 및 I/O 서브시스템 상태에 관한 유용한 데이터를 신속히 제공합니다. 물론 전체 호스트 수치만 나오지만 더 자세히 진단하기 전에 이 정도면 충분합니다. 아래는 <code class="highlighter-rouge">vmstat</code> 사용법입니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>vmstat 1
 r  b swpd  free    buff  cache   si   so  bi  bo   <span class="k">in   </span>cs us sy  <span class="nb">id </span>wa st
 2  0   0 759860 248412 2572248    0    0   0  80   63  127  8  0  92  0  0
 2  0   0 759002 248412 2572248    0    0   0   0   55  103 12  0  88  0  0
 1  0   0 758854 248412 2572248    0    0   0  80   57  116  5  1  94  0  0
 3  0   0 758604 248412 2572248    0    0   0  14   65  142 10  0  90  0  0
 2  0   0 758932 248412 2572248    0    0   0  96   52  100  8  0  92  0  0
 2  0   0 759860 248412 2572248    0    0   0   0   60  112  3  0  97  0  0
</code></pre></div></div>

<p><code class="highlighter-rouge">vmstat 1</code> 은 스냅샷을 찍는게 아니라 1초마다 한 번씩 찍어 다음 줄에 결과를 표시합니다.</p>

<p>섹션별로 살펴보겠습니다.</p>

<ul>
  <li>proc
    <ul>
      <li>실행 가능한(r) 프로세스 개수</li>
      <li>블로킹된(b) 프로세스 개수</li>
    </ul>
  </li>
  <li>memory
    <ul>
      <li>스왑 메모리(swpd) 표시</li>
      <li>미사용 메모리(free) 표시</li>
      <li>버퍼로 사용한 메모리(buff) 표시</li>
      <li>캐시로 사용한 메모리(cache) 표시</li>
    </ul>
  </li>
  <li>swap
    <ul>
      <li>디스크로 교체되어 들어간(스왑-인) 메모리(si) 정보</li>
      <li>디스크에서 교체되어 빠져나온(스왑-아웃) 메모리(so) wjdqh</li>
    </ul>
  </li>
  <li>io
    <ul>
      <li>블록-인(bi) 개수</li>
      <li>블록-아웃(bo) 개수</li>
      <li>각각 512바이트 블록 개수</li>
    </ul>
  </li>
  <li>system
    <ul>
      <li>인커럽트(in) 횟수</li>
      <li>초당 컨텍스트 교환(cs) 횟수</li>
    </ul>
  </li>
  <li>cpu
    <ul>
      <li>CPU 사용률(%) 로 표시</li>
      <li>유저 시간(us)</li>
      <li>커널 시간(sy)</li>
      <li>유휴 시간(id),</li>
      <li>대기 시간(wa)</li>
      <li>도둑맞은 시간(st)</li>
    </ul>
  </li>
</ul>

<p>튜닝이 잘 된 프로그램은 리소스를 최대한 활용합니다. 계산을 많이 하는 워크로드는 유저 공간의 CPU 사용률을 100 % 에 가깝게 유지하는게 목표입니다.</p>

<p>대다수 OS 에서 <code class="highlighter-rouge">vmstat</code> 은 컨텍스트 교환 발생 횟수를 나타내므로 <code class="highlighter-rouge">vmstat 1</code> 명령을 실행하면 컨텍스트 교환의 실시간 영향도를 지켜볼 수 있습니다. 유저 공간에서 CPU 사용률이 100 % 근처도 못 갔는데 어떤 프로세스에서 컨텍스트 교환 비율이 높게 나타나면 I/O 에서 블로킹이 일어났거나 <strong>스레드 락 경합(Thread Lock Contetntion)</strong> 상황이 벌어졌을 공산이 큽니다.</p>

<p><code class="highlighter-rouge">vmstat</code> 출력 결과만 봐서는 여러가지 경우의 수를 분간하기 어렵습니다. I/O 문제를 감지하기엔 좋지만, 스레드 락 경합을 실시간 감지하려면 실행 프로세스의 상태를 보여주는 툴이 필요합니다. 그와 더불어 스택을 샘플링해서 블로킹 코드를 보여주는 통계 스레드 프로파일러 툴도 많이 사용합니다.</p>

<h3 id="garbage-collection">Garbage Collection</h3>

<p>핫스팟 JVM 은 시작 시 메모리를 유저 공간에 할당 / 관리합니다. 그래서 메모리를 할당하느라 시스템 콜을 할 필요가 없습니다. 즉, 가비지 수집을 하려고 커널 교환을 할 일이 없습니다.</p>

<p>따라서 어떤 시스템에 CPU 사용률이 높게 나타나면, GC 의 문제가 아닙니다. GC 자체는 유저 공간의 CPU 사이클을 소비하되 커널 공간의 사용률에는 영향을 미치지 않는 활동이기 때문입니다. 반면, 어떤 JVM 프로세스가 유저 공간에서 CPU 를 100 % 가깝게 사용한다면 GC 를 의심해야합니다.</p>

<p>JVM 에서 GC 로깅은 거의 공짜입니다. 전체 비용을 최대한 정밀하게 산정해도 주변의 랜덤한 노이즈와 확실히 구분하기 어렵습니다. GC 로깅은 분석용 데이터의 원천으로서 가치가 높기 때문에 JVM 프로세스는 예외 없이, 특히 운영 환경에서는 GC 로그를 남겨야 합니다.</p>

<h3 id="io">I/O</h3>

<p>파일 I/O 는 전체 시스템 성능에 암적인 존재입니다. I/O 는 다른 OS 파트처럼 분명하게 추상화되어 있지 않기 때문입니다.</p>

<p>가령, 메모리 분야는 가상 메모리라는 격리 장치가 있지만, I/O 는 추상화할 장치가 없습니다.</p>

<p>Java 프로그램은 대부분 단순한 I/O 만 처리하며 I/O 서브시스템을 심하게 가동하는 어플리케이션 클래스도 비교적 적은편입니다.</p>

<p>성능 분석자 / 엔지니어는 어플리케이션에서 I/O 가 어떻게 일어나는지 인지하는 것만으로도 충분합니다. 특히 호스트당 I/O 가 집중되는 어플리케이션이 하나만 있을 경우, <code class="highlighter-rouge">iostat</code> 같은 툴이 제공되는 기본 카운터(block-in, block-out) 기능만 있어도 기초 진단용으로 활용하기에 좋습니다.</p>

<h4 id="kernel-bypass-io">KERNEL BYPASS I/O</h4>

<p>커널을 이용해 데이터를 복사해 유저 공간에 넣는 작업이 상당히 비싼 고성능 어플리케이션이 있습니다. 그래서 커널 대신 직접 네트워크 카드에서 유저가 접근 가능한 영역으로 데이터를 매핑하는 전용 HW / SW 를 사용합니다. 이렇게 하면 커널 공간과 유저 공간 사이를 넘나드는 행위 및 <em>이중 복사</em> 를 막을 수 있습니다.(<code class="highlighter-rouge">Example 9</code>)</p>

<blockquote>
  <p>Example 9 - Kernel bypass I/O</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74582189-16238180-4ffc-11ea-8629-065679bf0f7a.png" alt="image" /></p>

<h3 id="mechanical-sympathy">Mechanical Sympathy</h3>

<p>기계 공감은 성능을 조금이라도 내야하는 상황에서 하드웨어를 폭넓게 이해하고 공감할 수 있는 능력이 무엇보다 중요하다는 생각입니다.</p>

<p>캐시 라인 동작으로 예를 들어보겠습니다.</p>

<p>캐시 라인을 쓰면 메모리 블록을 미리 가져올 수 있지만, 멀티스레드 환경에서 두 스레드가 동일한 캐시 라인에 있는 변수를 읽거나 쓰려고 하면 문제가 됩니다.</p>

<p>두 스레드가 동일한 캐시 라인을 수정하려 하면 경합이 발생합니다. 첫 번째 스레드가 두 번째 스레드에 있는 캐시 라인을 무효화하면 메모리에서 다시 읽어야 합니다. 두 번째 스레드가 작업을 마치면 마찬가지로 첫 번째 스레드의 캐시 라인을 무효화합니다. 이렇게 주거니 받거니 하면서 <strong>잘못된 공유(False Sharing)</strong> 을 하고 결국 성능 하락으로 이어집니다.</p>

<p>Java 객체는 필드 배치가 고정돼 있지 않기 때문에 캐시 라인을 공유한 변수를 쉽게 찾을 수 있습니다. 따라서 변수 주변에 Padding 을 넣어 강제로 다른 캐시 라인으로 보내는 것도 한 가지 방법입니다.</p>

<h2 id="virtualization">Virtualization</h2>

<p>가상화는 다양한 종류가 있지만 이미 실행 중인 다른 OS 위에 OS 사본을 하나의 프로세스로 실행 시키는 모양이 보통입니다.(<code class="highlighter-rouge">Example 10</code>) 가상화 환경이 OS 안에서 일개 프로세스로 작동하는것 입니다.</p>

<blockquote>
  <p>Example 10 - Virtualization of operating systems</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74582189-16238180-4ffc-11ea-8629-065679bf0f7a.png" alt="image" /></p>

<p>가상화 특징은 다음 3가지로 요약 가능합니다.</p>

<ul>
  <li>가상화 OS 에서 실행하는 프로그램은 베어메탈에서 실행할 떄와 동일하게 작동해야 한다.</li>
  <li>Hypervisor 는 모든 하드웨어 리소스 액세스를 조정해야 합니다.</li>
  <li>가상화 오버헤드는 가급적 작아야 하며 실행 시간의 상당 부분을 차지해선 안된다.</li>
</ul>

<p>비가상화 시스템에서 OS 커널은프 Priviliged 모드로 작동하므로 하드웨어를 직접 제어할 수 있지만, 가상화 시스템에서는 게스트 OS 가 하드웨어에 직접 액세스 할 수 없습니다.</p>

<p>따라서 대개 Priviliged 명령어를 <strong>Unpriviliged</strong> 명령어로 고쳐씁니다. 또한, 컨텍스트 교환이 발생하는 동안 지나친 캐시플러시가 일어나지 않도록 일부 OS 커널의 자료 구조는 Shadow 해야합니다.</p>

<p>요즘 인텔 호환 CPU 는 가상화 OS 성능을 높이는 하드웨어 기능이 탑재된 경우도 있지만, 설령 하드웨어가 받쳐준다 해도 가상환경 내에서 프로그램을 실행하는 것 자체가 성능 분석 및 튜닝을 한층 더 복잡하게 만듭니다.</p>

<h2 id="the-jvm-and-the-operating-system">The JVM and the Operating System</h2>

<p>JVM 은 Java 코드에 Common Interface 를 제공하여 OS 에 독립적인 휴대용 실행 환경을 제공합니다. 하지만 스레드 스케줄링 같은 기본적인 서비스조차 하부 OS 에 반드시 액세스 해야합니다.</p>

<p>이런 기능은 <code class="highlighter-rouge">native</code> 키워드를 ㅂㅌ인 네이티브 메소드로 구현합니다. 네이티브 메소드는 C 언어로 작성하지만, Java 메소드처럼 액세스할 수 있습니다. 이 작업을 대행하는 공용 인터페이스를 <strong>Java Native Interface, JNI</strong> 라 합니다. 예를 들어, <code class="highlighter-rouge">java.lang.Object</code> 클래스에는 다음과 같이 Non-Private 네이티브 메서드가 선언되어 있습니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">getClass</span><span class="o">();</span>
<span class="kd">public</span> <span class="kd">native</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">();</span>
<span class="kd">protected</span> <span class="kd">native</span> <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">CloneNotSupportedException</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">notify</span><span class="o">();</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">notifyAll</span><span class="o">();</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">wait</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">;</span>
</code></pre></div></div>

<p>이들 메서드는 비교적 저수준의 플랫폼 관심사를 처리합니다. 간단한 시스템 시간을 조회하는 쉬운 예를 들어보겠습니다.</p>

<p><code class="highlighter-rouge">os::javaTimeMillis()</code> 함수는 Java 정적 메소드 <code class="highlighter-rouge">System.currentTimeMillis()</code> 에 구현된 로직을 처리합니다. 실제 코드는 C++ 로 작성됐지만 Java 서 C 코드 Bridge 를 통해 액세스할 수 있습니다. 핫스팟에선 어떻게 호출될지 알아보겠습니다.</p>

<p>네이티브 메소드 <code class="highlighter-rouge">System.currentTimeMillis()</code> 는 <code class="highlighter-rouge">JVM_CurrentTimeMillis()</code> 라는 JVM 엔트리 포인트 메소드에 매핑됩니다(<code class="highlighter-rouge">Example 11</code>). <em>.java/lang/System.c</em> 파일에 포함된 JNI <code class="highlighter-rouge">Java_java_lang_System_registerNatives()</code> 에 이러한 매핑 관계가 설정돼 있습니다.</p>

<blockquote>
  <p>Example 11 - The HotSpot calling stack</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/44635266/74582190-16238180-4ffc-11ea-97f4-ed76c5eb3707.png" alt="image" /></p>

<p><code class="highlighter-rouge">JVM_CurrentTimeMillis()</code> 는 VM 진입점에 해당하는 메소드를 호출합니다. 모양은 C 함수이지만 C 호출 관례에 따라 Export 된 C++ 함수입니다. 결국 OpenJDK 매크로 2개로 감싼 os::javaTimeMillis() 를 호출하는 구조입니다.</p>

<p>이 메소드는 os 이름공간에 정의되어 있고 OS 에 의존합니다. OpenJDK 코드베이스를 뒤져보면 OS 별 서브디렉터리 어딘가에 소스코드가 있습니다.</p>

<h2 id="summary">Summary</h2>
:ET