---
title : Ethereum Cryptography
tags :
- Cryptography
- Ethereum
- BlockChain
---

*이 포스트는 [Mastering Ethereum](https://github.com/ethereumbook/ethereumbook)를 바탕으로 작성하였습니다.*

이더리움의 기반 기술중 하나는 **암호학(Cryptography)** 입니다. 암호학은 데이터 지식을 증명하거나 진위성을 증명하는데 사용할 수 있습니다.

암호화 증명은 이더리움 플랫폼의 작동을 위한 중요한 수학도구이며, 이더리움 어플리케이션에 광범위하게 사용이 됩니다.

## Keys and Addresses

이더리움은 **외부 소유 계정(Externally Owned Account, EOA)** 와 **컨트랙트(contract)** 라는 두가지 계정을 가지고 있습니다. 디지털 **개인키(private key)**, **이더리움 주소(Ethereum address)**, **디지털 서명(Digital Signature)** 을 통해 외부 소유 계정의 이더 소유권을 확립합니다. 개인 키는 모든 사용자와 이더리움 간 상호작용의 핵심입니다. 계정 주소는 개인키에서 직접 파생이되며, 개인키는 계정이라고 불리는 단일 이더리움 주소를 고유하게 정해줍니다.

이더리움 시스템은 개인키를 이더리움에 전송하거나 저장하는 방식으로 직접 사용하지 않습니다. 개인키는 항상 비공개로 유지되어야 하며 이더리움 체인에 저장되어서도 안됩니다. 계정 주소와 디지털 서명만 시스템에 전송되고 저장됩니다.

개인키를 사용하여 생성된 디지털 서명을 통해 자금의 접근과 통제가 이루어집니다. 이더리움 트랜잭션은 유효한 디지털 서명이 블록체인에 있어야 합니다. 왜냐하면 개인키의 사본을 누군가 가지게되면 해당 계정과 이더를 제어할 수 있기 때문입니다. 사용자가 자신의 개인키를 안전하게 유지한다면, 이더리움 트랜잭션의 디지털 서명은 개인키의 소유권을 증명하기에 자금의 실제 소유자임도 증명하게 됩니다.

이더리움에서 똑같이 사용하는 암호화 시스템에서는 개인키와 공개키로 구성된 쌍으로 제공을 합니다. 개인키 자체는 이더리움 사용자에게 보여주지 않으며, 대부분 암호화된 형태로 파일로 저장하고 이더리움 지갑 SW 관리한다.

## Public Key Cryptography and Cryptocurrency

공개키 암호화는 정보보안의 핵심입니다. 공개키 암호화는 고유한 키를 사용하여 정보를 보호합니다. 이 키는 **inverse(수학의 역)** 를 계산하기 어렵다는 수학 함수를 바탕으로 합니다. 이 함수를 바탕으로 디지털 비밀과 위조 불가능한 디지털 서명을 만들 수 있게 합니다.

예를 들어, 2개의 큰 소수를 곱하는 것은 간단합니다. 하지만 8,0818,009 라는 숫자를 제시하고 이것이 두 소수의 곱의 결과라 가정해보면 어떤 소수의 곱인지 찾는것이 소수를 곱하는 것보다 어렵습니다.

이런 수학 함수 중 일부는 비밀 정보를 알고 있을때 쉽게 계산할 수 있습니다. 앞의 예에서 소수 하나가 2,003 이라고 하면 나머지 소수를 쉽게 찾을 수 있습니다. 이런 함수는 역산하기 위한 단축키로 사용할 수 있는 비밀정보가 없으면 거꾸로 계산하기 어렵기 때문에 **트랩 도어 함수** 라고도 합니다. 아래 그림은 트랩도어 함수를 간단한 그림으로 그린 자료입니다.

> Example 1

![1018px-Trapdoor_permutation svg](https://user-images.githubusercontent.com/44635266/70844468-d10c9300-1e84-11ea-8642-d3b1c10606f2.png)

암호학에 유용한 수학 함수의 좀 더 발전된 범주는 타원 곡선의 산술 연산을 바탕으로 합니다. 타원 곡선 산술에서 소수로 나눈 나머지를 곲하는 것은 간단하지만, 나눗셈은 사실상 불가능 합니다. 이것을 **이산 로그 문제(discrete logarithm problem)** 이라고 하며, 현재 알려진 트랩 도어는 없습니다. **타원 곡선 암호화(elliptic curve cryptography)** 는 최신 컴퓨터 시스템에서 광범위하게 활용되며, 이더리움에서 개인키와 디지털 서명을 사용하는 기초가 됩니다.

> 암호학 위키피디아 자료

* [Cryptography](https://en.wikipedia.org/wiki/Cryptography)
* [Trapdoor function](https://en.wikipedia.org/wiki/Trapdoor_function)
* [Prime factorization](https://en.wikipedia.org/wiki/Integer_factorization)
* [Discrete logarithm](https://en.wikipedia.org/wiki/Discrete_logarithm)
* [Elliptic curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography)

이더리움에서 개인키는 계정에서 자금을 지출하기 위해 트랜잭션에 서명해야 하는 **디지털 서명(Digital Signature)**  을 만드는데 필요한 고유한 정보의 접근을 제어한다. 디지털 서명은 소유자 또는 컨트랙트 사용자를 인증하는데도 사용한다.


## Private Keys

개인키는 단순히 무작위로 선택한 숫자입니다. 개인키의 소유권과 제어는 해당 주소를 승인하는 컨트랙트에 대한 접근뿐만 아니라 해당 이더리움 주소와 관련된 모든 자금에 대한 사용자 제어의 근원입니다. 개인키는 트랜잭션에 쓰이는 자금의 소유권을 증명함으로써 이더를 소비하는데 필요한 서명을 만드는데 사용합니다.

개인키는 항상 비밀로 유지해야합니다. 왜냐하면 개인키를 제3자에게 제공하는 공개하는 행위는 개인키로 확보한 이더와 컨트랙트에 대한 제어 권한을 제3자에게 주는것과 마찬가지이기 때문입니다.

### Generating a Private Key from a Random Number

이더리움에서 키를 생성할 때는 $1$ 부터 $2^{256}$ 사이의 숫자를 선택하며 이더리움에서 사용하는 타원 곡선의 순서로 정의합니다. 비공개 키를 생성하기 위해 256 비트 숫자를 무작위로 추출하여 유효한 범위 내에 있는지 확인합니다. 그리고 이것을 `Keccak-256` 또는 `SHA-256` 같은 256비트 해시 알고리즘에 대입하며 이루어지고 256비트 수를 생성하게 됩니다. 결과가 유효한 범위 내에 있으면 적절한 개인키가 되며, 그렇지 않으면 임의의 숫자로 다시 시도합니다.

> $2^{256}$ 은 약 $10^{77}$ 숫자입니다. 우주가 $10^{80}$ 원자를 포함하는것으로 추정하므로 엄청나게 큰 숫자입니다. 따라서 누군가가 이 개인키를 추측하거나 같은 값을 선택하는 방법은 현재 없습니다.

아래는 임의로 생성한 16진수 형식의 개인키 입니다.

```
f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
```

## Public Keys

이더리움 공개키는 타원 곡선에 있는 **점(point)** 로 타원 곡선 방정식을 만족하는 x 와 y 좌표의 집합을 의미합니다. 이더리움 공개키는 2개의 숫자가 함께 결합되어 있습니다. 이 숫자는 개인키로부터 **'단방향으로만'** 계산할 수 있습니다. 즉, 개인키가 있는 경우 계산하기 쉽지만, 공개키에서 개인키를 계산할 수는 없습니다.

공개키는 비가역적인 타원 곡선 곱셈을 사용하여 개인키로부터 계산이 됩니다. 

$$K = k * G$$

- k 는 개인키 
- G 는 **생성자 점(Generator point)** 라고 불리는 상수점 
- K 는 결과로 나오는 공개키
- `*` 는 특수 타원 곡선 '곱하기' 연산자 

타원 곡선 곱셈은 일반적인 곱셈과 같지 않습니다. 설명하자면, 타원 곡선에 대한 산술 연산은 정규 정수 연산과 다릅니다. 점(G) 에 정수(k) 를 곱하여 점(K)을 생성할 수 있습니다. 그러나 **나눗셈(division)** 연산이 존재하지 않으므로 K 를 G 로 나누어 k 를 계산할 수 없습니다.

### Elliptic Curve Cryptography Explained

타원 곡선 암호화는 타원 곡선의 점에 더하기와 곱셈으로 표현되는 이산 대수 문제를 바탕으로 한 비대칭 또는 공개키 암호화 유형입니다. 아래 `Example 2` 은 타원 곡선의 한 예입니다.

> Example 2 - A visualization of an elliptic curve

![image](https://user-images.githubusercontent.com/44635266/70844926-d91c0100-1e8b-11ea-838a-cd78bb8b7c58.png)

이더리움은 미국 표준기술연구소에서 제정한 `secp256k1` 라는 표준에 정의한 대로 특정 타원 곡선과 수학 상수 집합을 사용합니다. 표준ㅇ 곡선은 타원 곡선을 생성하는 다음 함수로 정의합니다.

$$y^2 = (x^3+7)\;over\;\mathbb{F}_p\\y^2\;mod\;p = (x^3 + 7)\;mod\;p$$

$mod\;p$ 는 이 곡선이 $\mathbb{F_p}$ 라고 쓰인 소수 차수 p 의 유한체상에 있음을 나타냅니다. 여기서 p의 값은 아래와 같이 매우 큰 소수입니다.

$$p = 2^{256} - 2^{32} - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1$$

이 곡선은 실수 대신에 소수 위수의 유한체상에 정의 했기 때문에 2차원으로 흩어져 있는 점들의 패턴처럼 보이므로 시각화하기 어렵스빈다. 그러나 수학은 실수에 대한 타원 곡선 수학과 동일합니다.  `Example 3` 에서 보여주는 좌표 위의 점 패턴은 훨씬 작은 유한체인 소수 위수 17의 타원 곡선과 동일합니다. `secp256k1` 이더리움 타원 곡선은 더 크고 복잡한 점 패턴입니다.

> Example 3 - Elliptic curve cryptography: visualizing an elliptic curve over F(p), with p=17

![image](https://user-images.githubusercontent.com/44635266/70844927-d9b49780-1e8b-11ea-8821-91d2be303ddd.png)

예를들어 `secp256k1` 곡선상의 점인 좌표 (x, y)를 가지는 점 Q 입니다.

```
Q =
(49790390825249384486033144355916864607616083520101638681403973749255924539515,
59574132161899900045862086493921015780032175291755807399284007721050341297360)
```

아래 예제는 python 을 활용하여 직접 확인하는 방법 입니다. x, y 가 실제로 타원 곡선상의 좌표라면, 그들은 방정식을 만족하고 결과는 0이 나오게 됩니다.

```shell
Python 3.7.5 (default, Nov  1 2019, 02:16:23)
[Clang 11.0.0 (clang-1100.0.33.8)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
>>> x = 49790390825249384486033144355916864607616083520101638681403973749255924539515
>>> y = 59574132161899900045862086493921015780032175291755807399284007721050341297360
>>> (x ** 3 + 7 - y**2) % p
0
```

### Elliptic Curve Arithmetic Operations

타원 곡선 수학 더하기 연산자를 정의할 수 있습니다. 이 연산자는 숫자 선을 따라 점프하는 대신 곡선의 다른 점으로 점프를 하게 됩니다.

타원 곡선에 두 점 $P_1$ 과 $P_2$ 가 주어지면 세 번째 점 $P_3 = P_1 + P_2$ 가 타원 곡선 위에 있도록 타원 곡선 덧셈을 정의합니다.

기하학적으로 이 세 번재 점 $P_3$ 은 $P_1$ 과 $P_2$ 사이의 선을 그려 계산합니다. 이 선은 정확하게 타원 곡선과 교차합니다. 이 점을 $P_3` = (x, y)$ 라고 부르겠습니다. 이어서 x 축에 반사하여 $P_3 = (x, -y)$ 를 구합니다.

$P_1$ 과 $P_2$ 가 같은 점이라면 $P_1$ 과 $P_2$ 사이의 선은 이 점 $P_1$ 곡선에 대한 접선으로 확장되어집니다. 이 접선은 새로운 점에서 곡선과 교차합니다. 미적분 기법을 사용하여 접선의 기울기를 결정할 수 있습니다. 이 기술은 2차원 정수 좌표상에 있는 곡선 위의 점들에도 적용할 수 있습니다. 아래 `Example 4`를 통해 쉽게 이해해보겠습니다.

> Example 4 - A visualization of an elliptic curve

![image](https://user-images.githubusercontent.com/44635266/70890343-2a60f780-2028-11ea-868d-e4c5af6e98fc.gif)


당신이 만약 두 점(A, B) 을 가지고 있고 최종점에 도착하기 위해 initial point에 임의의 n번을 dot 시켜준다면, 첫번째 점과 마지막 점만 가지고서는 n을 찾는것이 어렵습니다.

이 타원곡선을 이용하지 않고서는 같은 지점에 때 가지 몇번이나 x 축에 반사한지 알아낼 수 없습니다. 즉, do는 쉽고 undo는 어렵습니다. 좋은 트랩도어 함수의 표본입니다.

### Generating a Public Key

무작위로 생성한 숫자 k 형태의 개인키로 시작하여 생성자 점 G 라고 하는 곡선의 미리 결정된 점에 개인키를 곱하여 곡선상의 다른 점, 즉 대응하는 공개키 K 를 생성합니다.

$$K = k * G$$

생성한 점은 `secp256k1` 표준의 일부로 지정되어 모든 구현에서 동일하며, 해당 곡선에서 파생된 모든 키는 동일한 점 G 를 사용합니다. 생성자 점은 모든 이더리움 사용자에 대해 항상 동일하기 때문에, G 와 개인키 k 를 곱한 결과는 항상 K 로 동일합니다. k 와 K 관계는 고정되어 있지만, k 에서 K 까지의 한방향으로만 계산할 수 있습니다. 이런 이유로 이더리움 주소를 모든 사람과 공유 할 수 있으며, 사용자의 개인키는 공개하지 않습니다.

이제 이 계산을 적용하여 이전에 개인키로 특정 개인와 공개키를 찾아보겠습니다.

```
K = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315 * G
```

타원 곡선 곱셈을 사용하여 K 를 계산하는데 도움이 됩니다. 그 결과 공개키는 다음과 같은 점으로 정의합니다.

```
K = (x, y)
```

```
x = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b
y = 83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
```

이더리움에서 16진수 문자 130개의 Serialization 으로 표시되는 공개키를 볼 수 있습니다.

SEC 표준에서 제안한 형식에서는 타원 곡선의 점을 식별하는데 사용할 수 있는 4 가지  접두어를 정의합니다.

|Prefix|Meaning|Length(bytes counting prefix)|
|:--:|:--:|:--:|
|0x00|Point at infinity|1|
|0x04|Uncompressed point|65|
|0x02|Compressed point with even y|33|
|0x03|Compressed point with odd y|33|

이더리움은 압축되지 않은 공개키만을 사용합니다. 따라서 관련된 유일한 접두어는 `04` 입니다. Serialization 은 공개키와 x와 y 좌표를 연결합니다.

```
04 + x-coordinate (32 bytes/64 hex) + y-coordinate (32 bytes/64 hex)
```

따라서 이전에 계산한 공개키는 다음과 같이 Serialization 됩니다.

```
046e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0 \
c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
```

## Cryptographic Hash Functions

암호화 **해시 함수(hash function)** 는 이더리움 전반에 걸쳐 사용됩니다. 이더리움 공개키를 주소로 변환하는 작업에서 해시 함수가 사용이 됩니다. 또한, 데이터 확인에 도움이 되는 **디지털 지문(Digital Fingerprints)** 을 만드는데 사용할 수 있다.

해시 함수의 정의는 *임의 크기의 데이터를 고정된 크기의 데이터로 매핑하는 데 사용할 수 있는 모든 함수* 라 한다. 해시 함수에 대한 입력을 **사전 이미지(pre-image), 메세지(message)** 또는 단순히 **입력 데이터(input data)** 라고 합니다. 그 결과를 **해시(hash)** 라고 한다. **암호화 해시 함수(cryptographic hash function)** 는 이더리움 같은 플랫폼을 보호하는 데 유용한 특정 속성은 갖는 하위 범주다.

암호 해시 함수는 임의 크기의 비트열로 매핑하는 **단방향(one-way)** 해시 함수입니다. 단방향 특성은 결과값 해시만 알고 있을 때 입력 데이터를 다시 작성하는 것이 계산적으로 불가능함을 의미합니다. 가능한 입력을 결정하는 유일한 방법은 각 후보에 일치하는 결과가 이쓴ㄴ지 확인하며 무차별 대입 검색을 수행하는 것입니다.

해시함수는 다대일 함수 입니다. 동일환 결과에 해시 처리한 두 입력 데이터 집합을 찾는 것을 **해시 충돌(hash collision)** 찾기라고 합니다. 간단히 말해서, 해시 함수가 좋을수록 해시 충돌이 덜 발생하게 됩니다.

아래 암호화 해시 함수의 주요 속성을 알아보겠습니다.

* **Determinism**
  * 주어진 입력 메세지는 항상 동일한 해시 결과를 생성한다.
* **Verifiability**
  * 메세지의 해시 계산은 효율적이다. 
* **Noncorrelation**
  * 메세지에 대한 작은 변화는 해시 출력을 광범위하게 변경해야 해서 원본 메세지의 해시의 상관 관계가 없다.
* **Irreversibility**
  * 해시로부터 메세지를 계산하는 것은 불가능하다.
  * 모든 가능한 메세지에 대한 무차별 검색과 같다.
* **Collision protection**
  * 같은 해시 결과를 생성하는 2개의 서로 다른 메세지를 계산하는것은 불가능하다.
  
해시 충돌에 대한 저항은 특히 이더리움에서 디지털 서명 위조를 피하기 위해 중요합니다.

암호화 해시 기능이 다음과 같은 다양한 보안 어플리케이션에 유용합니다.

* Data fingerprinting
* Message integrity (error detection)
* Proof of work
* Authentication (password hashing and key stretching)
* Pseudorandom number generators
* Message commitment (commit–reveal mechanisms)
* Unique identifiers

### Ethereum’s Cryptographic Hash Function: Keccak-256

이더리움은 많은 곳에서 Keccak-256 암호화 해시 함수를 사용합니다. Keccak-256 은 SHA-3 암호화 해시 함수 경쟁대회의 후보로 설계되어 우승한 알고리즘 입니다.

### Which Hash Function Am I Using?

두 소프트웨어 모두 SHA-3 이라면 사용중인 소프트웨어 라이브러리가 SHA-3 또는 Keccak-256 인지 어떻게 알 수 있을까요.

방법은 주어진 입력에 대해 예상되는 결과인 **테스트 벡터(text vector)** 를 사용하는 것이다. 해시 함수에 가장 일반적으로 사용되는 테스트는 **빈 입력(empty input)** 입니다. 빈 문자열을 입력으로 해시 함수를 실행하면 다음과 같은 결과가 나옵니다.

```
Keccak256("") =
  c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470

SHA3("") =
  a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a
```

이 간단한 테스트를 실행하여 어떤 라이브러리를 사용하는지 확인할 수 있습니다.

## Ethereum Addresses

이더리움 주소는 Keccak-256 단방향 해시 함수를 사용하는 공개키 또는 컨트랙트에서 파생한 **고유 식별자(unique identifier)** 입니다.

**개인키 k**

```
k = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
```

**공개키 K** (x 및 y 좌표가 연결되고 16진수로 표시)

```
K = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e...
```

**Keccak-256 을 이용하여 공개키의 해시를 계산**

```
Keccak256(K) = 2a5bc342ed616b5ba5732269001d3f1ef827552ae1114027bd3ecf1f086ba0f9
```

이더리움 주소인 마지막 20byte 만 유지한다.

```
001d3f1ef827552ae1114027bd3ecf1f086ba0f9
```

종종 이더리움 주소가 접두어 0x 로 표시되어 다음과 같이 16 진수로 인코딩된 것을 볼 수 있다.

```
0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
```

### Ethereum Address Formats

이더리움 주소는 16진수이며, 공개키 Keccak-256 해시의 마지막 20 byte 에서 파생한 식별자 입니다.

모든 클라이언트의 사용자 인터페이스에 내장된 체크섬을 포함하여 잘못 입력된 주소를 보호하도록 인코딩된 비트코인 주소와 달리 이더리움 주소는 체크섬이 없는 원시 16진수로 표시한다.

### Inter Exchange Client Address Protocol

**클라이언트 주소 상호교환 프로토콜** 은 국제 은행 계좌번호 인코딩과 부분적으로 호환되는 이더리움 주소 인코딩으로 이더리움 주소에 대한 다목적의 체크섬이 가능하고 상호운용 가능한 인코딩을 제공한다. ICAP 주소는 이더리움 이름 레지스트리에 등록한 이더리움 주소 또는 일반 이름을 인코딩할 수 있다.

IBAN 은 은행 계좌 번호를 식별하기 위한 국제 표준으로 중앙 집중적이고 엄격하게 규제되는 서비스다. ICAP 는 탈중앙화형이지만 이더리움 주소에 대해 호환 가능하다.

IBAN 은 국가 코드, 체크섬 및 은행 계좌 식별자를 포함하는 최대 34개의 영수자로 구성된 문자열로 구성한다.

ICAP 는 '이더리움' 을 나타내는 비표준 국가 코드 'XE' 를 도입한 후에 두 문자 체크섬과 계정 식별자의 세 가지 가능한 변형을 도입하여 동일한 구조를 사용한다.

* **Direct**
  * 이더리움 주소의 최하위 비트 155개를 나타내는 최대 30자의 영숫자로 구성된 빅엔디안 base36 정수
  * 이더리움 주소에서만 동작
  * 필드 길이와 체크섬 측면에서 IBAN 과 호환이가능
  * ex) XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD (33 characters long).
* **Basic**
  * Direct 와 동일하지만 길이는 31자다.
  * 이더리움 주소를 인코딩 할 수 있지만 IBAN 필드 유효성 검사와 호환되지 않는다.
  * ex) XE18CHDJBPLTBCJ03FE9O2NS0BPOJVQCU2P (35 characters long).
* **InDirect**
  * 레지스트리 공급자를 통해 이더리움 주소로 확인하는 식별자를 인코딩
  * **자산 식별자(asset identifier, ex: ETH)**, 이름 서비스 및 사람이 읽을 수 있는 9자 이름 으로 구성된 16개의 영수자를 사용
  * ex) XE##ETHXREGKITTYCATS (20 characters long) 
  * '##' 은 2개의 계산된 체크섬 문자로 대체된다.

helpeth 커맨드 라인 도구를 사용하여 ICAP 주소를 만들 수 있습니다.

```shell
$ helpeth keyDetails \
  -p 0xf8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315

Address: 0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
ICAP: XE60 HAMI CDXS V5QX VJA7 TJW4 7Q9C HWKJ D
Public key: 0x6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b...
```

예제 키의 ICAP 주소는 다음과 같다.

```
XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD
```

이더리움 주소는 0 byte 로 시작하기 때문에 IBAN 형식으로 유효한 Direct ICAP 인코딩 방법을 사용하여 인코딩 할 수 있다.

주소가 0 으로 시작하지 않으면 Basic 인코딩으로 인코딩한다. 길이는 35자이며 IBAN 은 유효하지 않다.

### Hex Encoding with Checksum in Capitalization (EIP-55)

ICAP 네임 서비스의 느린 배포 때문에 **이더리움 개선 제안(Ethereum Improvement Proposal 55, EIP-55)** 에서 표준을 제안 햇다. EIP-55 는 16진수 주소의 대소문자를 수정하여 이더리움 주소에 대한 이전 버전과 호환되는 체크섬을 제공합니다.

주소의 알파벳 대소문자를 수정함으로써 입력의 무결성을 보호하기 위해 사용할 수 있는 체크섬을 전달 할 수 있다. EIP-55 체크섬을 지원하지 않는 지갑은 주소에 대문자가 혼용된다는 사실을 무시하지만, 이를 지원하는 사용자는 주소를 확인하고 99.986% 의 정확도로 오류를 감지할 수 있다.

혼합 대문자 인코딩은 미묘하기 때문에 처음에는 인식하지 못할 수도 있다. 예제 주소는 다음과 같습니다.

```
0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
```

EIP-55 혼합 대문자 체크섬을 사용하면 다음과 같이 됩니다.

```
0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
```

16 진수 인코딩 알파벳의 일부 알파벳 문자는 대문자인 반면, 그 밖의 문자는 소문자다.

EIP-55 는 구현하기 쉽습니다. 소문자 16 진수 주소의 Keccak-256 해시를 사용합니다.

1. 0x 접두어 없이 소문자 주소를 해시 처리한다.

```
Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0f9") =
23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9695d9a19d8f673ca991deae1
```

2. 해시의 해당 16 진수가 0x8 이상인 경우 각 알파벳 문자를 대문자로 만들어라. 

```
Address: 001d3f1ef827552ae1114027bd3ecf1f086ba0f9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
```

위 주소에는 4번째 위치의 알파벳 문자 d 가 들어있다. 해시의 4번째 문자는 6보다 작아서 소문자로 남겨둡니다. 주소의 다음 알파벳 문자는 6번째 위치에 있는 문자는 f 다. 16 진수 해시의 6번째 문자는 c보다 크고 8이다. 따라서 주소에서 F를 대문자로 반환하는 식이다.

해시의 처음 20 byte 는 체크섬으로 사용한다. 주소에 20 byte 가 적절하게 대문자로 되어 있기 때문이다.

결과로 나온 혼합 대문자를 확인하고 대문자로 된 문자와 주소 해시에 해당하는 문자를 알 수 이는지 확인한다.

```
Address: 001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
```

### Detecting an error in an EIP-55 encoded address

주소 마지막 알파벳 F 를 E 로 잘못 읽었다고 가정하자.
```
original : 0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
error : 0x001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
```

주소의 유효성을 검사하고 소문자로 변환하여 체크섬 해시를 계산합니다.

```
Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0e9") =
5429b5d9460122fb4b11af9cb88b7bb76d8928862e0a57d46dd18dd8e08a6927
```

글자 하나만 변경되어도 해시값은 급격하게 변경이 된다. 이제 대문자를 확인해보면 모두 잘못되었다는것을 확인할 수 있습니다.

```
001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
5429b5d9460122fb4b11af9cb88b7bb76d892886...
```
