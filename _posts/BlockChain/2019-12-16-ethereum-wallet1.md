---
title : Ethereum Wallet -1-
tags :
- Deterministic Wallets
- Nondeterministic Wallets
- Wallet
- Ethereum
- BlockChain
---

*이 포스트는 [Mastering Ethereum](https://github.com/ethereumbook/ethereumbook)를 바탕으로 작성하였습니다.*

## Wallet

개발자의 시각으로는 지갑이란 단어는 사용자의 키를 보관하고 관리하기 위해 사용되는 시스템 입니다. 모든 지갑은 키 관리 구성요소를 갖추고 있습니다.

### Wallet Technology Overview

지갑을 설계할 때 가장 중요한 고려사항은 편의성과 프라이버시 사이에 균형을 맞추는 것이다. 가장 편리한 이더리움 지갑은 하나의 개인키와 주소를 가지고 이를 재사용해서 모든것을 처리하는 지갑이다.

이더리움 지갑은 이더나 토큰을 보유하는것이 아니라 키만 보유한다. 이더 혹은 다른 토큰은 이더리움 블록체인에 기록이 된다. 사용자는 지갑에 있는 키로 트랜잭션을 서명함으로써 네트워크에 있는 토큰을 제어하는것이다. 이러한 맥락에서 이더리움은 **키체인(keychain)** 입니다.

지갑은 두 가지 주요 형태가 있습니다. 지갑이 포함하는 키가 서로 관련이 있느냐와 없느냐 입니다.

첫 번째 유형은 각기 다른 무작위 수로부터 각각의 키를 무작위적으로 추출하는 **비결정적 지갑(nondeterministic wallet)** 이라고 한다. 이러한 형태의 지갑을 JBOK(Just a Bunch Of Keys) 지갑이라 한다.

두 번째 유형은 모든 키가 **시드(seed)** 라 하는 단일 마스터 키로부터 파생된 **결정적 지갑(deterministic wallet)** 입니다. 이러한 지갑 형태의 모든 키는 서로 관련이 있고 원래의 시드를 갖고 잇다면 다시 키를 파생시킬 수 있습니다.

결정적 지갑에는 여러 가지 **키 파생(key derivation)** 방식이 있는데, 가장 많이 사용하는 파생 방식은 HD 지갑(BIP-32/BIP-44) 같은 트리구조를 사용합니다.

안전한 결정적 지갑을 만들기 위해서 시드는 단어 목록으로 인코딩되어 불의의 사고에 대비할 수 있도록 적어두고 사용합니다. 이를 지갑의 **니모닉 코드 단어(mnemonic code words)** 라고 합니다. 물론, 누군가가 사용자의 니모닉 코드 단어를 손에 넣으면 지갑을 재생성하여 사용자의 이더와 스마트 컨트랙트에 접근할 수 있다.

## Nondeterministic (Random) Wallets

비결정적 지갑은 무작위로 추출된 단일 개인키를 저장했다. 이 지갑은 여러 측면에서 불편하기 때문에 대체되고 있다. 예를 들어, 이더리움을 사용하는 동안 프라이버시를 극대화한다는 차원에서 이더리움 주소의 재사용을 피하는것이 좋은 지침으로 간주가 됩니다. 즉, 자금을 받을 때마다 새로운 주소를 사용합니다.

이렇게 하려면 비결정적 지갑은 정기적으로 키 목록을 증가시켜야 하는데,이는 정기 적인 백업이 필요하다는 뜻이다. 만약 지갑을 백업하기 전에 데이터를 잃어 버리면 자금과 스마트 컨트랙트에 접근할 수 없게 됩니다.

비결정적 지갑은 'JIT(Just In Time)' 모두 새로운 주소를 위한 새로운 지갑 파일을 만들기 때문에 다루기 어렵습니다.

그럼에도 불구하고 많은 이더리움 클라이언트는 보안 강화를 위해 암호문으로 암호화된 단일 개인키가 들어있는, JSON 인코딩 파일인 **키 저장소** 파일을 사용한다. JSON 파일의 내용은 다음과 같다.

```
{
    "address": "001d3f1ef827552ae1114027bd3ecf1f086ba0f9",
    "crypto": {
        "cipher": "aes-128-ctr",
        "ciphertext":
            "233a9f4d236ed0c13394b504b6da5df02587c8bf1ad8946f6f2b58f055507ece",
        "cipherparams": {
            "iv": "d10c6ec5bae81b6cb9144de81037fa15"
        },
        "kdf": "scrypt",
        "kdfparams": {
            "dklen": 32,
            "n": 262144,
            "p": 1,
            "r": 8,
            "salt":
                "99d37a47c7c9429c66976f643f386a61b78b97f3246adca89abe4245d2788407"
        },
        "mac": "594c8df1c8ee0ded8255a50caf07e8c12061fd859f4b7c76ab704b17c957e842"
    },
    "id": "4fcb2ba4-ccdb-424f-89d5-26cce304bf9c",
    "version": 3
}
```

키 저장소 형식은 무차별(brute-force), 사전(dictionary) 및  레인보우 테이블(rainbow table) 공격을 대비해 암호 확장 알고리즘으로 알려진 **키 파생 함수(key derivation fuction, KDF)** 를 사용합니다.

개인키는 암호문에 의해 직접적으로 암호화 되지 않습니다. 대신, 암호문은 반복적으로 해싱됨으로써 강화됩낟. 해시 함수는 262,144 라운드로 반복되며, 키 저장소 JSON에서 파라미터 crypto.kdfparams.n 으로 확인할 수 있습니다. 공격자가 암호문을 무차별적으로 생성하려면 암호화를 시도할 대마다 262,144 해시 라운드를 적용해야 할것이며, 이는 공격 속도를 늦추어 암호문에 대한 공격을 불가능하게 합니다.

### Deterministic (Seeded) Wallets

단일 마스터 키 또는 단일 시드로부터 파생된 개인키를 포함합니다. 시드는 개인키를 만들기 위해 인덱스 번호나 체인코드 같은 데이터와 결합된 무작위로 추출된 번호 입니다.

결정적 지갑에서 시드는 모든 파생된 키를 복구할 수 있습니다. 그러므로 생성 시점에 단일 백업으로 지갑에 있는 모든 자금과 컨트랙트를 안전하게 보호할 수 있습니다. 시드는 지갑을 내보내거나(export) 가져오기(import) 에 활용되며 다른 지갑 간에 모든 키를 쉽게 이관할 수 있습니다.

이러한 구조로 인해 시드만 있으면 전체 지갑에 접근이 가능하기 때문에 시드의 보안이 최 우선 과제가 됩니다. 한편, 보안 노력을 단일 데이터에 집중할 수 있다는 것은 장점으로 볼 수 있습니다.

다음 포스트에서는 결정적 지갑 표준 HD 지갑에 대해서 알아보겠습니다.