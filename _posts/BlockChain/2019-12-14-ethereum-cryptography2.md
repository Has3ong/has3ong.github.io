---
title : Ethereum Cryptography -2-
use_math: true
tags :
- Elliptic Curve Cryptography
- Private Key
- Public Key
- Cryptography
- Ethereum
- BlockChain
---

*이 포스트는 [Mastering Ethereum](https://github.com/ethereumbook/ethereumbook)를 바탕으로 작성하였습니다.*

## Private Keys

개인키는 단순히 무작위로 선택한 숫자입니다. 개인키의 소유권과 제어는 해당 주소를 승인하는 컨트랙트에 대한 접근뿐만 아니라 해당 이더리움 주소와 관련된 모든 자금에 대한 사용자 제어의 근원입니다. 개인키는 트랜잭션에 쓰이는 자금의 소유권을 증명함으로써 이더를 소비하는데 필요한 서명을 만드는데 사용합니다.

개인키는 항상 비밀로 유지해야합니다. 왜냐하면 개인키를 제3자에게 제공하는 공개하는 행위는 개인키로 확보한 이더와 컨트랙트에 대한 제어 권한을 제3자에게 주는것과 마찬가지이기 때문입니다.

### Generating a Private Key from a Random Number

이더리움에서 키를 생성할 때는 $1$ 부터 $2^{256}$ 사이의 숫자를 선택하며 이더리움에서 사용하는 타원 곡선의 순서로 정의합니다. 비공개 키를 생성하기 위해 256 비트 숫자를 무작위로 추출하여 유효한 범위 내에 있는지 확인합니다. 그리고 이것을 `Keccak-256` 또는 `SHA-256` 같은 256비트 해시 알고리즘에 대입하며 이루어지고 256비트 수를 생성하게 됩니다. 결과가 유효한 범위 내에 있으면 적절한 개인키가 되며, 그렇지 않으면 임의의 숫자로 다시 시도합니다.

> $2^{256}$ 은 약 $10^{77}$ 숫자입니다. 우주가 $10^{80}$ 원자를 포함하는것으로 추정하므로 엄청나게 큰 숫자입니다. 따라서 누군가가 이 개인키를 추측하거나 같은 값을 선택하는 방법은 현재 없습니다.

아래는 임의로 생성한 16진수 형식의 개인키 입니다.

```
f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
```

## Public Keys

이더리움 공개키는 타원 곡선에 있는 **점(point)** 로 타원 곡선 방정식을 만족하는 x 와 y 좌표의 집합을 의미합니다. 이더리움 공개키는 2개의 숫자가 함께 결합되어 있습니다. 이 숫자는 개인키로부터 **'단방향으로만'** 계산할 수 있습니다. 즉, 개인키가 있는 경우 계산하기 쉽지만, 공개키에서 개인키를 계산할 수는 없습니다.

공개키는 비가역적인 타원 곡선 곱셈을 사용하여 개인키로부터 계산이 됩니다. 

$$K = k * G$$

- k 는 개인키 
- G 는 **생성자 점(Generator point)** 라고 불리는 상수점 
- K 는 결과로 나오는 공개키
- `*` 는 특수 타원 곡선 '곱하기' 연산자 

타원 곡선 곱셈은 일반적인 곱셈과 같지 않습니다. 설명하자면, 타원 곡선에 대한 산술 연산은 정규 정수 연산과 다릅니다. 점(G) 에 정수(k) 를 곱하여 점(K)을 생성할 수 있습니다. 그러나 **나눗셈(division)** 연산이 존재하지 않으므로 K 를 G 로 나누어 k 를 계산할 수 없습니다.

### Elliptic Curve Cryptography Explained

타원 곡선 암호화는 타원 곡선의 점에 더하기와 곱셈으로 표현되는 이산 대수 문제를 바탕으로 한 비대칭 또는 공개키 암호화 유형입니다. 아래 `Example 1` 은 타원 곡선의 한 예입니다.

> Example 1 - A visualization of an elliptic curve

![image](https://user-images.githubusercontent.com/44635266/70844926-d91c0100-1e8b-11ea-838a-cd78bb8b7c58.png)

이더리움은 미국 표준기술연구소에서 제정한 `secp256k1` 라는 표준에 정의한 대로 특정 타원 곡선과 수학 상수 집합을 사용합니다. 표준ㅇ 곡선은 타원 곡선을 생성하는 다음 함수로 정의합니다.

$$y^2 = (x^3+7)\;over\;\mathbb{F}_p\\y^2\;mod\;p = (x^3 + 7)\;mod\;p$$

$mod\;p$ 는 이 곡선이 $\mathbb{F_p}$ 라고 쓰인 소수 차수 p 의 유한체상에 있음을 나타냅니다. 여기서 p의 값은 아래와 같이 매우 큰 소수입니다.

$$p = 2^{256} - 2^{32} - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1$$

이 곡선은 실수 대신에 소수 위수의 유한체상에 정의 했기 때문에 2차원으로 흩어져 있는 점들의 패턴처럼 보이므로 시각화하기 어렵스빈다. 그러나 수학은 실수에 대한 타원 곡선 수학과 동일합니다.  `Example 2` 에서 보여주는 좌표 위의 점 패턴은 훨씬 작은 유한체인 소수 위수 17의 타원 곡선과 동일합니다. `secp256k1` 이더리움 타원 곡선은 더 크고 복잡한 점 패턴입니다.

> Example2 - Elliptic curve cryptography: visualizing an elliptic curve over F(p), with p=17

![image](https://user-images.githubusercontent.com/44635266/70844927-d9b49780-1e8b-11ea-8821-91d2be303ddd.png)

예를들어 `secp256k1` 곡선상의 점인 좌표 (x, y)를 가지는 점 Q 입니다.

```
Q =
(49790390825249384486033144355916864607616083520101638681403973749255924539515,
59574132161899900045862086493921015780032175291755807399284007721050341297360)
```

아래 예제는 python 을 활용하여 직접 확인하는 방법 입니다. x, y 가 실제로 타원 곡선상의 좌표라면, 그들은 방정식을 만족하고 결과는 0이 나오게 됩니다.

```shell
Python 3.7.5 (default, Nov  1 2019, 02:16:23)
[Clang 11.0.0 (clang-1100.0.33.8)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
>>> x = 49790390825249384486033144355916864607616083520101638681403973749255924539515
>>> y = 59574132161899900045862086493921015780032175291755807399284007721050341297360
>>> (x ** 3 + 7 - y**2) % p
0
```

### Elliptic Curve Arithmetic Operations

타원 곡선 수학 더하기 연산자를 정의할 수 있습니다. 이 연산자는 숫자 선을 따라 점프하는 대신 곡선의 다른 점으로 점프를 하게 됩니다.

타원 곡선에 두 점 $P_1$ 과 $P_2$ 가 주어지면 세 번째 점 $P_3 = P_1 + P_2$ 가 타원 곡선 위에 있도록 타원 곡선 덧셈을 정의합니다.

기하학적으로 이 세 번재 점 $P_3$ 은 $P_1$ 과 $P_2$ 사이의 선을 그려 계산합니다. 이 선은 정확하게 타원 곡선과 교차합니다. 이 점을 $P_3` = (x, y)$ 라고 부르겠습니다. 이어서 x 축에 반사하여 $P_3 = (x, -y)$ 를 구합니다.

$P_1$ 과 $P_2$ 가 같은 점이라면 $P_1$ 과 $P_2$ 사이의 선은 이 점 $P_1$ 곡선에 대한 접선으로 확장되어집니다. 이 접선은 새로운 점에서 곡선과 교차합니다. 미적분 기법을 사용하여 접선의 기울기를 결정할 수 있습니다. 이 기술은 2차원 정수 좌표상에 있는 곡선 위의 점들에도 적용할 수 있습니다. 아래 `Example 3`를 통해 쉽게 이해해보겠습니다.

> Example 3 - A visualization of an elliptic curve

![image](https://user-images.githubusercontent.com/44635266/70890343-2a60f780-2028-11ea-868d-e4c5af6e98fc.gif)


당신이 만약 두 점(A, B) 을 가지고 있고 최종점에 도착하기 위해 initial point에 임의의 n번을 dot 시켜준다면, 첫번째 점과 마지막 점만 가지고서는 n을 찾는것이 어렵습니다.

이 타원곡선을 이용하지 않고서는 같은 지점에 때 가지 몇번이나 x 축에 반사한지 알아낼 수 없습니다. 즉, do는 쉽고 undo는 어렵습니다. 좋은 트랩도어 함수의 표본입니다.

### Generating a Public Key

무작위로 생성한 숫자 k 형태의 개인키로 시작하여 생성자 점 G 라고 하는 곡선의 미리 결정된 점에 개인키를 곱하여 곡선상의 다른 점, 즉 대응하는 공개키 K 를 생성합니다.

$$K = k * G$$

생성한 점은 `secp256k1` 표준의 일부로 지정되어 모든 구현에서 동일하며, 해당 곡선에서 파생된 모든 키는 동일한 점 G 를 사용합니다. 생성자 점은 모든 이더리움 사용자에 대해 항상 동일하기 때문에, G 와 개인키 k 를 곱한 결과는 항상 K 로 동일합니다. k 와 K 관계는 고정되어 있지만, k 에서 K 까지의 한방향으로만 계산할 수 있습니다. 이런 이유로 이더리움 주소를 모든 사람과 공유 할 수 있으며, 사용자의 개인키는 공개하지 않습니다.

이제 이 계산을 적용하여 이전에 개인키로 특정 개인와 공개키를 찾아보겠습니다.

```
K = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315 * G
```

타원 곡선 곱셈을 사용하여 K 를 계산하는데 도움이 됩니다. 그 결과 공개키는 다음과 같은 점으로 정의합니다.

```
K = (x, y)
```

```
x = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b
y = 83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
```

이더리움에서 16진수 문자 130개의 Serialization 으로 표시되는 공개키를 볼 수 있습니다.

SEC 표준에서 제안한 형식에서는 타원 곡선의 점을 식별하는데 사용할 수 있는 4 가지  접두어를 정의합니다.

|Prefix|Meaning|Length(bytes counting prefix)|
|:--:|:--:|:--:|
|0x00|Point at infinity|1|
|0x04|Uncompressed point|65|
|0x02|Compressed point with even y|33|
|0x03|Compressed point with odd y|33|

이더리움은 압축되지 않은 공개키만을 사용합니다. 따라서 관련된 유일한 접두어는 `04` 입니다. Serialization 은 공개키와 x와 y 좌표를 연결합니다.

```
04 + x-coordinate (32 bytes/64 hex) + y-coordinate (32 bytes/64 hex)
```

따라서 이전에 계산한 공개키는 다음과 같이 Serialization 됩니다.

```
046e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0 \
c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
```

