---
title : An Overview of Kubernetes -1-
tags :
- Orchestration
- Container
- Kubernetes
- DevOps
---

*이 포스트는 [Managing Kubernetes](https://go.heptio.com/rs/383-ENX-437/images/Managing_Kubernetes.pdf)를 바탕으로 작성하였습니다.*

## Containers

> Example 1 - Comparing traditional, virtualized, containerized and Kubernetes deployment architectures.

![image](https://user-images.githubusercontent.com/44635266/71195056-7afa7e00-22d0-11ea-90b3-93f16d58c5bc.png)

컨테이너는 도커가 등장으로 대중화 되었으며 개발자가 어플리케이션을 패키지화하고 배포하는 방식에 혁명을 일으켰습니다.

Kubernetes 는 **Container Orchestrator** 때문에 Kubernetes 이해하기 위해선 컨테이너를 제대로 이해해야 합니다.

컨테이너는 다음 2가지를 포함합니다.

* A container image
* A set of operating system concepts that isolates a running process or processes

**컨테이너 이미지(Container Image)** 는 어플리케이션 런타임을 포함하는데, 이는 바이너리, 라이브러리, 컨테이너를 실행하는 데 필요한 기타 데이터로 구성되어 있습니다. 개발자는 자신의 컴퓨터에서 어플리케이션을 컨테이너 이미지로 패키지화합니다. 그리고 다른 사용자의 컴퓨터나 데이터 센터 서버와 같은 다른 환경에서 이미지를 배포하고 실행할 때, 자신의 컴퓨터에서와 동일하게 컨테이너가 그대로 작동할 것이라고 신뢰할 수 있습니다. 다양한 환경에서 `portability` 과 일관된 실행은 컨테이너 이미지가 추구하는 가치 중 하나입니다.

컨테이너 이미지가 실행될 때 OS 의 네임스페이스를 사용하여 실행됩니다. 이런 네임스페이스는 프로세스를 포함하고 있으며, 이 프로세스는 시스템에서 실행 중인 다른 작업의 프로세스나 이와 관련된 것과 격리할 수 있습니다.

이런 격리는 각 컨테이너가 `chroot` 와 같은 분리된 고유한 파일 시스템을 가지고 있습니다. 또한, 각 컨테이너에는 고유한 자체 네트워크 및 PID 네임스페이스가 있습니다. 즉, 한 컨테이너의 프로세스 번호 42는 다른 컨테이너의 42번과 다른 프로세스 입니다. 커널 내에는 다양한 실행 컨테이너를 구분하도록 서로 다른 네임스페이스가 많이 있습니다. 마지막으로 바안 강화 리눅스 또는 AppArmor 와 같은 표준 운영체제 보안 기능을 실행 중인 컨테이너와 함께 사용 될 수 있습니다.

요약하자면 모든 격리는 별도의 컨테이너에서 실행되는 서로 다른 프로세스가 간섭하는 것을 더 어렵게 만들어 줍니다.

> 격리에 관해 이야기할 때는 CPU, 메모리, 파일과 같은 자원과 관련이 있다는게 중요합니다. 리눅스 및 윈도우에서 구현된 컨테이너는 현재 서로 다른 프로세스에 대한 강력한 보안 격리를 제공하지 않습니다. 컨테이너를 다른 커널 수준의 격리와 결합하면 일부 유스 케이스에 대해 합리적인 보안 격리를 제공할 수 있습니다. 하지만 일반적으로 hypervisior 수준의 보안만으로도 까다로운 워크로드를 격리할 수 있습니다.

컨테이너형 어플리케이션을 빌드하고 배포하는 데 도움이 되는 여러가지 툴이 만들어졌습니다.

첫 번째는 컨테이너 이미지 빌더입니다. 일반적으로 도커 명령줄 툴은 컨테이너 이미지를 작성하는데 사용합니다. 그러나 Open Container Initiavtive 표준으로 이미지 형식이 표준화되었스빈다. 이 표준으로 API, CI/CD 또는 새로운 대체 툴과 라이브러리로 제공되는 다른 이미지 빌더를 개발할 수 있었습니다.

도커 툴은 컨테이너 이미지를 만드는 방법에 대한 일련의 지침을 지정하는 **dockerfile** 을 사용합니다.

컨테이너 이미지를 만든 후에는 해당 이미지를 사용자의 컴퓨터에서 다른 사용자, 클라우드, 개인 센터에 배포하는 방법이 필요 합니다. 여기서 **이미지 레지스트리(Image Registry)** 가 등장합니다. 이 개념은 이미지를 업로드하고 관리하기 위한 API 입니다. 이미지가 빌드되면 이미지 레지스트리로 푸시됩니다. 이미지가 레지스트리에 저장한 후 =에는 해당 레지스트리에 접근할 수 있는 모든 시스템으로 이미지를 가져오거나 다운로드 할 수 있습니다.

레지스트리는 이미지를 푸시할 수 있는 권한이 있어야 하지만 일부 레지스트리는 공개되어 있으므로, 이미지를 푸시하면 전세계 누가나 이미지를 가져오거나 실행할 수 있습니다. 다른것은 비공개이며 이미지를 가져오기 위해서는 권한이 필요합니다.

## Container Orchestration

레지스트리 어딘가에 컨테이너 이미지를 저장 후 동작하는 어플리케이션을 만들려면 컨테이너 이미지를 실행해야 합니다. Kubernetes 와 같은 Container Orchestration 가 필요해지는 시점입니다. Kubernetes 역할은 CPU, Memory, Disk 와 같은 컴퓨터 리소스 그룹을 가져와 개발자가 컨테이너를 배포하는 데 사용할 수 있도록 컨테이너 지향 API 로 변환하는 것입니다.

Kubernetes 시스템은 리소스를 검토합니다. 그리고 해당 컨테이너 이미지가 실행될 수 있는 좋은 위치를 찾고 해당 컴퓨터 위치에서 컨테이너가 실행되도록 스케줄 합니다. 개발자는 자신의 컨테이너 이미지가 실행되는 것을 확인할 수 있지만 컨테이너가 구체적으로 어디에서 실행되는지 관심을 둘 필요는 없습니다.

하지만, 오케스트레이션 시스템은 컨테이너를 서버에 스케줄하는 것 이상의 의미를 가지고 있습니다. Kubernetes 오케스트레이터는 문제가 발생했을 때 컨테이너를 복구하는 방법을 알고 있습니다. 컨테이너 내부의 프로세스가 충돌하면 Kubernetes 가 이를 다시 시작합니다. 사용자 정의 상태 검사를 정의하면 Kubernetes 는 어플리케이션이 교착 상태에 있어 다시 시작해야 하는지(Liveness Check), 로드밸런싱 조정 서비스(readliness check) 를 해야 하는지 알 수 있습니다.

로드밸런싱과 관련하여 Kubernetes 는 다양한 **레플리카replica** 간 트래픽의 로드 밸런싱 방법을 정의하는 API 오브젝트도 제공합니다.

또한, Kubernetes 는 Zero-Downtime rollout 을 수행하고 설정, Persistent Volume, Secret 등을 관리하는 오브젝트를 가지고 있습니다.