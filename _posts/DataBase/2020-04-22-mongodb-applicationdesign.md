---
title : MongoDB Application Design
tags :
- Cardinality
- Application Design
- MongoDB
---

*이 포스트는 [MongoDB: The Definitive Guide](https://github.com/wuzhouhui/misc/blob/master/programming/db/MongoDB.The.Definitive.Guide.pdf) 를 바탕으로 작성하였습니다.*

## Normalization versus Denormalization

데이터를 표현하는 방법은 다양합니다. 그 과정에서 데이터를 얼만큼 **정규화(Normalization)** 하는지는 늘 중요한 관심사입니다. 정규화는 컬렉션의 간의 참조를 가지고 데이터를 여러 컬렉션으로 나누는 것입니다. 각 데이터 조각은 여러 문서가 참조할 수 있지만 하나의 컬렉션에 들어 있습니다.

따라서 데이터를 변경하려면 한 문서만 갱신하면 됩니다. 하지만 MongoDB 는 조인을 지원하지 않기 때문에 여러 컬렉션에서 문서를 모으려면 쿼리를 여러 번 수행해야 합니다.

**비정규화(Denormalization)** 는 모든 데이터를 하나의 문서에 내장하는 것으로 정규화의 반대입니다. 최종 데이터 사본에 대해 참조를 가지는 문서 대신에 여러 문서가 데이터의 사본을 갖습니다. 이는 정보가 변경되면 여러 문서가 갱신되어야 하지만 모든 관련 데이터는 하나의 쿼리로 가져올 수 있습니다.

일반적으로 정규화는 쓰기를 빠르게 만들고 비정규화는 읽기를 빠르게 만듭니다.

### Examples of Data Representations

학생들과 학생들이 수강 중인 과목에 대한 정보를 저장한다고 가정하겠습니다. 이를 표현하는 방법은 `student` 컬렉션과 `classes` 컬렉션을 갖는것입니다. 그 밖에도 학생과 학생이 수강 중인 과목에 대한 참조를 포함하는 `studentClasses` 컬렉션을 가질 수 있습니다.

```js
> db.studentClasses.findOne({"studentId" : id})
{
    "_id" : ObjectId("512512c1d86041c7dca81915"),
    "studentId" : ObjectId("512512a5d86041c7dca81914"),
    "classes" : [
        ObjectId("512512ced86041c7dca81916"),
        ObjectId("512512dcd86041c7dca81917"),
        ObjectId("512512e6d86041c7dca81918"),
        ObjectId("512512f0d86041c7dca81919")
    ]
}
```

RDB 에 익숙하면 위와 같은 형태의 조인 테이블을 본 적이 있을것입니다. 과목을 배열에 집어넣는 것이 MongoDB 스럽지만 실제 정보를 얻으려면 여러번 쿼리해야 하기 때문에 일반적으로 위와같이 데이터를 보관하지 않습니다.

학생이 수강하는 과목을 찾을때, `students` 컬렉션에서 학생을 쿼리하고 과목 `_id` 를 위해 `studentClasses`, 과목 정보를 위해 `classes` 즉, 3 번 쿼리를 해야합니다. 과목과 학생이 자주 바뀌지 않고 데이터를 빠르게 조회해야 할 필요가 없다면, MongoDB 에서 일반적으로 사용자가 데이터를 구주화하는 방법이 아닙니다.

학생 문서 안에 과목에 대한 참조를 내장하여 참조를 사용하는 쿼리 중 하나를 제거할 수 있습니다.

```js
{
    "_id" : ObjectId("512512a5d86041c7dca81914"),
    "name" : "John Doe",
    "classes" : [
        ObjectId("512512ced86041c7dca81916"),
        ObjectId("512512dcd86041c7dca81917"),
        ObjectId("512512e6d86041c7dca81918"),
        ObjectId("512512f0d86041c7dca81919")
    ]
}
```

`classes` 필드는 John Doe 가 수강중인 과목의 `_id` 배열을 보관합니다. 해당 과목에 대한 정보를 조회하고자 한다면 `classes` 컬렉션에 `_id` 로 쿼리할 수 있습니다. 두 개의 쿼리면 충분합니다.

읽기를 좀 더 최적화할 필요가 있다면, 데이터를 완전히 비정규화하고 각 과목을 `classes` 필드에 내장 문서로 저장하여 모든 정보를 하나의 쿼리로 가져오게 할 수 있습니다.

```js
{
    "_id" : ObjectId("512512a5d86041c7dca81914"),
    "name" : "John Doe",
    "classes" : [
        {
            "class" : "Trigonometry",
            "credits" : 3,
            "room" : "204"
        },
        {
            "class" : "Physics",
            "credits" : 3,
            "room" : "159"
        },
        {
            "class" : "Women in Literature",
            "credits" : 3,
            "room" : "14b"
        },
        {
            "class" : "AP European History",
            "credits" : 4,
            "room" : "321"
        }
    ]
}
```

이때 장점은 정보를 얻기 위해 쿼리를 하나만 사용하는 것입니다. 반면 단점은 더 많은 공간을 차지하고 동기화하기가 더 어렵다는 것입니다. 예를 들어 물리학이 4 학점이라면 물리학 과목을 수강하는 모든 학생의 문서를 갱신해야
합니다.

마지막으로 내장과 참조의 혼합형을 사용할 수 있는데 이는 자주 사용되는 정보로 하위 문서의 배열을 생성하지만 추가적인 정보에 대한 실제 문서는 참고하는 방식입니다.

```js
{
    "_id" : ObjectId("512512a5d86041c7dca81914"),
    "name" : "John Doe",
    "classes" : [
        {
            "_id" : ObjectId("512512ced86041c7dca81916"),
            "class" : "Trigonometry"
        },
        {
            "_id" : ObjectId("512512dcd86041c7dca81917"),
            "class" : "Physics"
        },
        {
            "_id" : ObjectId("512512e6d86041c7dca81918"),
            "class" : "Women in Literature"
        },
        {
            "_id" : ObjectId("512512f0d86041c7dca81919"),
            "class" : "AP European History"
        }
    ]
}
```

요구사항의 변경으로 시간이 흐르면서 내장된 정보의 양이 계속 변경될 수 있기 때문에 이런 방식도 괜찮습니다. 한 페이지에 정보를 많거나 적게 포함시키기 위해 문서 내 정보를 많거나 적게 내장시킬 수 있습니다.

또 다른 고려 사항은 정보가 읽혀지는 빈도에 비해 정보가 얼마나 자주 변경되는가에 대한 것입니다. 정기적으로 갱신되어야 한다면 정규화하는 것이 좋습니다. 하지만 드물게 변경된다면 어플리케이션이 수행하는 모든 읽기를 희생하여 갱신 프로세스를 최적화하는 방법은 거의 이득이 없습니다.

마지막으로 데이터에 필수적인 필드들은 문서 내에 포함되어야 합니다. 이 문서에 대해 쿼리할 때 필드가 결과에서 거의 항상 제외된다면 다른 컬렉션에 속해도 됩니다. 이러한 지침은 아래 표에 요약되어 있습니다.

|Embedding is better for...|References are better for...|
|:--|:--|
|작은 하위문서|큰 하위문서|
|정기적으로 변하지 않는 데이터|자주 변하는 데이터|
|결과적인 일관성이 허용될 때|즉각적인 일관성이 필요할 때|
|증가량이 적은 문서|증가량이 많은 문서|
|조회하려는 두 번째 쿼리를 수행하기 위해 자주 필요한 데이터|결과에서 자주 제외되는 데이터|
|빠른 읽기|빠른 쓰기|

사용자 컬렉션에 있다고 가정하겠습니다. 내장 어뷰를 판단할 있을 법한 몇 가지 예제 필드가 있습니다.

* Account preferences
  * 오직 이 사용자 문서와 관련이 잇고 아마도 이 문서에서 다른 사용자 정보로 노출될 것입니다. 계정 설정은 일반적으로 내장되어야 합니다.
* Recent activity
  * 최근 활동이 얼마나 많아지고 바뀌는지에 다라 달라집니다. 고정된 크기의 필드라면 내장하는 것이 유용합니다.
* Friends
  * 일반적으로 내장하지 않거나 완전히 내장하는 것은 피해야 합니다. 소셜 네트워킹에 대한 조언은 아래 절을 참조합니다.
* All of the content this user has produced
  * 내장하지 않습니다.

### Cardinality

**카디널리티(Cardinality)** 는 컬렉션이 다른 컬렉션에 대한 참조를 얼마나 많이 갖는가를 나타내는 개념입니다. 일반적인 관계는 일대일, 일대다, 다대일 관계입니다.

각 게시물은 제목을 가지므로 일대일 관계입니다. 각 저자는 많은 게시물을 가지므로 일대다 관계입니다. 게시물들은 여러 태그를 가지고 태그들은 여러 게시물을 참조하므로 이는 다대다 관계입니다.

MongoDB 를 사용할 때 다수를 함위 범주 많음과 적음으로 나누는 것이 개념상으로 도움이 됩니다. 예를 들어 각 저자가 몇 개의 게시물을 작성하면 저자와 게시물 사이에는 **일대소(One-to-Few)** 카디널리티를 가집니다. 태그보다 게시물을 더 많이 가진다면 블로그 게시물과 태그 사이에는 **다대소(Many-to-Few)** 관계를 가집니다. 많은 댓글이 달려 있는 블로그 게시물과 댓글 사이에는 일대다 관계를 가집니다.

### Friends, Followers, and Other Inconveniences

> Keep your friends close and your enemies embedded.

사람, 내용, 팔로워, 친구등을 연결하는 소셜 어플리케이션은 많습니다. 이러한 긴밀하게 연견될 정보를 내장하는 것과 참조하는 것을 적절히 알마젝 사용하는 방법을 파악하는건 까다로울 수 있습니다.

하지만 일반적으로 팔로우하고, 친구를 맺고, 짐하는 것은 한 사용자가 다른 사람으로부터의 알림을 구독하는 발행-구독 시스템으로 단순화할 수 있습니다. 따라서 능률적일 필요가 잇는 두 가지 기본적인 작업이 있는데, 이는 구독자를 어떻게 저장하는가와 이벤트와 관련된 모든 당사자에게 어떻게 통지하는가 입니다.

사람들이 전형적으로 구현을 구독하는 데는 3 가지 방법이 있습니다. 첫 번재 선택은 발행자를 구독자의 문서에 넣는 방법입니다.

```js
{
    "_id" : ObjectId("51250a5cd86041c7dca8190f"),
    "username" : "batman",
    "email" : "batman@waynetech.com"
    "following" : [
        ObjectId("51250a72d86041c7dca81910"), 
        ObjectId("51250a7ed86041c7dca81936")
    ]
}
```

이제 사용자의 문서가 있다면 `db.activities.find({"user" : {"$in" : user["following"]}})` 처럼 쿼리하여 관심 있어 하는 발행된 모든 행사를 찾을 수 있습니다. 하지만 새로 발행된 행사에 관심을 가지는 모든 사람을 찾아야 한다면 모든 사용자에 걸쳐 `following` 필드를 쿼리해야 합니다.

그 대신 팔로워를 발행자의 문서에 다음과 같이 추가할 수 있습니다.

```js
{
    "_id" : ObjectId("51250a7ed86041c7dca81936"),
    "username" : "joker",
    "email" : "joker@mailinator.com"
    "followers" : [
        ObjectId("512510e8d86041c7dca81912"),
        ObjectId("51250a5cd86041c7dca8190f"),
        ObjectId("512510ffd86041c7dca81910")
    ]
}
```

이 사용자는 무언가 할 때마다 알려줘야 할 모든 사용자를 바로 알 수 있습니다. 단점은 팔로우 하는 모든 사람을 찾으려면 전체 사용자 컬렉션을 쿼리해야 한다는 것입니다.

이러한 선택 사항 중 어느쪽이든 추가적인 단점이 잇습니다. 이는 문서를 더욱 크고 자주 바뀌도록 만듭니다. `following(followers)` 필드는 자주 반환될 필요가 없습니다. 사용자들이 자주 팔로우하거나 팔로우를 그만둔다면 이는 많은 **단편화(Fragmentation)** 를 초래할 수 있습니다.

따라서 최종 선택 사항은 좀 더 정규화해서 구독을 다른 컬렉션에 저장함으로써 이러한 단점들을 완화하는 것입니다. 그만큼 정규화하는 것은 종종 과잉이지만 문서의 나머지를 반환하지 않는 너무 자주 변하는 필드에 대해 유용합니다. `followers` 는 이런 방법으로 적합할 필드입니다.

아래와 같은 문서를 가지는 발행자와 구독자가 짝지어진 컬렉션을 둡니다.

```python
{
    "_id" : ObjectId("51250a7ed86041c7dca81936"), // followee's "_id"
    "followers" : [
        ObjectId("512510e8d86041c7dca81912"),
        ObjectId("51250a5cd86041c7dca8190f"),
        ObjectId("512510ffd86041c7dca81910")
    ]
}
```

이는 사용자 문서를 유연하게 유지시켜 주지만 팔로워를 얻으려면 추가적인 쿼리를 해야합니다. `followers` 배열은 일반적으로 자주 크기를 변경할 것이며, 이는 사용자 컬렉션을 가능한 작게 유지하려는 동안에 이 컬렉션에 `usePowerOf2Sizes` 를 활성화하는 것을 허용합니다.

이 팔로워 컬렉션을 다른 데이터베이스에 둔다면 사용자 컬렉션에 너무 많이 영향을 주지 않고 조각 모음을 할 수 있습니다.

#### 1. Dealing with the Wil Wheaton effect

사용하는 전략에 관계없이, 내장은 단지 제한된 수의 하위문서 및 참조에 적합합니다. 유명인 사용자가 있다면 팔로워를 저장하고 있는 어떤 문서라도 넘쳐날 수 있습니다. 이를 절충하는 전형적인 방법은 필요하다면 연속 문서를 가지는겁니다. 예를 들면 다음과 같이 할 수 있습니다.

```js
> db.users.find({"username" : "wil"})
{
    "_id" : ObjectId("51252871d86041c7dca8191a"),
    "username" : "wil",
    "email" : "wil@example.com",
    "tbc" : [
        ObjectId("512528ced86041c7dca8191e"),
        ObjectId("5126510dd86041c7dca81924")
    ]
    "followers" : [
        ObjectId("512528a0d86041c7dca8191b"),
        ObjectId("512528a2d86041c7dca8191c"),
        ObjectId("512528a3d86041c7dca8191d"),
        ...
    ]
}
{
    "_id" : ObjectId("512528ced86041c7dca8191e"),
    "followers" : [
        ObjectId("512528f1d86041c7dca8191f"),
        ObjectId("512528f6d86041c7dca81920"),
        ObjectId("512528f8d86041c7dca81921"),
        ...
    ]
}
{
    "_id" : ObjectId("5126510dd86041c7dca81924"),
    "followers" : [
        ObjectId("512673e1d86041c7dca81925"),
        ObjectId("512650efd86041c7dca81922"),
        ObjectId("512650fdd86041c7dca81923"),
        ...
    ]
}
```

이후 문서 조회를 돕기 위해 `tbc` 배열에 어플리케이션 로직을 추가합니다.

## Optimizations for Data Manipulation

어플리케이션을 최적화하기 위해 읽기와 쓰기 성능을 분석하여 어느 것이 병목 현상을 일으키는지 우선적으로 알아야 합니다. 읽기를 최적화하는 것은 일반적으로 올바른 인덱스를 가지고 하나의 문서에서 가능한 한 많은 정보를 돌려주는 것과 관련이 있습니다.

쓰기를 최적화하는 것은 보통 가지고 있는 인덱스의 수를 최소화하고 가능한 한 효율적으로 갱신을 수행하는 것과 관련이 있습니다.

빠른 쓰기를 위한 최적화 스키마와 빠른 읽기를 위한 최적화 스키마 사이에는 종종 타협점이 존재하므로, 어플리케이션에 무엇이 더 중요한지 결정해야 할 수 있습니다. 쓰기와 대비한 읽기의 중요성뿐만 아니라 이들의 비율 또한 최적화 요소가 됩니다. 만약 쓰기가 더 중요하지만 모든 쓰기에 대해 수천 번의 읽기를 수행하고 잇다면 여전히 읽기를 먼저 최적화하기 원할 것입니다.

### Optimizing for Document Growth

데이터를 갱신할 필요가 있다면, 문서의 크기가 계속 커질 것인지 아닌지, 그리고 커진다면 얼마나 커질 것인지 결정해야 합니다. 만약 그것이 예측할 만한 양이라면 문서를 패딩하는 것이 이동을 방지하고 스기를 빠르게 만듭니다. 패딩 요소가 1.2 정도거나 더 크다면 수동 패딩의 사용을 고려해야 합니다.

문서를 수동적으로 패딩한다는 것은 자웅에 제거해야 할 큰 필드를 가진 문서를 생성하는 것입니다. 이는 결국 문서가 필요로 하는 공간을 사전에 할당하는 것입니다. 예를 들어 음식점 평가에 대한 컬렉션을 가지고 있고 문서가 다음과 같은 모습이라고 가정하겠습니다.

```js
{
    "_id" : ObjectId(),
    "restaurant" : "Le Cirque",
    "review" : "Hamburgers were overpriced."
    "userId" : ObjectId(),
    "tags" : []
}
```

`tags` 필드는 사용자가 더한 태그만큼 증가할 것이고, 어플리케이션은 종종 다음과 같이 갱신을 수행할 것입니다.

```js
> db.reviews.update({"_id" : id}, 
... {"$push" : {"tags" : {"$each" : ["French", "fine dining", "hamburgers"]}}}})
```

`tags` 가 일반적으로 100 byte 이상 증가하지 않는다면 원하지 않는 이동을 방지하기 위해 수동으로 문서를 패딩할 수 있습니다. 문서를 패딩없이 남겨 둔다면 `tags` 의 크기가 증가함에 따라 이동은 반드시 발생하게 될 것입니다. 패딩을 위해 문서에 마지막 필드를 추가합니다.

```js
{
    "_id" : ObjectId(),
    "restaurant" : "Le Cirque",
    "review" : "Hamburgers were overpriced."
    "userId" : ObjectId(),
    "tags" : [],
    "garbage" : "........................................................"+
        "................................................................"+
        "................................................................"
}
```

이를 `insert` 상에서 수행하거나 문서가 `upsert` 로 생성되었다면, 문서가 처음으로 삽입되었을 대 필드를 생성하기 위해 `$setOnInsert` 를 사용합니다.

문서를 갱신할 때는 항상 `garbage` 필드를 `$unset` 합니다.

```js
> db.reviews.update({"_id" : id}, 
... {"$push" : {"tags" : {"$each" : ["French", "fine dining", "hamburgers"]}}},
...  "$unset" : {"garbage" : true}})
```

만약 `garbage` 필드가 존재한다면 `$unset` 은 `garbage` 필드를 삭제하고, 그렇지 않다면 어떤 연산도 발생하지 않습니다.

문서가 증가하는 하나의 필드를 가지고 있다면 문서의 마지막 필드로 유지하도록 노력해야합니다. 필드의 크기가 커졌을 때 MongoDB 가 `tags` 필드 뒤에 필드를 다시 쓰는 일이 없게 해야 더 효율적입니다.

### Removing Old Data

일부 데이터는 짧은 시간 동안만 중요합니다. 시간이 지날 수록 이 데이터는 저장 공간만 낭비하게 됩니다. 오래된 데이터를 제거하는 데 있어 3 가지 인기 있는 옵션이 있습니다. 제한 컬렉션, TTL 컬렉션, 시간당 컬렉션 삭제입니다.

가장 쉬운 옵션은 **제한 컬렉션** 을 사용하는 것입니다. 제한 컬렉션의 크기를 크게 설정하고 오래된 데이터를 끝으로 밀려 나가게 하면 됩니다. 그러나 제한 컬렉션은 사용자가 할 수 있는 작업에 대해 어느 정도의 제약 사항을 유발하며 일시적으로 컬렉션이 가질 수 있는 시간의 길이를 줄이기 때문에 급격히 증가하는 트래픽에 취약합니다.

두 번째 옵션은 **TTL 컬렉션** 입니다. TTL 컬렉션은 문서가 제거될 때 미세 수준의 조절을 제공합니다. 그러나 많은 쓰기를 수행하는 컬렉션에는 빠르지 않습니다. 이는 사용자 요청의 제거와 같은 방식으로 TTL 인덱스를 탐색하여 문서를 제거합니다. 그럼에도 불구하고 TTL 컬렉션이 유지될 수 있다면 아마 가장 쉬운 방법이라 할 수 있습니다.

마지막 옵션은 여러 컬렉션을 사용하는 것입니다. 예를 들어 한 달에 하나의 컬렉션을 사용할 수 있습니다. 달이 바뀔 때마다 어플리케이션은 이 달의 비어있는 컬렉션을 사용하고 현재와 이전 달의 컬렉션에 있는 데이터를 찾습니다. 컬렉션이 6 개월보다 오래되면 이를 삭제할 수 있습니다. 이는 많은 양의 트래픽에도 대부분 버틸 수 있게 해 주지만, 동적 컬렉션 이름을 사용해서 가능한 한 여러 데이터베이스를 조회해야 하기 때문에 어플리케이션을 구축하는 것이 좀 더 복잡합니다.

## Planning Out Databases and Collections

일단 문서의 형태가 구상 된다면 어떤 컬렉션 또는 어떤 데이터베이스 안에 넣어야 할지 결정해야 합니다. 이는 매우 직관적인 과정이지만, 염두에 두어야 할 몇 가지 지침이 있습니다.

일반적으로 비슷한 스키마를 가진 문서는 같은 컬렉션에 보관해야 합니다. MongoDB 는 여러 컬렉션에서의 데이터 결합을 허용하지 않기 때문에, 함게 쿼리나 집계해야 하는 문서가 있는 경우, 이러한 문서는하나의 큰 컬렉션에 넣기 위한 좋은 후보입니다. 예를 들어 다른 모양의 문서를 가질 수 있지만, 이를 집계할 예정이라면 모두 같은 컬렉션에 존재해야 합니다.

데이터베이스에 대해 고려해야하는 큰 문제는 락과 저장입니다. 각 데이터베이스는 각자의 파일 내에 존재하고, 대개 디스크에 존재하는 각자의 디렉터리에 위치하는데, 이는 다른 데이터베이스를 다른 볼륨에 마운트할 수 있음을 의미합니다. 그러므로 데이터베이스 내에 모든 항목이 비슷한 품질, 접근패턴, 트래픽 수준을 가지길 원할것입니다.

어플리케이션의 데이터를 중요도에 따라 나누면 3 개의 데이터베이스로(Log, Activites, Users) 나눌 수 있습니다. 이렇게 분리하면 가장 높은 가치의 데이터가 가장 작은 데이터라는 장점이 있습니다. 전체 데이터 셋을 위해 SSD 를 가질 여유가 없을 수도 있지만, 사용자를 위해 하나 정도는 마련할 수 있습니다. 또는 사용자를 위해 RAID10 을, 로그와 액티비티를 위해 RAID0 을 사용하면됩니다.

여러 데이터베이스를 사용할 때 몇가지 제한 사항이 있습니다. MongoDB 는 사용자가 직접 데이터를 한 데이터베이스에서 다른 데이터베이스로 옮기는 것을 허용하지 않습니다. 사용자는 특정 데이트베이스에서 수행되지 않은 맵리듀스의 결과를 특정 데이터베이스에 저장할 수 없고, 특정 데이터베이스에 있던 컬렉션을 `renameCollection` 으로 다른 데이터베이스로 옮길 수 없습니다.

## Managing Consistency

직접 쓴 데이터를 읽는 것에서부터 알려지지 않은 오래된 데이터를 읽는 것까지 상당히 다양한 수준의 일관성을 제공합니다. 지난해의 액티비티를 리포팅한다면 지난 며칠간의 정확한 데이터가 필요할 수도 있습니다. 대조적으로 실시간 거래를 수행한다면 최신 쓰기에 대해 즉각적으로 읽기를 수행할 필요가 있습니다.

다양한 일관성 수준을 획득하는 방법을 이해하기 위해서는 MongoDB 가 내부에서 무엇을 수행하는지 이해할 필요가 있습니다. 서버는 각 연결에 대한 요청 큐를 유지하고 있습니다. 클라이언트가 요청을 보낼 때 해당 요청은 연결 큐의 가장 끝 쪽에 위치하게 될 것입니다. 큐의 대기열에 요청을 추가하는 작업이 진행되고 난 뒤에 그 연결의 모든 후속 요청이 발생할 것입니다. 그러므로 단일 연결은 데이터베이스에 대한 일관적인 관점을 가지고 있고 자신의 쓰기를 항상 읽을 수 있습니다.

## Migrating Schemas

어플리케이션의 규모가 커지고 요구사항이 변할수록 스키마 또한 커지고 변화해야 합니다. 이를 수행하는 몇 가지 방법이 있는데 어떤 방법을 선택하든 어플리케이션이 사용하는 각 스키마를 조심스럽게 기록해야 합니다.

가장 단순한 방법은 스키마를 어플리케이션의 요구에 맞도록 변화시키는 것입니다. 어플리케이션이 모든 오래된 버전으 스키마를 지원하는지 확인합니다. 이 기술은 특히 버전 문제로 충돌하는 경우에는 매우 지저분해질 수 있습니다.

다음 방법은 각 문서에 `version` 필드를 추가하고 스키마를 엄격하게 관리하는 것입니다.

마지막은 스키마가 변경될 때 모든 데이터를 마이그레이션하는 것입니다. MongoDB 는 시스템에 많은 부하를 줄 수 있는 마이그레이셔을 피하기 위해 동적 스키마를 가지는 것을 허용합니다.

## When Not to Use MongoDB

MongoDB 는 다음과 같은 사례에 부적합합니다.

* MongoDB 는 트랜잭션을 지원하지 않기 때문에 트랜잭션을 요구하는 시스템은 다른 데이터 저장소를 사용해야 합니다. 
* 여러 차원에 걸쳐 다양한 유형의 데이터를 조인하려는 시도는 RDB 에 대한 환싱입니다. MongoDB 는 이러한 것을 잘 처리하지 못합니다.
* MongoDB 보다 RDB 를 사용하는 가장 큰 이유는 MongoDB 를 지원하지 않는 도구를 사용할 수 있기 때문입니다. 아직 RDB 만큼의 생태계를 따라갈 수 없습니다.