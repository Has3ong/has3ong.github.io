---
title : MongoDB Setting Up a Replica Set
tags :
- Election
- Primary
- Replica Set
- MongoDB
- Database
---

*이 포스트는 [MongoDB: The Definitive Guide](https://github.com/wuzhouhui/misc/blob/master/programming/db/MongoDB.The.Definitive.Guide.pdf) 를 바탕으로 작성하였습니다.*

## Introduction to Replication

독립 실행형 서버인 단일 `mongod` 서버를 사용했습니다. 이는 MongoDB 를 막 시작하기에는 쉬운 방법이지만, 실제 서비스에서 운영하기에는 매우 위엄합니다. 만약 서버 고장이 발생하거나 이용 불가능한 상태가 되면 대처가 안됩니다. 

복제는 여러 서버 상에서 데이터의 동일한 복사본을 유지하는 방법이며 모든 실제 서비스 적용을 위해 추천됩니다. 한 대 또는 그 이상의 서버에 어떤 이상이 발생해도, 복제는 어플리케이션을 정상적을 동작하게 하고 데이터를 안전하게 보존할 수 있게 합니다.

MongoDB 를 사용하면복제 셋을 생성함으로써 복제를 설정할 수 있습니다. 복제 셋은 클라이언트의 요청을 처리하는 하나의 **리(Primary)** 서버와 프라이머리 데이터의 복제 데이터를 가진 **세컨더리(Secondary)** 서버로 이루어집니다. 만약 프라이머리 서버에 장애가 발생하면 세컨더리 서버는 자신들 중 새로운 프라이머리 서버를 선출할 수 있습니다.

복제를 사용하는 상태에서 서버가 다운되면 복제셋에 있는 다른 서버를 통해 데이터에 접속할 수 있습니다. 만약 서버 상의 데이터가 손상되거나 접근할 수 없는 상태라면 복제 셋의 다른 멤버로부터 새로운 복제 데이터를 만들 수 있습니다.

## A One-Minute Test Setup

로컬 장비에 3-멤버 복제 셋 설정을 통해 빠르게 복제를 시작할 수 있도록 해보겠습니다. 이 설정은 실제 서비스에는 맞지 않지만 복제와 그 설정에 친숙해질 수 있는 좋은 방법입니다.

`mongo` 쉘에 `--nodb` 옵션으로 시작하면 어떤 `mongod` 에도 접속하지 않은 상태로 쉘을 시작합니다.

```shell
$ mongo --nodb
```

다음 명령을 통해 복제 셋을 만들어 보겠습니다.

```js
> replicaSet = new ReplSetTest({"nodes" : 3})
```

이난 하나의 프라이머리와 두 개의 세컨더리로 구성된 복제 셋을 생성하도록 쉘에 알려줍니다.

하지만 다음 두 명령을 실행하기 전까지 `mongod` 서버는 실제로 시작하지 않습니다.

```js
> // starts three mongod processes
> replicaSet.startSet()
>
> // configures replication
> replicaSet.initiate()
```

이제 포트 31000, 31001, 31002 에 실행하는 3 개의 `mongod` 프로세스를 확인할 수 있습니다. 이들은 매우 어지로운 로그를 혀냊 쉘이 쏟아낼 것이므로 이 쉘을 제쳐두고 새로운 두 번째 쉘을 하나 더 열어보겠습니다.

두 번재 쉘에서 31000 포트로 실행 중인 `mongod` 에 접속해보겠습니다.

```js
> conn1 = new Mongo("localhost:31000")
connection to localhost:31000
testReplSet:PRIMARY>
testReplSet:PRIMARY> primaryDB = conn1.getDB("test")
test
```

복제 셋 멤버에 접속할 때 프롬프트는 `testReplSet:PRIMARY>` 와 같이 바꿉니다. `PRIMARY` 는 멤버의 상태이며, `testReplSet` 은 이 복제 셋을 위한 식별자입니다. 나중에 자신의 식별자를 선택하는 방법을 배우겠습니다. `testReplSet` 은 `ReplSetTest` 가 사용하는 기본 이름입니다.

예제에서는 가독성을 위해 프롬프트 상에서 `testReplSet:PRIMARY>` 대신 `>` 를 사용하겠습니다.

`isMaster` 명령을 실행하기 위해 프라이머리에 접속된 연결을 사용합니다. 다음은 현재 복제 셋의 상태를 보여줍니다.

```js
> primaryDB.isMaster()
{
    "setName" : "testReplSet",
    "ismaster" : true,
    "secondary" : false,
    "hosts" : [
        "wooster:31000",
        "wooster:31002",
        "wooster:31001"
    ],
    "primary" : "wooster:31000",
    "me" : "wooster:31000",
    "maxBsonObjectSize" : 16777216,
    "localTime" : ISODate("2012-09-28T15:48:11.025Z"),
    "ok" : 1
}
```

`isMaster` 에 발생하는 결과물에는 꽤 많은 필드가 존재하지만, 중요 참조 사항은 이 노드가 프라이머리인지(`"ismaster":true`) 와 복제 셋에 존재하는 호스트들의 목록이 존재하는지 여부입니다.

프라이머리에 접속했다면, 쓰기를 수행하고 어떤 일이 발생하는지 살펴보겠습니다. 먼저 문서 1000 개를 입력합니다.

```js
> conn2 = new Mongo("localhost:31001")
connection to localhost:31001
> secondaryDB = conn2.getDB("test")
test
```

이제 세컨더리 중에 하나를 확인하고 모든 문서의 복제 데이터를 가지는지 확인합니다. 세컨더리 중 하나를 접속하겠습니다.

아마 세컨더리는 프라이머리보다 뒤떨어지고, 가장 최근의 쓰기에 대한 정보도 없기 때문에 기본적으로 읽기 요청을 거부하여 어플리케이션이 오래된 데이터를 읽는 것을 예방할 것입니다. 그러므로 세컨더리에 쿼리를 시도하면 *not primary* 란 메세지와 함께 오류가 발생합니다.

```js
> secondaryDB.coll.find()
error: { "$err" : "not master and slaveok=false", "code" : 13435 }
```

이는 어플리케이션을 실수로 세컨더리에 접속해서 오래된 데이터를 읽어 오는것으로부터 보호하기 위함입니다. 세컨더리에 대한 쿼리를 허용하기위해 *I’m okay with reading from secondaries* 라는 플래그를 다음과 같이 설정합니다.

```js
> conn2.setSlaveOk()
```

`slaveOK` 가 데이터베이스(`secondaryDB`)가 아닌 연결(`conn2`)에 설정되어 있음을 알아두어야합니다. 이제 이 멤버에서 읽도록 설정했습니다. 일반적인 쿼리를 수행해보겠습니다.

```js
> secondaryDB.coll.find()
{ "_id" : ObjectId("5037cac65f3257931833902b"), "count" : 0 }
{ "_id" : ObjectId("5037cac65f3257931833902c"), "count" : 1 }
{ "_id" : ObjectId("5037cac65f3257931833902d"), "count" : 2 }
...
{ "_id" : ObjectId("5037cac65f3257931833903c"), "count" : 17 }
{ "_id" : ObjectId("5037cac65f3257931833903d"), "count" : 18 }
{ "_id" : ObjectId("5037cac65f3257931833903e"), "count" : 19 }
Type "it" for more
>
> secondaryDB.coll.count()
1000
```

모든 문서가 존재하는것을 확인할 수 있습니다. 이제 세컨더리에 쓰기 작업을 시도해 보겠습니다.

```js
> secondaryDB.coll.insert({"count" : 1001})
> secondaryDB.runCommand({"getLastError" : 1})
{
    "err" : "not master",
    "code" : 10058,
    "n" : 0,
    "lastOp" : Timestamp(0, 0),
    "connectionId" : 5,
    "ok" : 1
}
```

세컨더리가 쓰기 작업을 허용하지 않는 것을 확인할 수 있습니다. 세컨더리는 오직 복제를 통해 받은 쓰기를 수행하고, 클라이언트로부터 들어온 쓰기는 수행하지 않습니다.

**자동 장애복구(Automatic Failover)** 는 시도해 볼 만한 흥미로운 특징입니다. 만약 프라이머리가 다운되면, 세컨더리 중 하나는 자동적으로 프라이머리로 선출됩니다. 이를 수행해 보려면 프라이머리를 중지시킵니다.

```js
> primaryDB.adminCommand({"shutdown" : 1})
```

어떤 것이 새로운 프라이머리가 되어있는지 확인하려면 세컨더리에서 `isMaster` 를 실행합니다.

```js
> secondaryDB.isMaster()
```

`isMaster` 를 실행하면 다음과 같이 보입니다.

```js
{
    "setName" : "testReplSet",
    "ismaster" : true,
    "secondary" : false,
    "hosts" : [
        "wooster:31001",
        "wooster:31000",
        "wooster:31002"
    ],
    "primary" : "wooster:31001",
    "me" : "wooster:31001",
    "maxBsonObjectSize" : 16777216,
    "localTime" : ISODate("2012-09-28T16:52:07.975Z"),
    "ok" : 1
}
```

다른 서버가 프라이머리가 될 수 있습니다. 어느 쪽이든 프라이머리가 다운되었다는 것을 먼저 알린 세컨더리가 프라이머리로 선출됩니다. 이 새로운 프라이머리에 쓰기 작업을 보낼 수 있습니다.

복제 셋에서 작업이 끝나면 첫 번째 쉘에서 서버를 중지시킵니다. 이 쉘은 복제 셋으로부터 발생한 로그 출력물로 가득할 것이며, 이 상황에서 프롬프트로 돌아오려면 엔터키를 여러번 누릅니다. 복제 셋을 중지하려면 다음을 실행시킨다.

```js
> replicaSet.stopSet()
```

중요사항을 몇가지 알아보겠습니다.

* 클라이언트는 독립 실행형 서버에 보낼 수 있는 모든 작업을 프라이머리 서버에도 보낼 수 있습니다.
* 클라이언트는 세컨더리에 쓰기 작업을 할 수 없습니다.
* 클라이언트는 기본적으로 세컨더리로부터 읽기 작업을 할 수 없습니다.
  * 내가 세컨더리로부터 데이터를 읽어 오고 있다는 사실을 알고 있다는 명시적인 설정을 통해 클라이언트는 세컨더리로부터 읽을 수 있습니다.

## Configuring a Replica Set

`server-1` 의 27017 번 포트에 약간의 데이터를 가진 독립 실행형 `mongod` 가 있다고 가정하겠습니다. 첫 번째로 해야 하는 일은 복제 셋의 이름을 설정하는 것입니다.

복제 셋을 위한 이름을 가지고 있다면 `--replSet name` 옵션을 사용하여 `server-1` 을 재기동하겠습니다.

```shell
$ mongod --replSet spock -f mongod.conf --fork
```

이제 `repleSet` 옵션 그리고 같은 식별자로 `mongod` 서버를 두 개 더 시작해보겠습니다. 이들은 복제 셋의 다른 멤버가 될 것입니다.

```shell
$ ssh server-2
server-2$ mongod --replSet spock -f mongod.conf --fork
server-2$ exit
$
$ ssh server-3
server-3$ mongod --replSet spock -f mongod.conf --fork
server-3$ exit
```

첫 번째 멤버가 데이터를 가지고 있다 하더라도 나머지 각 멤버는 빈 데이터 디렉토리를 가지고 있어야 합니다. 일단 복제 셋에 추가되기만 하면 추가된 멤버는 자동적으로 첫 번재 멤버의 데이터를 가져옵니다.

각 멤버에 대해 이제 서버 시작시 사용할 수 있도록 *mongod.conf* 파일에 `replSet` 옵션을 추가합니다.

`mongod` 를 시작하면 3 개의 분리된 서버의 3 개의 `mongod` 가 있어야 합니다. 하지만 각 `mongod` 는 아직 다른 `mongod` 의 존재를 모릅니다. 그들에게 다른 `mongod` 의 존재를 알리려면 각 멤버에 대해 목록을 표시하는 구성을 생성하고 이 구성을 `server-1` 에 보내야 합니다. `server-1` 은 다른 멤버에 해당 설정을 전파할 것입니다.

먼저 복제 셋 구성을 생성해보겠습니다. 쉘에서 다음과 같은 문서를 만듭니다.

```json
> config = {
    "_id" : "spock",
    "members" : [
        {"_id" : 0, "host" : "server-1:27017"},
        {"_id" : 1, "host" : "server-2:27017"},
        {"_id" : 2, "host" : "server-3:27017"}
    ]
}
```

몇 가지 중요한 부분이 있습니다. 구성의 `_id` 는 명령행에서 전달한 복제 셋의 이름입니다.

문서의 다음 부분은 복제 셋 멤버의 배열입니다. 이들 각각은 두 개의 필드를 필요로 하는데 정수형의 유일한 `_id` 와 호스트명입니다.

`config` 객체는 복제 셋 구성이기 때문에 이를 복제 셋 멤버에 보내야 합니다. 이렇게 하려면 데이터가 있는 서버 (`server-1:27017`) 에 접속한 뒤 다음과 같은 구성으로 복제 셋을 시작합니다.

```js
> // connect to server-1
> db = (new Mongo("server-1:27017")).getDB("test")
>
> // initiate replica set
> rs.initiate(config)
{
    "info" : "Config now saved locally.  Should come online in about a minute.",
    "ok" : 1
}
```

`server-1` 은 구성 내용을 구문 분석하고 다른 멤버에 메세지를 보내서 새로운 구성을 알립니다. 일단 멤버들이 모든 구성을 로드하면 새로운 프라이머리를 선출하고 읽기와 쓰기 작업을 처리합니다

새로운 복제 셋을 시작하는 경우에는 복제 셋 내의 어떤 멤버에도 구성을 보낼 수 있습니다. 멤버 중 하나에서 데이터를 가지고 시작하는 경우에는 해당 구성을 데이터와 함게 멤버에 보내야 합니다. 하나 이상의 멤버에서 데이터를 가지고 복제 셋을 시작할 수 없습니다.

### rs Helper Functions

`rs.initiate()` 명령의 `rs` 는 복제 보조자 함수를 포함하는 전역변수입니다. 이 기능은 거의 항상 데이터베이스 명령을 감싸고 있는 래퍼입니다. 예를 들어 다음 데이터 베이스 명령은 `rs.initiate(config)` 와 같습니다.

```js
> db.adminCommand({"replSetInitiate" : config})
```

경우에 따라 보조자 대신에 명령 양식을 사용하면 더 쉽게 해결할 수 있으니, 보조자 및 기본 명령 모두에 친숙해지는 것이 좋습니다.

### Networking Considerations

복제 셋의 모든 멤버는 같은 셋 내의 다른 멤버와 연결할 수 있어야 합니다. 만약 이미 작동 중인 다른 멤버에 연결할 수 없다는 에러가 발생하면, 서로의 연결이 이루어지도록 네트워크 구성을 바꿔야 합니다.

또한 복제 셋 구성에서 localhost 를 호스트 네임으로 사용하면 안됩니다. 단일 서버에서는 복제 셋을 작동하는 지점이 별로 없고, localhost 는 외부 시스템에서 제대로 인식되지 않기 때문입니다. MongoDB 는 로컬 테스트를 위해 모든 localhost 의 복제 셋을 허용하지만 구성에서 localhost 와 비 localhost 를 혼합하는 것은 허용하지 않습니다.

## Changing Your Replica Set Configuration

복제 셋 구성은 언제든지 변경될 수 있으며 멤버 추가, 삭제, 변경이 가능합니다. 몇 가지 일반적인 작업을 위한 쉘 보조자가 있으며, 복제 셋에 새로운 멤버를 추가할 때는 `rs.add` 를 사용할 수 있습니다.

```js
rs.add("server-4:27017")
```

마찬가지로 멤버를 제거할 수 있습니다.

```js
> rs.remove("server-1:27017")

Fri Sep 28 16:44:46 DBClientCursor::init call() failed
Fri Sep 28 16:44:46 query failed : admin.$cmd { replSetReconfig: { 
    _id: "testReplSet", version: 2, members: [ { _id: 0, host: "ubuntu:31000" }, 
   { _id: 2, host: "ubuntu:31002" } ] } } to: localhost:31000
Fri Sep 28 16:44:46 Error: error doing query: 
    failed src/mongo/shell/collection.js:155
Fri Sep 28 16:44:46 trying reconnect to localhost:31000
Fri Sep 28 16:44:46 reconnect localhost:31000 ok
```

멤버를 제거할 때나 추가하는것 이외의 거의 모든 구성을 변경을 할 때 쉘에서 데이터베이스에 연결할 수 없다는 에러가 발생할 수 있습니다. 사실 이는 재구성이 성공했다는 의미이므로 좋은 현상입니다. 복제 셋을 재구성할 때 프라이머리는 재구성 과정에서의 마지막 단계로 모든 커넥션을 닫습니다. 따라서 쉘은 잠시 연결이 끊어지지만 자동적으로 다음 작업에서 다시 연결됩니다.

프라이머리가 모든 연결을 닫는 이유는 복제 셋을 재구성할 때마다 프라이머리가 잠시 세컨더리로 강등되기 때문입니다. 프라이머리는 즉시 선출되어야 하지만 복제 재구성 후 짧은 순간 동안 프라이머리를 가지지 못합니다.

재구성 성공 여부는 쉘에서 `rs.config()` 실행을 통해 확인할 수 있습니다. 이는 현재 구성 정보를 출력합니다.

```js
> rs.config()
{
    "_id" : "testReplSet",
    "version" : 2,
    "members" : [
        {
            "_id" : 1,
            "host" : "server-2:27017"
        },
        {
            "_id" : 2,
            "host" : "server-3:27017"
        },
        {
            "_id" : 3,
            "host" : "server-4:27017"
        }
    ]
}
```

구성을 변경할 때마다 `version` 필드의 값은 증가합니다.

단지 멤버를 추가하거나 제거하는 것뿐만 아니라 이미 존재하는 멤버들을 수정할 수 있습니다. 수정을 하려면 쉘에서 구성 문서를 만들고 `rs.reconfig` 를 호출합니다. 예를 들어 아래와 같은 구성을 가진다고 가정하겠습니다.

```js
> rs.config()
{
    "_id" : "testReplSet",
    "version" : 2,
    "members" : [
        {
            "_id" : 0,
            "host" : "server-1:27017"
        },
        {
            "_id" : 1,
            "host" : "10.1.1.123:27017"
        },
        {
            "_id" : 2,
            "host" : "server-3:27017"
        }
    ]
}
```

누군가 실수로 흐스트명 대신에 IP 로 멤버 1 을 추가했습니다. 이를 변경하기 위해서는 쉘에서 현재 구성을 로드하고 관련 필드를 변경합니다.

```js
> var config = rs.config()
> config.members[1].host = "server-2:27017"
```

이제 구성 문서는 올바른 형태를 갖추었으니 `rs.config` 보조자를 이용해 이를 데이터베이스로 보내야 합니다.

```js
> rs.reconfig(config)
```

`rs.config` 는 멤버들의 구성을 변경하거나 여러 멤버를 한 번에 추가 / 제거하는 것과 같은 복잡한 작업을 위한 `rs.add` 와 `rs.remove` 에 더 유용합니다. 필요한 모든 유효한 구성을 변경하기 위해 이를 사용할 수 있습니다. 간단하게 원하는 형태의 구성을 나타내는 구성 문서를 작성하고 이를 `rs.config` 에 전달합니다.

## How to Design a Set

복제 셋을 구상하기에 앞서 복제 셋 개념을 알아보겠습니다. 프라이머리를 선출하기 위해 멤버의 과반수 이상이 필요하고, 프라이머리는 자시닝 과반수 이상에 머물러 있는 한 프라이머리로서의 역할을 유지할 수 있습니다. 그리고 과반수 이상에 복제되면 쓰기가 안전해집니다.

아래 테이블은 과반수를 정의한 것입니다.

|Number of members in the set|Majority of the set|
|:--|:--|
|1|1|
|2|2|
|3|2|
|4|3|
|5|3|
|6|4|
|7|4|

과반수는 복제 셋의 설정에 의해 산정되기 때문에 얼마나 많은 멤버가 다운되거나 사용할 수 없는 상태인지는 중요하지 않습니다.

예를 들어 `Example 1` 에서 같이 복제 셋에 다섯 멤버를 가지고 있고, 그 중 세 멤버가 다운되고 두 멤버가 살아있다고 가정하겠습니다. 이 살아있는 멤버는 과반수에 해당하지 않아 프라이머리를 선출할 수 없습니다. 둘 중 하나가 프라이머리였다면, 멤버가 과반수에 해당하지 않는다는 통보를 받자마자 프라이머리 자격을 내려놓습니다.

몇 초 뒤에 복제 셋은 두 개의 세컨더리와 세 개의 통신이 안 되는 멤버로 구성되어있는 것을 확인할 수 있습니다.

> Example 1 - With a minority of the set available, all members will be secondaries

![image](https://user-images.githubusercontent.com/44635266/79864792-04ec5c00-8415-11ea-8de7-ac90898a0251.png)

`Example 2` 를 보면 남아있는 멤버로 프라이머리를 선출할 수 없는지 알 수 있습니다. 왜냐하면 네트워크가 단절되었을수도 있기 때문입니다. 아래의 경우 왼쪽의 세 멤버는 복제 셋의 과반수를 이루기 때문에 프라이머리를 선출할 것입니다.

네트워크 파티션의 경우 파티션 양쪽에서 프라이머리를 선출하기를 원하지 않을 것입니다. 그렇지 않으면 복제 셋은 두 개의 프라이머리를 가지게 됩니다. 그러면 두 프라이머리는 모두 데이터에 기록을 하게되며 데이터 셋은 나뉩니다. 프라이머리를 선출하기 위해 과반수 이상을 요구하는 것은 하나 이상의 프라이머리를 가지는 경우를 피하기 위한 깔끔한 방법입니다.

> Example 2 - For the members, a network partition looks identical to servers on the other side of the partition going down

![image](https://user-images.githubusercontent.com/44635266/79864813-0d449700-8415-11ea-9472-d2292650fdb0.png)

일반적으로 하나 이상의 프라이머리만을 가질 수 있으며 이런 방식으로 복제 셋을 구성하는 것은 중요합니다. 예를 들어 위에 표시된 다섯 멤버로 구성된 복제 셋의 경우, 만약 멤버 1, 2, 3 이 한 데이터 센터 내에 있고 나머지 멤버 4, 5 가 다른곳에 존재한다면, 거의 언제나 복제 셋의 과반수는 첫 번째 데이터 센터일 가능성이 높습니다.

원하진 않지만, 일반적인 설정 중 하나는 프라이머리와 하나의 세컨더리로 구성된 2-멤버 복제 셋입니다. `Example 3` 처럼 하나의 멤버가 이용 불가능한 상태가 되었는데, 또 다른 멤버는 이를 확인할 수 없다고 가정하겠습니다. 이 상황에서 어느 쪽 네트워크 파티션도 과반수를 차지하지 못하기 때문에 두 개의 세컨더리로 끝납니다. 따라서 이 종류의 구성은 권장되지 않습니다.

> Example 3 - With an even number of members, neither side of a partition has a majority

![image](https://user-images.githubusercontent.com/44635266/79864833-15043b80-8415-11ea-8a58-5087b35ad6cb.png)

만약 MongoDB 가 하나 이상의 프라이머리를 가지는 것을 지원하면 어려움은 해결될것입니다. 하지만 다중 마스터는 그 자체로 복잡성을 수반합니다. 두 개의 프라이머리를 가지고 있으면 쓰기 충돌을 다루어야 할지도 모릅니다.

이 다중 쓰기를 지원하는 시스템에서의 충돌 상황을 다루는 두 가지 방법이 있는데, 수동 조정 방식과 시스템이 임의의 승자를 선택하도록 하는 방식입니다. 이미 쓴 데이터가 앞으로 변하지 않을 것이라 확신하지 못하므로 개발하기 쉬운 모델이 아닙니다.

그래서 MongoDB 는 오직 단일 프라이머리만 지원합니다.

### How Elections Work

세컨더리가 프라이머리가 되지 못하면 다른 모든 멤버에 이를 알리고 자신을 프라이머리로 선출할 것을 요청합니다. 요청받은 다른 멤버들은 다음과 같은 항목들을 토대로 검사를 수행합니다.

* 요청받은 멤버들이 선출되고자 하는 멤버가 도달할 수 없는 프라이머리에 도달할 수 있는가
* 선출되고자 하는 멤버가 최신화된 복제 데이터를 가지고 있는가
* 선출되어야 하는 더 높은 우선순위를 가진 멤버는 없는가

선출되고자 하는 멤버가 복제 셋의 과반수로부터 찬성 메세지를 받으면 그 멤버는 프라이머리가 됩니다. 만약 한 서버가 거부권을 행사하면 선출은 취소됩니다. 선출되고자 하는 멤버가 프라이머리가 될 수 없는 이유를 인지할 때 다른 멤버는 선출을 거부할 수 있습니다.

거부권은 10,000 표로 등록되어 있기 때문에 로그상에서는 매우 큰 음수를 확인할 수 있습니다. 만약 한 멤버가 다른 멤버를 위해 투표하고 또 다른 멤버가 투표를 거부하는 경우 종종 투표 결과는 다음과 비슷한 메세지를 볼 수 있습니다.

```
Wed Jun 20 17:44:02 [rsMgr] replSet info electSelf 1
Wed Jun 20 17:44:02 [rsMgr] replSet couldn't elect self, only received -9999 votes
```

두 멤버가 투표를 거부하고 한 멤버가 투표한 경우 결과는 19,999 가 되는데 이 메세지들은 정상이며 신경 쓸 필요 없습니다.

선출되기 원하는 멤버는 자신이 도달할 수 있는 멤버들이 알고 있는 한 최신 복제본을 가지고 있어야 합니다. 예를 들어 후보자의 작업이 123 이 가장 최근 작업일 때 다른 멤버들과 통신했을때 그 중 하나가 작업이 124 까지 복제를 수행했다면 해당 멤버는 후보자의 선출을 반대할 것입니다. 후보자는 동기화를 계속하여 작업 124 로 동기화되면 다시 선출을 요구하고 이전에 투표를 거부한 멤버들도 찬성을 할것입니다.

후보자가 과반수로부터 찬성을 얻게 되면 후보자는 프라이머리 상태로 전환합니다.

일반적으로 혼동되는 부분 중 하나는 복제 셋 멤버들이 항상 자신을 위해 스스로 선출 기회를 찾는것입니다. 편의상 이웃 멤버들은 다른 서버가 프라이머리가 되도록 지명할 수 없고 서버가 선출되기를 원할 경우에 투표만 할 수 있습니다.

## Member Configuration Options

지금까지 구성한 복제 셋은 모든 멤버가 모두 다른 멤버와 같은 구성을 가지는 점에서 매우 균일합니다. 하지만 멤버들이 동일하지 않기를 바랄 때도 있습니다.

특정 멤버가 우선적으로 프라이머리가 되게 하거나 읽기 요청이 라우팅될 수 없도록 클라이언트에 특정 멤버가 보이지 않도록 할 수도 있습니다. 이와 같은 구성 옵션들은 복제 셋 구성의 멤버 하위문서에 명시될 수 있습니다. 사용자가 설정할 수 있는 멤버 구성 옵션을 보겠습니다.

### Creating Election Arbiters

MongoDB 는 프라이머리 선출에만 목적을 가지는 **아비터(Arbiter)** 라는 유형의 멤버를 지원합니다. 이는 데이터를 가지지 않으며, 클라이언트에 의해 사용되지 않습니다. 아비터는 오직 2-멤버 복제 셋에서 과반수를 구성하기 위해 존재합니다.

아비터는 `mongod` 서버의 작동에 대해서 어떠한 연관도 없기 때문에 MongoDB 를 사용하는 서버보다 사야이 떨어지는 서버에 경량화 프로세스로 아비터를 실행할 수 있습니다.

`--replSet name` 옵션과 빈 데이터 디렉토리를 이용해 일반적으로 `mongod` 를 시작하는 방식으로 아비터를 시작할 수 있습니다. `rs.addArb()` 보조자를 이용하면 이를 복제 셋에 추가할 수 있습니다.

```js
> rs.addArb("server-5:27017")
```

동일하게, 멤버 구성에서 `arbiterOnly` 옵션을 지정할 수 있습니다.

```js
> rs.add({"_id" : 4, "host" : "server-5:27017", "arbiterOnly" : true})
```

아비터는 일단 복제 셋에 추가되면 영구적으로 아비터로 남습니다. 아비터에서 아비터가 아닌것으로 또는 아비터가 아닌 것을 아비터로 재구성하는 것은 불가능합니다.

아비터의 또 다른 장점은 클러스터 상에서 동점 상황을 없앨 수 있습니다. 만약 짝수 개의 노드를 가지고 있다면 절반 노드는 한 멤버를 위해 투표하고 나머지 절반 노드는 다른 멤버를 위해 투표할 수 있습니다. 이 상황에서 아비터를 추가하면 투표 결과를 결정지을 수 있습니다.

#### 1. Use at most one arbiter

아비터는 하나만 필요합니다. 노드의 개수가 홀수라면 아비터는 필요하지 않습니다. 아비터에 대한 일반적인 오해는 만약의 경우를 대비해서 여분의 아비터를 추가해야 한다고 생각하는 것입니다. 하지만 이 행위는 선출 속도를 빠르게 하거나 여분의 아비터를 추가하는 데 있어 데이터의 안정성을 보장하지 않습니다.

복제 셋에 세 멤버가 있다고 가정하겠습니다. 프라이머리를 선출하기 위해서는 두 멤버가 필요합니다. 아비터를 추가하면 복제 셋은 네 멤버를 가지기 때문에 프라이머리를 선발하는 데 세 멤버가 필요합니다. 따라서 복제 셋은 불안정적인 상태가 되는데, 이는 복제 셋 멤버의 67 % 가 살아야 하는데 이제 75 % 가 살아 있기 떄문입니다.

여분의 멤버를 가지면 선출 시간도 길어질 수 있습니다. 아비터를 추가해 노드의 수가 짝수가되면 아비터는 동점 상황을 초래할 수 있습니다.

#### 2. The downside to using an arbiter

데이터 노드와 아비터 중 하나를 골라야 하면, 데이터 노드를 선택합니다.

작은 규모의 복제 셋에서 아비터를 사용하는 것은 운영 업무를 더 어렵게 만들 수 있습니다. 두 데이터 노드와 하나의 아비터로 운영된 복제 셋을 구동 중일 때 데이터를 가진 멤버가 다운된다면, 현재 세컨더리로 사용 중인 새로운 서버로 데이터 복제본을 가져와야 하므로, 데이터 복사는 서버에 큰 부하를 주게됩니다.

따라서 아비터 대신 홀수 개의 일반 멤버를 추가하는 것이 좋습니다.

### Priority

우선순위는 특정 멤버가 얼마나 프라이머리가 되기를 원하는 지표며, 우선순위는 0 에서 100 까지 지정할 수 있으며 기본값은 1 입니다. 우선순위로 0 을 가진 멤버는 절대 프라이머리가 될 수 없으며, 이러한 멤버들을 수동적 멤버라 합니다.

우선순위가 높은 멤버는 항상 프라이머리로 선출될 수 있습니다. 예를 들어 우선순위가 1.5 인 멤버를 다음과 같이 복제 셋에 추가했다 가정하겠습니다.

```js
> rs.add({"_id" : 4, "host" : "server-4:27017", "priority" : 1.5})
```

복제 셋의 다른 멤버가 우선순위 1 을 가졌다 가정하겠습니다.

`server-4` 가 다른 복제 셋과 같은 최신 데이터로 동괴하되면 현재의 프라이머리는 자동적으로 프라이머리의 자리에 물러나고 `server-4` 가 선출됩니다. 만약 `server-4` 가 복제 셋과 같은 최신 데이터로 동기화되지 못하면 현재의 프라이머리는 계속 프라이머리로서의 자격을 유지합니다. 우선순위를 설정하는 것이 복제 셋에 프라이머리가 없는 상황이 발생하지 않도록 합니다. 또한 최신 데이터를 가지지 못한 멤버가 프라이머리가 되는 현상을 방지할 수 있습니다.

우선순위와 관련하여 재구성은 항상 새로운 구성에서 프라이머리가 될 수 있는 멤버에 보내져야 하는 것입니다. 그러므로 현재 프라이머리의 우선순위를 단일 재구성과 함께 0 으로 설정할 수 없습니다.

우선순위의 값은 복제 셋안의 다른 우선순위보다 큰지 작은지만 중요합니다. 우선순위가 500, 1, 1 인 멤버는 2, 1, 1 과 같은 방식으로 동작합니다.

### Hidden

클라이언트는 숨겨진 멤버에 요청을 라우팅하지 않고, 숨겨진 멤버는 복제 소스로서 바람직하지 않습니다. 따라서 많은 이들이 덜 강력한 서버나 백업 서버를 숨깁니다. 에를 들어 다음과 같은 복제 셋을 가지고 있다고 가정하겠습니다.

```js
> rs.isMaster()
{
    ...
    "hosts" : [
        "server-1:27107",
        "server-2:27017",
        "server-3:27017"
    ],
    ...
}
```

`server-3` 을 숨기려면 `hidden:true` 필드를 구성에 추가합니다. 멤버는 숨겨지려면 우선순위 0 을 가져야합니다.

```js
> var config = rs.config()
> config.members[2].hidden = 0
0
> config.members[2].priority = 0
0
> rs.reconfig(config)
```

`isMaster()` 를 실행하면 다음과 같은 결과를 확인할 수 있습니다.

```js
> rs.isMaster()
{
    ...
    "hosts" : [
        "server-1:27107",
        "server-2:27017"
    ],
    ...
}
```

`rs.status()` 와 `rs.config()` 는 여전히 멤버를 보여줄 것이며, `isMaster()` 에서만 사라집니다. 클라이언트가 복제 셋으로 접속할 때, 복제 셋의 멤버를 확인하기 위해 `isMaster()` 를 호출합니다. 그러므로 숨겨진 멤버는 릭기 요청을 처리하기 위해 사용되지는 않습니다. 멤버를 다시 노출시키려면 `hidden` 옵션을 `false` 로 변경하거나 옵션 전체를 제거합니다.

### Slave Delay

데이터의 에러가 발생하는 상황은 언제든 발생할 수 있습니다. 이 문제를 예방하기 위해 `slaveDelay` 를 설정하여 지연된 세컨더리를 구성할 수 있습니다.

지연된 세컨더리는 명시한 시간만큼 고의로 뒤처집니다. 이 방식으로 누군가 주 컬렉션을 잘못 조작하여 데이터가 바뀐 경우 이전 데이터의 동일한 복제본으로 복구할 수 있습니다.

`slaveDelay` 는 멤버의 우선순위가 0 이 되는 것을 요구합니다. 어플리케이션이 읽기 요청을 세컨더리로 라우팅한다면 지연된 슬레이브 멤버들을 숨겨서 읽기 요청이 라우팅되지 않도록 합니다.

### Building Indexes

때때로 세컨더리는 프라이머리에 존재하는 것과 동일한 인덱스를 가질 필요가 없습니다. 세컨더리를 단지 데이터 백업과 오프라인 배치작업에서만 사용한다면 `buildIndexes : false` 를 멤버의 구성에 명시하고 싶을 것입니다. 이 옵션은 세컨더리가 인덱스를 구축하는 것을 방지합니다.

이는 영구적인 설정이며 `buildIndexes : false` 가 명시된 멤버는 일반적인 인덱스 구축 멤버로 재구성될 수 없습니다. 만약 인덱스 비구축 멤버를 인덱스 구축 멤버로 바꾸고 싶다면 복제 셋에서 멤버를 제거하고 데이터를 모두 지운 뒤 해당 멤버를 다시 복제 셋에 추가하여 처음부터 다시 동기화해야 합니다.

이 옵션은 멤버의 우선순위가 0 이어야 합니다.