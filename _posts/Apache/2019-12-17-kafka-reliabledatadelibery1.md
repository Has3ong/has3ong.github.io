---
title : Kafka Reliable Data Delivery -1-
tags :
- Unclean Leader Election
- Replication
- Kafka
---

*이 포스트는 [Kafka Definitive Guide](https://github.com/Avkash/mldl/blob/master/pages/docs/books/confluent-kafka-definitive-guide-complete.pdf)를 바탕으로 작성하였습니다.*

## Reliability Guarantees

신뢰성을 얘기할 때 우리는 **보장(guarantee)** 을 거론합니다. 

가장 많이 알려진 신뢰성 보장은 ACID 입니다. RDB 가 보편적으로 지원하는 표준화된 신뢰성 보장입니다. ACID 는 **원자성(Atomicity) ,일관성(Consistency), 고립성(Isolation), 지속성(Durability)** 을 의미합니다. 따라서 어떤 데이터베이스가 ACID 를 준수한다면 그것은 트랜잭션 처리와 관련된 약속된 행동을 보장한다는 의미입니다.

이런 보장이 있기 때문에 어플리케이션에서 RDB 를 믿고 사용할 수 있습니다. 그렇다면 Apache Kafka 에서는 무엇을 보장하는지 알아보겠습니다.

1. Kafka 에서는 파티션의 메세지 순서를 보장합니다.
2. 각 파티션의 모든 ISR 에 메세지를 썻다면 해당 메세지는 커밋된 것으로 간주한다.
3. 최소 하나의 레플리카가 살아있다면 커밋된 메세지는 유실되지 않는다.
4. 컨슈머는 커밋된 메세지만 읽을 수 있다.

신뢰성 있는 시스템을 만들기 위해서는 트레이드오프가 수반됩니다. 따라서 Kafka 는 관리자와 개발자들이 필요한 신뢰성의 정도를 조절할 수 있게 개발되었습니다.

신뢰도가 높고 지속적으로 메세지를 저장하는 것의 중요도와 가용성, 높은 처리량, 낮은 지연 시간 하드웨어 비용의 중요도 중 어느것에 더 큰 비중을 둘 것인지 알 수 있습니다.

## Replication

파티션마다 다수의 레플리카를 가질 수 있는 Kafka 의 복제 매커니즘은 신뢰성 보장의 핵심 입니다. 장애 발생시 Kafka 가 메세지의 지속성을 제공하는 방법이 다수의 레플리카에 메세지를 쓰는 것이기 때문이다.

Kafka 의 각 토픽은 데이터를 저장하는 기본 요소인 파티션으로 분할되며, 각 파티션은 하나의 디스크에 저장이 됩니다. Kafka 는 파티션 내부의 메세지 순서를 보장하며, 파티션은 온라인 또는 오프라인이 될 수 있다. 각 파티션은 다수의 레플리카를 가질 수 있으며, 레플리카 중 하나는 리더로 지명되며, 모든 메세지는 리더 레플리카에 쓰거나 읽습니다. 이외의 다른 레플리카들은 팔로워라하며, 리더와 동기화되면서 떄에 맞춰 최근의 모든 메세지를 복제합니다. 만일 리더를 사용할 수 없게 되면 동기화된 레플리카 중 하나가 리더가 됩니다.

레플리카가 파티션의 리더이거나 다음과 같은 팔로워일때 그 레플리카는 동기화되는것으로 간주됩니다.

1. Zookeeper 와 세션이 열결되어 있음(Zookeeper 에게 하트비트를 전송했음)
2. 최근 10초 내에 리더로부터 메세지를 읽었음

만일 위 두 사항을 만족하지 않으면 동기화 되지 않는 것으로 간주하여 Zookeeper 와 다시 연결되어 리더에 저장된 가장 최근 메세지드띾지 복제하면 동기화 상태가 됩니다.

동기화에 약간 뒤쳐진 동기화 레플리카는 프로듀서와 컨슈머의 처리 속도를 저하할 수 있습니다. 메세지가 커밋되기 전에 모든 동기화 레플리카의 메세지 수신을 기다리기 때문입니다. 하지만, 레플리카가 동기화되지 않은 상태면 메세지 수신을 기다리지 않습니다. 이 경우 레플리카는 여전히 동기화가 뒤쳐지겟지만 프로듀서와 컨슈머의 처리 성능에는 영향을 주지 않습니다.

### Replication Factor

토픽 수준에서 **복제 펙터(replication factor)** 를 구성하는 매개변수는 *replication.factor* 입니다. 브로커 수준에서는 자동 생성되는 토픽에 대해 default.replication.factor 매개변수를 설정할 수 있습니다.

복제 팩터가 N 이면 N-1 개의 브로커가 중단되더라도 여전히 토픽의 데이터를 신뢰성 있게 읽거나 쓸 수 있습니다. 따라서 복제 팩터가 클수록 가용성과 신뢰성은 높아지고 장애에 따른 데이터 유실은 적어진다. 바념ㄴ에, 복제 팩터가 N 일 경우 최소한 N 개의 브로커가 필요하고 N 개의 복사본을 저장해야 하므로 N 배의 디스크 공간이 필요하다. 그러므로 가용성을 높이는 대신 하드웨어가 많이 소요된다.

보통 가용성이 중요한 토픽은 복제 팩터를 3으로 설정할 것은 권한다.

레플리카들의 위치도 매우 중요 합니다. 기본적으로 Kafka 는 파티션의 각 레플리카들을 별개의 브로커에 둡니다. 하지만, 파티션의 모든 레플리카들이 같은 랙에 있는 브로커들에 속해있는 경우 랙이 오작동하면 복제 팩터와는 무관하게 파티션의 가용성을 상실하게 됩니다. 따라서 랙 수준의 장애를 방지하기 위해 다수의 랙에 브로커드들을 위치시킨 후 브로커 구성 매개변수인 broker.rack 을 사용해 각 브로커의 랙 이름을 설정할 것은 권한다.

### Unclean Leader Election

이 구성은 브로커 수준에서만 사용할 수 있다. 매개변수 이름은 `unclean.leader.election.enable` 이며 기본값은 true 다.

파티션의 리더를 더 이상 사용할 수 없다면 동기화 레플리카 중 하나가 새로운 리더가 선출된다. 이 경우 데이터가 유실되지 않는다는 것이 보장되므로 이것을 클린 리더 선출이라 한다.

하지만 동기화된 레플리카들이 아예 없다면 어떻게 해야할까.

두 가지 시나리오로 알아보겠습니다.

> Scenario 1

파티션에는 3개의 레플리카가 있는데 2개의 팔로어를 사용할 수 없게 되었다. 프로듀서가 리더에 계속 쓰는 동안 모든 메세지는 수신이 확인되고 커밋된다. 사용할 수 있는 동기화된 레플리카가 리더뿐이기 떄문이다.

다음에는 리더를 사용할 수 없게 된다고 가정해보겠습니다. 비동기화 팔로어 중 하나가 먼저 시작된다면, 결국 해당 파티션의 사용할 수 있지만 유일한 레플리카로 비동기화 팔로어만 남게된다.

> Scenario 2

파티션에 3개의 레플리카가 있다. 네트워크에 문제가 생겨 2개의 팔로어가 복제가 뒤쳐졌다. 그리고 여전이 사용할 수는 있지만 동기화되지 않게 되었다.

이 경우 리더는 유일한 동기화 레플리카가 되어 메세지를 계속 받는다. 그 다음에 리더를 사용할 수 없게 된다면, 두 개의 사용 가능한 레플리카들은 이후로도 계속 동기화될 수 없다.

두 개의 시나리오에서 다음과 같은 판단을 내립니다.

* 비동기화 레플리카를 새로운 리더가 될 수 없게 한다면, 해당 파티션은 이전 리더가 온라인이 될 때까지 오프라인 상태로 남게 된다. 상황에 따라서는 수 시간이 걸릴 수 있다.
* 비동기화 레플리카를 새로운 리거다 될수 있게 한다면, 해당 레플리카가 동기화 되지 않는 동안 이전 리더에 썻던 메세지들을 잃게 되고 컨슈머 간에 일관성도 결여될 수 있다.

비동기화 레플리카가 리더가 될 수 있게 한다면 데이터 유실과 일관성 결여의 위험을 감수해야 하며, 그렇지 않고 리더가 될 수 없게 한다면, 가용성이 떨어지는 것에 직면하게 된다. 원래 리더를 사용할 수 있게 되어 해당 파티션이 다시 온라인 상태로 될 때까지 기다려야한다.

`unclean.leader.election.enable` 를 false 로 설정하면 리더가 온라인이 되기를 기다린다는 의미이므로 가용성이 떨어 질 수 있다. 일반적으로 데이터 품질과 일관성이 중요한 시스템에서는 언클린 리더 선출을 하지 못하게 한다.

### Minimum In-Sync Replicas

토픽과 브로커 구성에 관련된 구성 매개변수로 `min.insync.replicas` 가 있다.

커밋된 데이터를 하나 이상의 레플리카에 확실하게 쓰고자 한다면, 동기화 레플리카의 최소 개수를 더 큰 값으로 설정해야 합니다. 하나의 토픽이 3개의 레플리카를 가질 떄 `min.insync.replicas` 매개변수를 2로 설정하면 3개의 레플리카 중에서 최소 2개가 동기화될 때 토픽의 파티션에 쓸 수 있습니다.

이 경우 3개의 모든 레플리카가 동기화된다면 모든 것이 정상으로 처리됩니다. 만약 3개 중 2개를 사용할 수 없게 되면 브로커들이 더 이상 쓰기 요청을 받지 않게 되며, 데이터를 쓰려고 하는 프로듀서는 NotEnoughReplicasException 에러를 받게 됩니다.

그러나 컨슈머는 기존 데이터를 계속 읽을 수 있습니다. 이 경우 하나의 동기화 레플리카가 읽기 전용이 되는 셈이며, 그럼으로써 바람직하지 않은 데이터를 읽고 쓰는것을 방지하고 언클린 리더가 선출되지 않게 합니다. 

그리고 읽기 전용 상황을 원래대로 복구하기 위해서는 사용 불가능한 2 개의 레플리카 중 하나를 다시 사용할 수 잇게 한 후 밀렸던 메세지를 처리하고 동기화되도록 해야 한다.