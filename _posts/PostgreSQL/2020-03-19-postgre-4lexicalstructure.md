---
title : PostgreSQL Chapter 4. SQL Syntax
tags :
- PostgreSQL
---

## 4.1. Lexical Structure

* [4.1.1. Identifiers and Key Words](#411-identifiers-and-key-words)
* [4.1.2. Constants](#412-constants)
* [4.1.3. Operators](#413-operators)
* [4.1.4. Special Characters](#414-special-characters)
* [4.1.5. Comments](#415-comments)
* [4.1.6. Operator Precedence](#416-operator-precedence)

SQL 입력은 명령문으로 구성되어 있습니다. 명령은 토큰으로 구성되어 있고, 세미콜론(`;`) 으로 끝납니다. 입력 스트림의 끝도 명령을 종료시킵니다. 토큰은 특정 명령 구문에 따라 다릅니다.

토큰은 *Key Word*, *Identifier*, *Quoted Identifier*, *Literal* 또는 *Special Character Symbol* 일 수 있습니다. 토큰 일반적으로 공백(*Space*, *Tab*, *New Line*)으로 구분되지만, 모호성이 없는 경우(일반적으로 특수 문자가 다른 토큰 타입에 인접한 경우) 일 필요는 없습니다. 

예를 들어 아래 SQL 명령은 유효합니다.

```sql
SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');
```

위 예제는 한 줄의 하나씩 3 개의 명령으로 구성되어있습니다. (필요하지는 않지만 하나 이상의 명령이 한 행에있을 수 있으며, 명령이 여러 행에 걸쳐 분할 될 수 있습니다.)

또한 SQL 입력에서 주석을 적을 수 있습니다. 주석은 토큰이 아니며 공백과 같습니다.

SQL 구문은 어떤 토큰이 구문을 식별하고 어떤 피연산자나 매개변수가 꼭 필요하다는 없습니다. 처음 몇 개의 토큰은 일반적으로 명령 이름이므로, 위 예에서는 `SELECT`, `UPDATE`, `INSERT` 구문에 대해 설명합니다. 하지만, `UPDATE` 구문은 항상 특정 위치에 `SET` 토큰이 필요하고, `INSERT` 구문도 실행되기 위해서는 `VALUES` 가 필요합니다. 각 SQL 구문에 대한 정확한 규칙은 [Part 6]() 에 있습니다.

### 4.1.1. Identifiers and Key Words 

위 예에서 `SELECT`, `UPDATE` 또는 `VALUES` 와 같은 토큰은 키워드, 즉 SQL 언어에서 고정 된 의미를 갖는 단어의 예입니다. `MY_TABLE` 및 `A` 토큰은 식별자의 예입니다. 사용되는 구문에 따라 테이블, 칼럼 또는 기타 데이터베이스 개체의 이름을 식별합니다. 따라서 *names* 라고도 표현을 합니다. 키워드와 식별자는 어휘 구조가 같아 언어를 모르면 토큰이 식별자인지, 키워드인지 알 수 없습니다. 키워드의 전체 목록은 [Appendix C](https://www.postgresql.org/docs/12/sql-keywords-appendix.html) 에 있습니다.

SQL 식별자와 키워드는 문자 (a-z뿐만 아니라 분음 부호 및 비 라틴 문자가있는 문자) 또는 밑줄 (`_`)로 시작해야합니다. 식별자 또는 키워드의 후속 문자는 문자, 밑줄, 숫자 (0-9) 또는 달러 기호 ($) 일 수 있습니다. 달러 부호는 SQL 표준에 따라 식별자에서 허용되지 않으므로, 사용 시 응용 프로그램의 휴대성이 떨어질 수 있다는 점에 유의해야 합니다. SQL 표준은 숫자를 포함하거나 밑줄로 시작하거나 밑줄로 끝나는 키워드를 정의하지 않으므로 이 형식의 식별자는 향후 표준 확장과 충돌 할 가능성이 없습니다.

시스템은 `NAMEDATALEN-1` 바이트 이하의 식별자를 사용합니다. 더 긴 이름으로 사용할 수 있지만, 자동으로 잘릴것입니다. 기본적으로 `NAMEDATALEN` 은 64 이므로 최대 식별자 길이는 63 바이트입니다. 이 한계에 문제가 있으면 *src/include/pg_config_manual.h* 에서 `NAMEDATALEN` 상수를 변경하여 증가시킬 수 있습니다.

아래와 같이 키워드 및 따옴표없는 식별자는 대소 문자를 구분하지 않습니다.

```sql
UPDATE MY_TABLE SET A = 5;
```

위 예제는 아래와같이도 사용할 수 있습니다.

```sql
uPDaTE my_TabLE SeT a = 5;
```

하지만, 권고되는 방식은 자주 사용되는 규칙은 키워드를 대문자로 쓰고 이름을 소문자로 쓰는 것입니다. 

```sql
UPDATE my_table SET a = 5;
```

두 종류의 식별자가 있습니다. **구분 식별자(Delimited Identifier)** 와 **참조 식별자(Quoted Indetifier)** 입니다. 문자를 큰 따옴포(`"`) 로 묶어서 구성합니다. 구분 식별자는 항상 식별자이며, 키워드가 아닙니다. 따라서 `SELECT` 는 `select` 이름을 가진 칼럼 또는 테이블을 참조하는 데 사용될 수 있지만 인용되지 않은 선택은 키워드로 간주되므로 테이블 또는 칼럼 이름이 예상되는 경우에는 구문 분석 오류가 발생합니다. 예제는 다음과 같이 큰 따옴표 붙은 식별자로 작성할 수 있습니다.

즉 `SELECT select` 와 같이 사용하면 오류가 발생하고 `SELECT "select"` 와 같이 사용해야합니다.

```sql
UPDATE "my_table" SET "a" = 5;
```

인용 부호는 코드가 0 인 문자를 제외한 모든 문자를 사용할 수 있습니다.(큰 따옴표를 포함하려면 두 개의 큰 따옴표를 쓰십시오.) 이렇게하면 공백이나 앰퍼샌드를 포함하는 것과 같이 불가능한 테이블 또는 칼럼 이름을 만들 수 있습니다. 길이 제한은 여전히 적용됩니다.

따옴표 붙은 식별자의 변형으로 코드 포인트로 식별 된 이스케이프 된 유니코드 문자를 포함 할 수 있습니다. 이 변형은 큰 따옴표 바로 앞의 `U &` (대문자 U 와 소문자 u 다음에 앰퍼샌드)로 시작합니다 (예 :`U & "foo"`). (이는 연산자 `&` 와 모호한 문제가 발생 할 수 있으니, 이 문제를 피하려면 연산자 주위에 공백을 사용하시면 됩니다.). 따옴표 안에는 백 슬래시(\) 뒤에 4 자리 16 진수 코드 포인트 번호를 입력하거나 백 슬래시 뒤에 더하기 부호와 6 자리 16 진수 코드 포인트 번호를 작성하여 이스케이프 형식으로 유니코드 문자를 지정할 수 있습니다.

예를 들어 식별자 `data` 는 다음과 같이 쓸 수 있습니다.

```sql
U&"d\0061t\+000061"
```

다음의 간단한 예는 러시아어 단어 "slon"(코끼리) 을 키릴 문자로 씁니다.

```sql
U&"\0441\043B\043E\043D"
```

백 슬래시와 다른 이스케이프 문자가 필요한 경우 문자열 뒤에 `UESCAPE` 절을 사용하여 지정할 수 있습니다. 예를 들면 다음과 같습니다.

```sql
U&"d!0061t!+000061" UESCAPE '!'
```

이스케이프 문자는 16 진수, 더하기 부호, 작은 따옴표, 큰 따옴표 또는 공백 문자 이외의 단일 문자 일 수 있습니다. 이스케이프 문자는 큰 따옴표가 아닌 작은 따옴표로 작성됩니다.

식별자에 이스케이프 문자를 문자 그대로 포함하려면 두 번 사용하시면 됩니다.

유니코드 이스케이프 구문은 서버 인코딩이 `UTF8` 인 경우에만 작동합니다. 다른 서버 인코딩을 사용하는 경우 ASCII 범위 (최대 `\007F`)의 코드 포인트 만 지정할 수 있습니다. 4 자리(4-digit) 및 6 자리(6-digit) 형식 모두 UTF-16 대리 쌍을 지정하여 U+FFFF 보다 큰 코드 포인트를 가진 문자를 구성하는 데 사용될 수 있지만 6 자리 형식의 사용 가능성은 기술적으로 이를 불필요하게 만듭니다. (대리 쌍은 직접 저장되지 않고 단일 코드 포인트로 결합 된 다음 UTF-8 로 인코딩됩니다.)

인용 부호를 인용하면 대소 문자를 구분하지만 인용되지 않은 이름은 항상 소문자가 됩니다. 예를 들어 식별자 `FOO`, `foo` 및 `"foo"` 는 PostgreSQL 에서 동일한 것으로 간주되지만 `"Foo"` 및 `"FOO"` 는 세 가지와 다릅니다. (PostgreSQL 에서 인용되지 않은 이름을 소문자로 작성하는 것은 SQL 표준과 호환되지 않으므로 인용되지 않은 이름은 대문자로 작성해야 합니다. 따라서 `foo` 는 표준에 따라 `"foo"` 가 아닌 `"FOO"` 와 동일합니다. 이식성이 좋은 응용 프로그램을 작성하려면 항상 특정 이름을 인용하거나 인용하지 않는 것이 좋습니다.)

### 4.1.2. Constants

PostgreSQL에는 3 가지 종류의 암묵적 타입(*Implicitly-Typed*) 상수가 있습니다 : *String*, *Bit String*, *Number*. 상수는 명시적 타입(*Explicit-Type*) 으로도 지정할 수 있으므로 시스템에서 정확한 표현과 효율적인 처리가 가능합니다. 이러한 방법은 하위 섹션에서 살펴보겠습니다.

#### 4.1.2.1. String Constants

SQL 의 문자열 상수는 작은 따옴표 (`'`)로 묶인 임의의 문자 시퀀스입니다. 예를 들어 `'This is a string'` 입니다. 문자열 상수 내에 작은 따옴표 문자를 포함 시키려면 두 개의 인접한 작은 따옴표 (예 : `'Dianne''s horse'`)를 사용하시면 됩니다. 이것은 큰 따옴표 문자 (`"`)와 동일하지 않습니다.

최소한 하나의 줄 바꿈이있는 공백으로만 구분되는 두 개의 문자열 상수는 문자열이 하나의 상수로 작성된 것처럼 연결되고 효과적으로 처리됩니다. 예를 들면 다음과 같습니다.

```sql
SELECT 'foo'
'bar';
```

아래와 동일합니다.

```sql
SELECT 'foobar';
```

하지만 아래 구문은 유효하지 않습니다.

```sql
SELECT 'foo'      'bar';
```

#### 4.1.2.2. String Constants With C-Style Escapes

PostgreSQL은 SQL 표준의 확장 “이스케이프” 문자열 상수도 허용합니다. 이스케이프 문자열 상수는 여는 작은 따옴표 바로 앞에 문자 `E` (대문자 또는 소문자) 를 쓰면 지정됩니다 (예 : `E'foo'`). (줄간에 이스케이프 문자열 상수를 사용할 때는 첫 번째 여는 인용 부호 앞에 `E` 만 사용하면 됩니다.) 이스케이프 문자열 내에서 백 슬래시 문자 (\)는 C 와 유사한 백 슬래시 이스케이프 시퀀스를 시작합니다. 이 시퀀스에서는 백 슬래시와 다음 문자의 조합이 특수 바이트 값을 나타냅니다. [Table 1]

##### Table 4.1. - Backslash Escape Sequences

|Backslash Escape Sequence|Interpretation|
|:--|:--|
|`\b`|backspace|
|`\f`|form feed|
|`\n`|new line|
|`\r`|carriage return|
|`\t`|tab|
|`\o, \oo, \ooo (o = 0 - 7)`|octal byte value|
|`\xh, \xhh (h = 0 - 9, A - F)`|hexadecimal byte value|
|`\uxxxx, \Uxxxxxxxx (x = 0 - 9, A - F)`|16 or 32-bit hexadecimal Unicode character value|

백 슬래시 뒤의 다른 문자는 그대로 사용됩니다. 따라서 백 슬래시 문자를 포함 시키려면 두 개의 백 슬래시 (`\\`)를 사용해야합니다. 또한, `''` 방법 외에도 `\'` 를 작성하여 이스케이프 문자열에 작은 따옴표를 포함시킬 수 있습니다.

특히 8 진 또는 16 진 이스케이프를 사용할 때 작성하는 바이트 시퀀스는 서버 문자 세트 인코딩에서 유효한 문자를 작성해야합니다. 서버 인코딩이 UTF-8 인 경우, [Section 4.1.2.3](#4123-string-constants-with-unicode-escapes) 에서 설명한 유니코드 이스케이프 또는 대체 유니코드 이스케이프 구문을 대신 사용해야합니다. (대체 UTF-8 인코딩을 직접 수행하고 바이트를 작성하는 것이 번거로울 수 있습니다.)

유니코드 이스케이프 구문은 서버 인코딩이 `UTF8` 인 경우에만 완벽하게 작동합니다. 다른 서버 인코딩을 사용하는 경우 ASCII 범위 (최대 `\u007F`) 의 코드 포인트 만 지정할 수 있습니다. 4 자리 및 8 자리 형식 모두 UTF-16 대리 쌍을 지정하여 U+FFFF 보다 큰 코드 포인트를 가진 문자를 구성하는 데 사용할 수 있지만 기술적으로 8 자리 형식을 사용할 수 있으므로 불필요합니다. 서버 인코딩이 UTF8 일 때 서로 게이트 쌍을 사용하는 경우 먼저 단일 코드 포인트로 결합 된 다음 UTF-8 로 인코딩됩니다.

> Caution : 구성 매개 변수 `standard_conforming_strings` 가 해제 된 경우 PostgreSQL 은 정규 및 이스케이프 문자열 상수에서 백 슬래시 이스케이프를 인식합니다. 그러나 PostgreSQL 9.1에서 기본값은 켜져 있습니다. 즉, 백 슬래시 이스케이프는 이스케이프 문자열 상수에서만 인식됩니다. 이 동작은 표준을 준수하지만 백 슬래시 이스케이프가 항상 인식 되어있어 이전에 기록된 동작에 의존하는 응용 프로그램을 중단 할 수 있습니다. 이 문제를 해결하기위해 매개 변수를 off 로 설정할 수 있지만 백 슬래시 이스케이프를 사용하지 않는 것이 좋습니다. 특수 문자를 나타 내기 위해 백 슬래시 이스케이프를 사용해야하는 경우 문자열 상수를 `E` 로 작성하시면 됩니다. `standard_conforming_strings` 외에도, 구성 매개 변수 `escape_string_warning` 및 `backslash_quote` 는 문자열 상수에서 백 슬래시 처리를 제어합니다.

코드가 0 인 문자는 문자열 상수에 있을 수 없습니다.

#### 4.1.2.3. String Constants With Unicode Escapes

PostgreSQL 은 코드 포인트별로 임의의 유니코드 문자를 지정할 수있는 문자열에 대한 다른 타입의 이스케이프 구문도 지원합니다. 유니코드 이스케이프 문자열 상수는 여는 따옴표 바로 앞에 `U & 'foo'` 와 같은 공백없이 `U&` (대문자 소문자 U 와 앰퍼샌드) 로 시작합니다. (이것은 연산자 `&` 와 모호성을 만들 수 있습니다. 이 문제를 피하려면 연산자 주위에 공백을 사용해야합니다.) 따옴표 안에는 백 슬래시 뒤에 4 자리 16 진수 코드 포인트 번호를 입력하거나 백 슬래시 뒤에 더하기 부호와 6 자리 16 진수 코드 포인트 번호를 작성하여 이스케이프 형식으로 유니코드 문자를 지정할 수 있습니다. 예를 들어 문자열 `data` 는 다음과 같이 쓸 수 있습니다.

```sql
U&'d\0061t\+000061'
```

다음의 간단한 예는 러시아어 단어 "slon"(코끼리) 을 키릴 문자로 씁니다.

```sql
U&'\0441\043B\043E\043D'
```

백 슬래시와 다른 이스케이프 문자가 필요한 경우 문자열 뒤에 `UESCAPE` 절을 사용하여 지정할 수 있습니다. 예를 들면 다음과 같습니다.

```sql
U&'d!0061t!+000061' UESCAPE '!'
```

이스케이프 문자는 16 진수, 더하기 부호, 작은 따옴표, 큰 따옴표 또는 공백 문자 이외의 단일 문자 일 수 있습니다.

유니코드 이스케이프 구문은 서버 인코딩이 `UTF8` 인 경우에만 완벽하게 작동합니다. 다른 서버 인코딩을 사용하는 경우 ASCII 범위 (최대 `\u007F`) 의 코드 포인트 만 지정할 수 있습니다. 4 자리 및 8 자리 형식 모두 UTF-16 대리 쌍을 지정하여 U+FFFF 보다 큰 코드 포인트를 가진 문자를 구성하는 데 사용할 수 있지만 기술적으로 8 자리 형식을 사용할 수 있으므로 불필요합니다. 서버 인코딩이 UTF8 일 때 서로 게이트 쌍을 사용하는 경우 먼저 단일 코드 포인트로 결합 된 다음 UTF-8 로 인코딩됩니다.

또한 문자열 상수에 대한 유니코드 이스케이프 구문은 구성 매개 변수`standard_conforming_strings` 가 설정된 경우에만 작동합니다. 그렇지 않으면 이 구문은 SQL 문을 구문 분석하는 클라이언트가 SQL 삽입 및 이와 유사한 보안 문제를 야기 할 수있는 지점으로 혼동 될 수 있기 때문입니다. 매개 변수가 off 로 설정되면 이 구문은 오류 메시지와 함께 거부됩니다.

문자열에 이스케이프 문자를 포함 시키려면 두 번 사용하시면 됩니다. 

#### 4.1.2.4. Dollar-Quoted String Constants

문자열 상수를 지정하는 표준 구문은 일반적으로 편리하지만 각 문자열을 두 배로 늘려야하므로 원하는 문자열에 작은 따옴표 나 백 슬래시가 많은 경우 이해하기 어려울 수 있습니다.이러한 상황에서 더 읽기 쉬운 쿼리를 허용하기 위해 PostgreSQL은 *dollar quoting* 이라는 다른 방법을 사용하여 문자열 상수를 작성합니다. 달러 인용 문자열 상수는 달러 기호 (`$`$, 0 개 이상의 문자로 구성된 선택적 *tag*, 다른 달러 기호, 문자열 내용을 구성하는 임의의 문자 시퀀스, 달러 기호, 이 작은 따옴표와 달러 기호를 시작했습니다. 예를 들어, 달러 인용을 사용하여 문자열 `Dianne 's horse` 를 지정하는 두 가지 방법이 있습니다.

```sql
$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$
```

달러 인용 문자열 내에서 이스케이프하지 않고 작은 따옴표를 사용할 수 있습니다. 실제로, 달러 인용 문자열 내부의 문자는 이스케이프 처리되지 않습니다. 문자열 내용은 항상 문자 그대로 작성됩니다. 백슬래시는 특수하지 않으며 시작 태그와 일치하는 시퀀스의 일부가 아니며 달러 기호도 아닙니다.

각 중첩 수준에서 다른 태그를 선택하여 달러 인용 문자열 상수를 중첩 할 수 있습니다. 이것은 함수 정의를 작성할 때 가장 일반적으로 사용됩니다. 예를 들면 다음과 같습니다.

```sql
$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$
```

여기서 `$q$[\t\r\n\v\\]$q$` 시퀀스는 달러 인용 리터럴 문자열 `[\t\r\n\v\\]` 을 나타내며 함수 본문에서 인식되어 PostgreSQL 에 의해 실행됩니다. 그러나 시퀀스가 외부 달러 인용 구분 기호 `$function$` 와 일치하지 않기 때문에 외부 문자열에 관한 한 상수 내에 더 많은 문자가 있습니다.

달러 인용 문자열의 태그(있는 경우) 는 인용 부호를 포함 할 수 없다는 점을 제외하고는 인용되지 않은 식별자와 동일한 규칙을 따릅니다. 태그는 대소 문자를 구분하므로`$tag$String content$tag$` 는 정확하지만, `$TAG$String content$tag$` 는 정확하지 않습니다.

키워드나 식별자 뒤에 오는 달러 인용 문자열은 공백으로 구분해야합니다. 그렇지 않으면 달러 인용 구분 기호가 선행 식별자의 일부로 사용됩니다.

달러 인용은 SQL 표준의 일부는 아니지만, 종종 표준 호환 작은 따옴표 구문보다 복잡한 문자열 리터럴을 작성하는 것이 더 편리한 방법입니다. 프로시저 함수 정의에서 종종 필요한 것처럼 다른 상수 내에서 문자열 상수를 나타낼 때 특히 유용합니다. 작은 따옴표 구문을 사용하는 경우, 위의 예에서 각 백슬래시를 4개의 백슬래시로 작성해야 하는데, 이 백슬래시는 원래 문자열 상수를 구문 분석할 때 2개의 백슬래시로 감소하고, 그 다음 기능 실행 중에 내부 문자열 상수가 다시 폴링될 때 1개로 감소한다.

#### 4.1.2.5. Bit-String Constants

비트 열 상수는 여는 따옴표 바로 앞에 `B` (대문자 공백 또는 소문자) 가있는 일반 문자열 상수처럼 보입니다 (예 : `B'1001'`). 비트 열 상수 내에서 허용되는 유일한 문자는 `0` 과 `1` 입니다.

또는, `X` (대문자 또는 소문자) (예 : `X'1FF'`) 를 사용하여 비트 열 상수를 16 진수 표기법으로 지정할 수 있습니다. 이 표기법은 각 16 진수에 4 개의 2 진수가있는 비트 열 상수와 같습니다.

비트 스트링 상수의 두 가지 형식은 일반 스트링 상수와 같은 방식으로 여러 행에 걸쳐 계속 될 수 있습니다. 달러 인용은 비트 스트링 상수에서 사용될 수 없습니다.

#### 4.1.2.6. Numeric Constants

숫자 상수는 다음과 같은 일반적인 형식으로 허용됩니다.

```sql
digits
digits.[digits][e[+-]digits]
[digits].digits[e[+-]digits]
digitse[+-]digits
```

여기서 `digits` 는 하나 이상의 10 진수 숫자 (0-9)입니다. 소수점을 사용하는 경우 하나 이상의 숫자가 소수점 앞뒤에 있어야 합니다. 지수 표기식(e) 가 있는 경우 하나 이상의 숫자가 지수 표기식(e) 를 따라야합니다. 상수에는 공백이나 다른 문자가 포함될 수 없습니다. 선행 플러스 마이너스 기호는 실제로 상수의 일부로 간주되지 않으며, 상수에 적용되는 연산자라는 점에 유의하십시오.

다음은 유효한 숫자 상수의 예입니다.

* 42
* 3.5
* 4.
* .001
* 5e2
* 1.925e-3

소수점이나 지수를 포함하지 않는 숫자 상수는 초기 값이 `integer` (32 비트) 타입에 맞는 경우 `integer` 타입으로 가정됩니다. 그렇지 않으면 값이 `bigint` (64 비트) 타입에 맞는 경우 `bigint` 타입으로 추정됩니다. 그렇지 않으면 `numeric` 로 간주됩니다. 소수점 및 / 또는 지수를 포함하는 상수는 항상 처음에는 `numeric` 로 가정합니다.

숫자 상수의 초기에 할당 된 데이터 타입은 타입 분석 알고리즘의 시작점 일뿐입니다. 대부분의 경우 상수는 상황에 따라 가장 적합한 타입으로 자동 강제됩니다. 필요한 경우 숫자 값을 캐스팅하여 특정 데이터 타입으로 해석하도록 할 수 있습니다. 예를 들어 다음과 같이 작성하여 숫자 값을 `real` (`float4`) 타입으로 취급 할 수 있습니다.

```sql
REAL '1.23'  -- string style
1.23::REAL   -- PostgreSQL (historical) style
```

이것들은 실제로 다음에 논의되는 일반적인 캐스팅 표기법의 특별한 경우입니다.

#### 4.1.2.7. Constants Of Other Types

다음 표기법 중 하나를 사용하여 *arbitrary* 타입의 상수를 입력 할 수 있습니다.

```sql
type 'string'
'string'::type
CAST ( 'string' AS type )
```

문자열 상수의 텍스트는 `type` 이라는 타입의 입력 변환 루틴으로 전달됩니다. 결과는 표시된 타입의 상수입니다. 상수에 대한 모호성이없는 경우 명시적 타입 캐스트를 생략 할 수 있습니다 (예 : 테이블 열에 직접 지정된 경우). 이 경우 자동으로 강제 변환됩니다.

문자열 상수는 일반 SQL 표기법 또는 달러 인용을 사용하여 작성할 수 있습니다.

함수와 같은 구문을 사용하여 타입 강제 변환을 지정할 수도 있습니다.

```sql
typename ( 'string' )
```

그러나 모든 타입 이름을 이런 식으로 사용할 수있는 것은 아닙니다. 자세한 내용은 [Section 4.2.9]() 를 참조하시면 됩니다.

`::`, `CAST ()` 및 함수 호출 구문을 사용하여 [Section 4.2.9]() 에 설명 된대로 임의 표현식의 런타임 타입 변환을 지정할 수도 있습니다. 구문 상 모호성을 피하기 위해 `type` `string` 구문은 간단한 리터럴 상수의 타입을 지정하는 데만 사용할 수 있습니다. `type` `string` 구문에 대한 다른 제한 사항은 배열 타입에 대해 작동하지 않는다는 것입니다. `::` 또는 `CAST ()` 를 사용하여 배열 상수의 타입을 지정해야합니다.

`CAST()` 구문은 SQL 을 따릅니다. `type` `string` 구문은 일반적인 표준입니다. SQL 은 구문을 몇 가지 데이터 타입에 대해서만 지정하지만 PostgreSQL 은 모든 타입에 대해 구문을 허용합니다. `::`  구문은 함수 호출 구문과 마찬가지로 역사적인 PostgreSQL 사용법입니다.

### 4.1.3. Operators

연산자 이름은 다음 목록에서 최대 `NAMEDATALEN-1`(63 기본값) 의 문자열이다.

*+ - * / < > = ~ ! @ # % ^ & | ` ?*

하지만 연산자 이름에는 몇 가지 제한 사항이 있습니다.

* `-` 및 `/*` 는 주석의 시작으로 간주되므로 연산자 이름의 어느 곳에도 나타날 수 없습니다.
* 이름에 다음 문자 중 하나 이상이 포함되어 있지 않으면 여러 문자 연산자 이름은 `+` 또는 `-` 로 끝날 수 없습니다.
  * *~ ! @ # % ^ & | ` ?*
  * 예를 들어 `@-` 는 허용되는 연산자 이름이지만 `*-` 는 아닙니다. 이 제한 사항으로 PostgreSQL 은 토큰 사이에 공백없이 SQL 호환 쿼리를 구문 분석 할 수 있습니다.

비 SQL 표준 연산자 이름으로 작업 할 때는 일반적으로 모호성을 피하기 위해 인접한 연산자를 공백으로 구분해야합니다. 예를 들어, `@` 라는 왼쪽 단항 연산자를 정의한 경우 `X*@Y` 를 쓸 수 없습니다. PostgreSQL 이 하나가 아닌 두 개의 연산자 이름으로 읽도록 `X* @Y` 를 작성해야합니다.

### 4.1.4. Special Characters

영숫자가 아닌 일부 문자는 연산자와 다른 특별한 의미를 갖습니다. 사용법에 대한 세부 사항은 각 구문 요소가 설명 된 위치에서 찾을 수 있습니다. 이 섹션에서는 이러한 문자 종류가 있고 어떤 목적으로 사용하는지만 알면됩니다.

* 함수 기호 또는 준비된 명령문의 본문에서 위치 매개 변수를 나타내는 데 달러 기호 (`$`) 와 숫자가 사용됩니다. 다른 맥락에서, 달러 부호는 식별자 또는 달러 인용 문자열 상수의 일부일 수 있습니다.
* 괄호 (`()`) 는 표현식을 그룹화하고 우선 순위를 적용한다는 일반적인 의미를 갖습니다. 경우에 따라 특정 SQL 명령의 고정 구문의 일부로 괄호가 필요합니다.
* 대괄호 (`[]`) 는 배열의 요소를 선택하는 데 사용됩니다. 배열에 대한 자세한 내용은 [Section 8.15]() 을 참조하십시오.
* 쉼표 (`,`) 는 일부 구문 구조에서 목록의 요소를 구분하는 데 사용됩니다.
* 세미콜론 (`;`) 은 SQL 명령을 종료합니다. 문자열 상수 또는 따옴표 붙은 식별자를 제외하고는 명령 내 어디에나 나타날 수 없습니다.
* 콜론 (`:`) 은 배열에서 "슬라이스"를 선택하는 데 사용됩니다. ([Section 8.15]() 참조) 특정 SQL 언어 (예 : Embedded SQL) 에서 콜론은 변수 이름 앞에 접두사를 사용합니다.
* 별표 (`*`) 는 일부 컨텍스트에서 테이블 행의 모든 ​​필드 또는 복합 값을 나타내는 데 사용됩니다. 또한 집계 함수의 인수로 사용될 때 특별한 의미를 갖습니다. 즉 집계에는 명시적인 매개 변수가 필요하지 않습니다.
* 마침표 (`.`) 는 숫자 상수에 사용되며 스키마, 테이블 및 열 이름을 구분합니다.

### 4.1.5. Comments

주석은 이중 대시(`--`) 로 시작하고 줄의 끝까지 확장되는 일련의 문자입니다.

```sql
-- This is a standard SQL comment
```

C 언어 스타일로도 주석 블록을 사용할 수 있습니다.

```sql
/* multiline comment
 * with nesting: /* nested block comment */
 */
```

여기서 주석은 `/*` 로 시작하고 일치하는 `*/` 까지 확장됩니다. 이러한 블록 주석은 SQL 표준에 지정되어 있지만 C 와 달리 중첩되므로 기존 블록 주석을 포함 할 수있는 더 큰 코드 블록을 주석 처리 할 수 있습니다.

주석은 추가 구문 분석 전에 입력 스트림에서 제거되며 공백으로 효과적으로 대체됩니다.

### 4.1.6. Operator Precedence

[Table 4.2](#table-42-operator-precedence-highest-to-lowest) 는 PostgreSQL에서 연산자의 우선 순위와 연관성을 보여줍니다. 대부분의 연산자는 동일한 우선 순위를 가지며 왼쪽 연관입니다. 연산자의 우선 순위와 연관성은 파서에 고정되어 있습니다.

이진 연산자와 단항 연산자의 조합을 사용할 때 괄호를 추가해야하는 경우가 있습니다. 

```sql
SELECT 5 ! - 6;
```

위 구문은 다음과 같이 파싱됩니다.

```sql
SELECT 5 ! (- 6);
```

파서는 `—` 를 전혀 알지 못하기 때문에,  `!` 는 인픽스 연산자가 아니라 포스트픽스 연산자로 정의된다. 이 경우 원하는 동작을 얻으려면 다음을 작성해야 한다

```sql
SELECT (5 !) - 6;
```

이것은 확장성을 위해 지불하는 대가입니다.

##### Table 4.2. Operator Precedence (highest to lowest)

|Operator/Element|Associativity|Description|
|:--|:--|:--|
|.|left|table/column name separator|
|::|left|PostgreSQL-style typecast|
|[ ]|left|array element selection|
|+ -|right|unary plus, unary minus|
|^|left|exponentiation|
|* / %|left|multiplication, division, modulo|
|+ -|left|addition, subtraction|
|(any other operator)|left|all other native and user-defined operators|
|BETWEEN IN LIKE ILIKE SIMILAR||range containment, set membership, string matching|
|< > = <= >= <>||comparison operators|
|IS ISNULL NOTNULL||IS TRUE, IS FALSE, IS NULL, IS DISTINCT FROM, etc|
|NOT|right|logical negation|
|AND|left|logical conjunction|
|OR|left|logical disjunction|

연산자 우선 순위 규칙은 위에서 언급 한 내장 연산자와 이름이 같은 사용자 정의 연산자에도 적용됩니다. 예를 들어, 일부 사용자 정의 데이터 유형에 대해 `+` 연산자를 정의하면 사용자의 작업에 관계없이 기본 제공 `+` 연산자와 동일한 우선 순위를 갖습니다.

스키마 규정 연산자 이름이 `OPERATOR` 구문에서 사용되는 경우 다음과 같습니다.

```sql
SELECT 3 OPERATOR(pg_catalog.+) 4;
```

`OPERATOR` 구문은 “다른 연산자” 에 대해 [Table 4.2](#table-42-operator-precedence-highest-to-lowest) 표시된 기본 우선 순위를 갖습니다. 이것은 `OPERATOR()` 안에 어떤 특정 연산자가 나타나는지에 관계없이 적용됩니다.

> Note : 9.5 이전의 PostgreSQL 버전은 약간 다른 연산자 우선 순위 규칙을 사용했습니다. 특히 `<=` `> =` 및 `<>` 는 일반 연산자로 취급되었습니다. `IS` 테스트는 우선 순위가 높았습니다. 그리고 `NOT BETWEEN` 과 관련 구성은 일관성이 없어서 어떤 경우에는 `BETWEEN` 이 아닌 `NOT` 의 우선 순위를 갖는 것으로 간주됩니다. 이러한 규칙은 SQL 표준을보다 잘 준수하고 논리적으로 동등한 구문의 일관성없는 처리로 인한 혼동을 줄이기 위해 변경되었습니다. 대부분의 경우 이러한 변경으로 인해 동작이 변경되지 않거나 괄호를 추가하여 해결할 수 있는 *no such operator* 오류가 발생할 수 있습니다. 그러나 구문 분석 오류가보고되지 않고 쿼리가 동작을 변경할 수 있는 경우가 있습니다. 이러한 변경 사항이 자동으로 손상되었는지 여부에 대해 우려가있는 경우 구성 매개 변수 `operator_precedence_warning` 을 설정하여 애플리케이션을 테스트하여 경고가 기록되는지 확인할 수 있습니다.