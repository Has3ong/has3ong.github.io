---
title : PostgreSQL Chapter 5. Data Definition
tags :
- PostgreSQL
---

## 5.4. System Columns

모든 테이블에는 시스템에의해 암시적으로 정의된 여러 `system` 칼럼이 있습니다. 따라서 이러한 이름은 사용자 정의 칼럼의 이름으로 사용할 수 없습니다. (이러한 제한은 이름이 키워드인지 아닌지와 별개입니다. 이름을 인용해도 이러한 제한을 벗어날 수는 없습니다.) 실제로 이 칼럼에 대해 걱정할 필요는 없습니다. 이미 존재한다고 알고있습니다.

* `tableoid`
  * 이 행을 포함하는 테이블의 OID. 이 칼럼은 상속 계층에서 선택하는 쿼리에 특히 유용합니다 ([Section 5.10]() 참조). 왜냐하면 이 칼럼이 없으면 행이 어느 개별 테이블에서 왔는지 구별하기 어렵기 때문입니다. `tableoid` 는 `pg_class` 의 `oid` 열에 대해 결합하면 테이블 이름을 얻을 수 있습니다.

* `xmin`
  * 이 행 버전에 대한 삽입 트랜잭션의 ID (트랜잭션 ID)입니다. (행 버전은 행의 개별 상태입니다. 행을 업데이트할 때마다 동일한 논리 행에 대해 새 행 버전이 작성됩니다.)

* `cmin`
  * 삽입 트랜잭션 내에서 명령 식별자 (0부터 시작)

* `xmax`
  * 삭제 트랜잭션의 ID (트랜잭션 ID)이거나 삭제되지 않은 행 버전의 경우 0입니다. 보이는 행 버전에서 이 칼럼이 0 이 아닌 것이 가능합니다. 일반적으로 삭제 트랜잭션이 아직 커밋되지 않았거나 삭제 시도가 롤백되었음을 나타냅니다.

* `cmax`
  * 삭제 트랜잭션 내의 명령 식별자 또는 0

* `ctid`
  * 테이블 내에서 행 버전의 실제 위치입니다. `ctid` 를 사용하여 행 버전을 매우 빠르게 찾을 수 있지만 `VACUUM FULL` 에 의해 행 또는 `ctid` 가 업데이트되거나 이동되면 행의 `ctid` 가 변경됩니다. 따라서 `ctid` 는 장기 행 식별자로 쓸모가 없습니다. 논리 키를 식별하려면 기본 키를 사용해야합니다.

트랜잭션 식별자도 32 비트입니다. 오래 지속되는 데이터베이스에서는 트랜잭션 ID 가 둘러 싸여 있을 수 있다. 이는 적절한 유지보수 절차를 고려할 때 치명적인 문제가 아닙니다. 자세한 내용은 [Chapter 24]() 을 참조하십시오. 그러나 장기적으로 트랜잭션 ID 의 고유성 (10 억 개 이상의 트랜잭션)에 의존하는 것은 현명하지 않습니다.

명령 식별자도 32 비트입니다. 이는 단일 트랜잭션 내에서 $2^{32}$ (40 억) 개의 SQL 한도가 생성됩니다. 실제로 이 제한은 문제가 아닙니다 — 제한은 처리된 행의 수가 아니라 SQL 명령의 수에 있다는 점에 유의하면됩니다. 또한 실제로 데이터베이스 내용을 수정하는 명령만 명령 식별자를 소비하게 됩니다.



